)]}'
{"version": 3, "sources": ["/web_studio/static/src/client_action/action_editor/action_editor.js", "/web_studio/static/src/client_action/app_creator/app_creator.js", "/web_studio/static/src/client_action/editor/app_menu_editor/app_menu_editor.js", "/web_studio/static/src/client_action/editor/edition_flow.js", "/web_studio/static/src/client_action/editor/editor.js", "/web_studio/static/src/client_action/editor/editor_menu/editor_menu.js", "/web_studio/static/src/client_action/editor/new_model_item/new_model_item.js", "/web_studio/static/src/client_action/editor/new_view_dialogs/map_new_view_dialog.js", "/web_studio/static/src/client_action/editor/new_view_dialogs/new_view_dialog.js", "/web_studio/static/src/client_action/editor/studio_action_container.js", "/web_studio/static/src/client_action/icon_creator/icon_creator.js", "/web_studio/static/src/client_action/menu_creator/menu_creator.js", "/web_studio/static/src/client_action/model_configurator/model_configurator.js", "/web_studio/static/src/client_action/navbar/home_menu_customizer/home_menu_customizer.js", "/web_studio/static/src/client_action/navbar/navbar.js", "/web_studio/static/src/client_action/report_editor/error_display.js", "/web_studio/static/src/client_action/report_editor/report_editor.js", "/web_studio/static/src/client_action/report_editor/report_editor_iframe.js", "/web_studio/static/src/client_action/report_editor/report_editor_model.js", "/web_studio/static/src/client_action/report_editor/report_editor_snackbar.js", "/web_studio/static/src/client_action/report_editor/report_editor_wysiwyg/report_editor_wysiwyg.js", "/web_studio/static/src/client_action/report_editor/report_editor_wysiwyg/studio_dynamic_placeholder_popover.js", "/web_studio/static/src/client_action/report_editor/report_editor_xml/report_editor_xml.js", "/web_studio/static/src/client_action/report_editor/report_editor_xml/report_record_navigation.js", "/web_studio/static/src/client_action/report_editor/utils.js", "/web_studio/static/src/client_action/studio_client_action.js", "/web_studio/static/src/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog.js", "/web_studio/static/src/client_action/studio_home_menu/studio_home_menu.js", "/web_studio/static/src/client_action/utils.js", "/web_studio/static/src/client_action/view_editor/default_view_sidebar/default_view_sidebar.js", "/web_studio/static/src/client_action/view_editor/editors/calendar/calendar_editor.js", "/web_studio/static/src/client_action/view_editor/editors/cohort/cohort_editor.js", "/web_studio/static/src/client_action/view_editor/editors/components/field_content_overlay.js", "/web_studio/static/src/client_action/view_editor/editors/components/field_selector_dialog.js", "/web_studio/static/src/client_action/view_editor/editors/components/field_studio.js", "/web_studio/static/src/client_action/view_editor/editors/components/studio_hook_component.js", "/web_studio/static/src/client_action/view_editor/editors/components/view_button_studio.js", "/web_studio/static/src/client_action/view_editor/editors/components/widget_studio.js", "/web_studio/static/src/client_action/view_editor/editors/form/chatter_container.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_compiler.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_controller/form_editor_controller.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_renderer/form_editor_groups.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer_components.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/form_editor_sidebar.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/button_properties.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/new_button_box_dialog.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/rainbow_effect.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/chatter_properties/chatter_properties.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/group_properties/group_properties.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/label_properties/label_properties.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/o_td_label_properties/o_td_label_properties.js", "/web_studio/static/src/client_action/view_editor/editors/form/form_editor_sidebar/properties/page_properties/page_properties.js", "/web_studio/static/src/client_action/view_editor/editors/gantt/gantt_editor_sidebar.js", "/web_studio/static/src/client_action/view_editor/editors/graph/graph_editor.js", "/web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor.js", "/web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_compiler.js", "/web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_record.js", "/web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_renderer.js", "/web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/kanban_editor_sidebar.js", "/web_studio/static/src/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/kanban_cover_properties/kanban_cover_properties.js", "/web_studio/static/src/client_action/view_editor/editors/list/list_editor.js", "/web_studio/static/src/client_action/view_editor/editors/list/list_editor_renderer.js", "/web_studio/static/src/client_action/view_editor/editors/list/list_editor_sidebar/list_editor_sidebar.js", "/web_studio/static/src/client_action/view_editor/editors/map/map_editor_sidebar.js", "/web_studio/static/src/client_action/view_editor/editors/pivot/pivot_editor.js", "/web_studio/static/src/client_action/view_editor/editors/search/search_editor.js", "/web_studio/static/src/client_action/view_editor/editors/sidebar_safe_fields.js", "/web_studio/static/src/client_action/view_editor/editors/utils.js", "/web_studio/static/src/client_action/view_editor/editors/xml_utils.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/action_button/action_button.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/field_configuration/field_configuration.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/interactive_editor.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/interactive_editor_sidebar.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/properties/field_properties/field_properties.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/properties/field_properties/field_type_properties.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/properties/field_properties/type_widget_properties.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/properties/properties.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox.js", "/web_studio/static/src/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox.js", "/web_studio/static/src/client_action/view_editor/operations_utils.js", "/web_studio/static/src/client_action/view_editor/property/property.js", "/web_studio/static/src/client_action/view_editor/studio_view.js", "/web_studio/static/src/client_action/view_editor/view_editor.js", "/web_studio/static/src/client_action/view_editor/view_editor_hook.js", "/web_studio/static/src/client_action/view_editor/view_editor_model.js", "/web_studio/static/src/client_action/view_editor/view_editor_snackbar.js", "/web_studio/static/src/client_action/view_editor/view_structures/view_structures.js", "/web_studio/static/src/client_action/xml_resource_editor/xml_resource_editor.js", "/web_studio/static/src/views/kanban_report/new_report_dialog.js", "/web_studio/static/src/views/kanban_report/report_kanban_view.js", "/website_studio/static/src/website_integrator/website_integrator.js"], "mappings": "AAAA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrQA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnNA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxMA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjUA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3IA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1GA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtKA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7DA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5YA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACXA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtuBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9NA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtIA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACbA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvIA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxQA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjMA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpOA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1GA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxLA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/HA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1PA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1OA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7IA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxMA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChIA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtaA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxOA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvIA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1RA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvMA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtkBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvNA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9WA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/GA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACZA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACl1BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACVA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpPA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/** @odoo-module */\nimport { Component } from \"@odoo/owl\";\nimport { useOwnedDialogs, useService } from \"@web/core/utils/hooks\";\nimport { registry } from \"@web/core/registry\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { sortBy } from \"@web/core/utils/arrays\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\nimport { DropdownItem } from \"@web/core/dropdown/dropdown_item\";\nimport { AlertDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport { standardActionServiceProps } from \"@web/webclient/actions/action_service\";\n\nimport { Record } from \"@web/model/record\";\nimport {\n    Many2ManyTagsField,\n    many2ManyTagsField,\n} from \"@web/views/fields/many2many_tags/many2many_tags_field\";\nimport { CharField } from \"@web/views/fields/char/char_field\";\nimport { TextField } from \"@web/views/fields/text/text_field\";\n\nimport { viewTypeToString, useStudioServiceAsReactive } from \"@web_studio/studio_service\";\nimport { NewViewDialog } from \"../editor/new_view_dialogs/new_view_dialog\";\nimport { MapNewViewDialog } from \"../editor/new_view_dialogs/map_new_view_dialog\";\n\nfunction getViewCategories() {\n    return {\n        general: {\n            title: _t(\"General views\"),\n            viewTypes: [\"form\", \"search\", \"activity\"],\n        },\n        multiple: {\n            title: _t(\"Multiple records views\"),\n            viewTypes: [\"list\", \"kanban\", \"map\"],\n        },\n        timeline: {\n            title: _t(\"Timeline views\"),\n            viewTypes: [\"calendar\", \"cohort\", \"gantt\"],\n        },\n        reporting: {\n            title: _t(\"Reporting views\"),\n            viewTypes: [\"graph\", \"pivot\"],\n        },\n    };\n}\n\nconst actionFieldsGet = {\n    id: { type: \"integer\" },\n    name: { type: \"char\" },\n    help: { type: \"text\" },\n    groups_id: { type: \"many2many\", relation: \"res.groups\", string: \"Groups\" },\n};\n\nfunction getActionActiveFields() {\n    const activeFields = {};\n    for (const fName of Object.keys(actionFieldsGet)) {\n        activeFields[fName] = {};\n    }\n\n    const groups_idRelated = Object.fromEntries(\n        many2ManyTagsField.relatedFields({ options: {} }).map((f) => [f.name, f])\n    );\n    activeFields.groups_id.related = { activeFields: groups_idRelated, fields: groups_idRelated };\n\n    return activeFields;\n}\n\nfunction getActionValues(action) {\n    const values = {};\n    for (const fName of Object.keys(actionFieldsGet)) {\n        values[fName] = action[fName];\n    }\n    return values;\n}\n\nclass ActionEditor extends Component {\n    setup() {\n        this.studio = useStudioServiceAsReactive();\n        this.action = useService(\"action\");\n        this.notification = useService(\"notification\");\n        this.rpc = useService(\"rpc\");\n        this.user = useService(\"user\");\n        this.viewCategories = getViewCategories();\n        this.addDialog = useOwnedDialogs();\n\n        this.actionFieldsGet = { ...actionFieldsGet };\n    }\n\n    get actionRecordProps() {\n        const values = getActionValues(this.studio.editedAction);\n        return {\n            fields: this.actionFieldsGet,\n            resModel: \"ir.actions.act_window\",\n            resId: values.id,\n            mode: \"edit\",\n            values,\n            activeFields: getActionActiveFields(),\n            onRecordChanged: (record, changes) => {\n                return this.editAction(changes);\n            },\n        };\n    }\n\n    get activeViews() {\n        return this.studio.editedAction.views.map(([, name]) => name);\n    }\n\n    getOrderedViewTypes(viewTypes) {\n        const activeViews = this.activeViews;\n        const currentDefaultView = activeViews[0];\n        const viewInfos = viewTypes.map((viewType) => {\n            return {\n                name: viewType,\n                title: viewTypeToString(viewType),\n                isActive: activeViews.includes(viewType),\n                isDefault: currentDefaultView === viewType,\n                imgUrl: `/web_studio/static/src/img/view_type/${viewType}.png`,\n                canBeDefault: ![\"form\", \"search\"].includes(viewType),\n                canBeDisabled: viewType !== \"search\",\n            };\n        });\n        return sortBy(\n            viewInfos,\n            ({ isDefault, isActive }) => {\n                return isDefault ? 2 : isActive ? 1 : 0;\n            },\n            \"desc\"\n        );\n    }\n\n    setDefaultView(viewType) {\n        viewType = viewType === \"tree\" ? \"list\" : viewType;\n        let viewModes = this.studio.editedAction.view_mode.split(\",\");\n        viewModes = viewModes.filter((m) => m !== viewType);\n        viewModes.unshift(viewType);\n        return this.editAction({ view_mode: viewModes.join(\",\") });\n    }\n\n    disableView(viewType) {\n        const viewMode = this.studio.editedAction.view_mode\n            .split(\",\")\n            .filter((m) => m !== viewType);\n\n        if (!viewMode.length) {\n            this.addDialog(AlertDialog, {\n                body: _t(\"You cannot deactivate this view as it is the last one active.\"),\n            });\n        } else {\n            return this.editAction({ view_mode: viewMode.join(\",\") });\n        }\n    }\n\n    restoreDefaultView(viewType) {\n        return this.env.editionFlow.restoreDefaultView(null, viewType);\n    }\n\n    async addViewType(viewType) {\n        const action = this.studio.editedAction;\n        const viewMode = action.view_mode.split(\",\");\n        viewMode.push(viewType);\n        let viewAdded = await this.rpc(\"/web_studio/add_view_type\", {\n            action_type: action.type,\n            action_id: action.id,\n            res_model: action.res_model,\n            view_type: viewType,\n            args: { view_mode: viewMode.join(\",\") },\n            context: this.user.context,\n        });\n\n        if (viewAdded !== true) {\n            viewAdded = await new Promise((resolve) => {\n                let DialogClass;\n                const dialogProps = {\n                    confirm: async () => {\n                        resolve(true);\n                    },\n                    cancel: () => resolve(false),\n                };\n                if ([\"gantt\", \"calendar\", \"cohort\"].includes(viewType)) {\n                    DialogClass = NewViewDialog;\n                    dialogProps.viewType = viewType;\n                } else if (viewType === \"map\") {\n                    DialogClass = MapNewViewDialog;\n                } else {\n                    this.addDialog(AlertDialog, {\n                        body: _t(\n                            \"Creating this type of view is not currently supported in Studio.\"\n                        ),\n                    });\n                    resolve(false);\n                }\n                this.addDialog(DialogClass, dialogProps);\n            });\n        }\n        if (viewAdded) {\n            await this.editAction({ view_mode: viewMode.join(\",\") });\n        }\n        return viewAdded;\n    }\n\n    editView(viewType) {\n        this.studio.setParams({ viewType, editorTab: \"views\" });\n    }\n\n    async onThumbnailClicked(viewType) {\n        if (this.activeViews.includes(viewType)) {\n            return this.editView(viewType);\n        }\n        const resModel = this.studio.editedAction.res_model;\n        if (viewType === \"activity\") {\n            const activityAllowed = await this.studio.isAllowed(\"activity\", resModel);\n            if (!activityAllowed) {\n                this.notification.add(\n                    _t(\"Activity view unavailable on this model\"),\n                    {\n                        title: false,\n                        type: \"danger\",\n                    }\n                );\n                return;\n            }\n        }\n        if (await this.addViewType(viewType)) {\n            return this.editView(viewType);\n        }\n    }\n\n    openFormAction() {\n        return this.action.doAction(\n            {\n                type: \"ir.actions.act_window\",\n                res_model: \"ir.actions.act_window\",\n                res_id: this.studio.editedAction.id,\n                views: [[false, \"form\"]],\n                target: \"current\",\n            },\n            {\n                stackPosition: \"replacePreviousAction\",\n            }\n        );\n    }\n\n    async editAction(changes) {\n        await this.rpc(\"/web_studio/edit_action\", {\n            action_id: this.studio.editedAction.id,\n            action_type: \"ir.actions.act_window\",\n            args: changes,\n        });\n        return this.studio.reload({}, false);\n    }\n}\nActionEditor.template = \"web_studio.ActionEditor\";\nActionEditor.components = {\n    Dropdown,\n    DropdownItem,\n    Record,\n    CharField,\n    TextField,\n    Many2ManyTagsField,\n};\nActionEditor.props = { ...standardActionServiceProps };\n\nregistry.category(\"actions\").add(\"web_studio.action_editor\", ActionEditor);\n", "/** @odoo-module **/\n\nimport { Component, reactive, useExternalListener, useState } from \"@odoo/owl\";\nimport { useAutofocus, useService } from \"@web/core/utils/hooks\";\nimport { BG_COLORS, COLORS, ICONS } from \"@web_studio/utils\";\nimport { ModelConfigurator } from \"@web_studio/client_action/model_configurator/model_configurator\";\nimport { IconCreator } from \"../icon_creator/icon_creator\";\nimport { MenuCreator, MenuCreatorModel } from \"@web_studio/client_action/menu_creator/menu_creator\";\n\nclass AppCreatorState {\n    /**\n     * @param {Function} onFinished\n     */\n    constructor({ onFinished }) {\n        this._onFinished = onFinished;\n        // ==================== Misc ====================\n        this.step = \"welcome\";\n\n        // ================== Fields ==================\n        this.fieldsValidators = {\n            appName: () => !!this.data.appName,\n            menu: (_this) => _this.menuCreatorModel.isValid,\n        };\n        this.menuCreatorModel = reactive(new MenuCreatorModel());\n\n        this.data = {\n            appName: \"\",\n            iconData: {\n                backgroundColor: BG_COLORS[5],\n                color: COLORS[4],\n                iconClass: ICONS[0],\n                type: \"custom_icon\",\n            },\n            menu: this.menuCreatorModel.data,\n            modelOptions: [],\n        };\n\n        // ================== Steps ==================\n        this._steps = {\n            welcome: {\n                next: () => \"app\",\n            },\n            app: {\n                previous: \"welcome\",\n                next: () => \"model\",\n                fields: [\"appName\"],\n            },\n            model: {\n                previous: \"app\",\n                next: (data) => {\n                    return data.menu.modelChoice === \"new\" ? \"model_configuration\" : \"\";\n                },\n                fields: [\"menu\"],\n            },\n            model_configuration: {\n                previous: \"model\",\n            },\n        };\n    }\n\n    //--------------------------------------------------------------------------\n    // Getters\n    //--------------------------------------------------------------------------\n\n    get step() {\n        return this._step;\n    }\n\n    set step(step) {\n        this._step = step;\n        this.showValidation = false;\n    }\n\n    get nextStep() {\n        const next = this._next;\n        return this._stepInvalidFields.length ? false : next;\n    }\n\n    get hasPrevious() {\n        return \"previous\" in this._currentStep;\n    }\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    isFieldValid(fieldName) {\n        return this.showValidation ? this.fieldsValidators[fieldName](this) : true;\n    }\n\n    next() {\n        this.showValidation = true;\n        const invalidFields = this._stepInvalidFields;\n        if (invalidFields.length) {\n            return;\n        }\n        const next = this._next;\n        if (next) {\n            this.step = next;\n        } else {\n            return this._onFinished();\n        }\n    }\n\n    previous() {\n        if (this._currentStep.previous) {\n            this.step = this._currentStep.previous;\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    get _currentStep() {\n        return this._steps[this._step];\n    }\n\n    get _next() {\n        return this._currentStep.next ? this._currentStep.next(this.data) : \"\";\n    }\n\n    get _stepInvalidFields() {\n        return (this._currentStep.fields || []).filter((fName) => {\n            return !this.fieldsValidators[fName](this);\n        });\n    }\n}\n\nexport class AppCreator extends Component {\n    static template = \"web_studio.AppCreator\";\n    static components = { IconCreator, ModelConfigurator, MenuCreator };\n    static props = {\n        onNewAppCreated: { type: Function },\n    };\n\n    setup() {\n        this.state = useState(\n            new AppCreatorState({\n                onFinished: this.createNewApp.bind(this),\n            })\n        );\n\n        this.uiService = useService(\"ui\");\n        this.rpc = useService(\"rpc\");\n        this.user = useService(\"user\");\n\n        useAutofocus();\n        useExternalListener(window, \"keydown\", this.onKeydown);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    async createNewApp() {\n        this.uiService.block();\n        const data = this.state.data;\n        const iconData = data.iconData;\n\n        const iconValue =\n            iconData.type === \"custom_icon\"\n                ? // custom icon data\n                  [iconData.iconClass, iconData.color, iconData.backgroundColor]\n                : // attachment\n                  iconData.uploaded_attachment_id;\n\n        try {\n            const result = await this.rpc(\"/web_studio/create_new_app\", {\n                app_name: data.appName,\n                menu_name: data.menu.menuName,\n                model_choice: data.menu.modelChoice,\n                model_id: data.menu.modelChoice && data.menu.modelId && data.menu.modelId[0],\n                model_options: data.modelOptions,\n                icon: iconValue,\n                context: this.user.context,\n            });\n            await this.props.onNewAppCreated(result);\n        } finally {\n            this.uiService.unblock();\n        }\n    }\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @param {KeyboardEvent} ev\n     */\n    onKeydown(ev) {\n        if (\n            ev.key === \"Enter\" &&\n            !(\n                ev.target.classList &&\n                ev.target.classList.contains(\"o_web_studio_app_creator_previous\")\n            )\n        ) {\n            ev.preventDefault();\n            this.state.next();\n        }\n    }\n\n    /**\n     * Handle the confirmation of options in the modelconfigurator\n     * @param {Object} options\n     */\n    onConfirmOptions(options) {\n        this.state.data.modelOptions = options;\n        return this.state.next();\n    }\n}\n", "/** @odoo-module */\nimport { Component, useRef, useState } from \"@odoo/owl\";\nimport { useBus, useService, useOwnedDialogs } from \"@web/core/utils/hooks\";\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { useNestedSortable } from \"@web/core/utils/nested_sortable\";\nimport { FormViewDialog } from \"@web/views/view_dialogs/form_view_dialog\";\nimport { MenuCreatorDialog } from \"@web_studio/client_action/menu_creator/menu_creator\";\nimport { useDialogConfirmation, useSubEnvAndServices } from \"@web_studio/client_action/utils\";\nimport { _t } from \"@web/core/l10n/translation\";\n\nconst EditMenuDialogProps = { ...Dialog.props };\nEditMenuDialogProps.close = { type: Function };\ndelete EditMenuDialogProps.slots;\nclass EditMenuDialog extends Component {\n    static components = { Dialog };\n    static template = \"web_studio.AppMenuEditor.EditMenuDialog\";\n    static props = EditMenuDialogProps;\n\n    setup() {\n        // Keep the bus from the WebClient\n        const originalBus = this.env.bus;\n        useBus(originalBus, \"MENUS:APP-CHANGED\", () => (this.state.tree = this.getTree()));\n\n        this.menus = useService(\"menu\");\n        this.addDialog = useOwnedDialogs();\n        this.orm = useService(\"orm\");\n        this.user = useService(\"user\");\n        this.rpc = useService(\"rpc\");\n\n        useBus(this.env.bus, \"ACTION_MANAGER:UPDATE\", () => this.cancel());\n\n        this.title = _t(\"Edit Menu\");\n\n        // States and data\n        this.state = useState({ tree: {}, flatMenus: {} });\n        this.state.tree = this.getTree();\n        this.toMove = {};\n        this.toDelete = [];\n\n        // DragAndDrop to move menus around\n        const root = useRef(\"root\");\n        useNestedSortable({\n            ref: root,\n            handle: \".o-draggable-handle\",\n            nest: true,\n            maxLevels: 5,\n            useElementSize: true,\n            onDrop: this.moveMenu.bind(this),\n        });\n\n        const { confirm, cancel } = useDialogConfirmation({\n            confirm: async () => {\n                await this.saveChanges();\n            },\n        });\n        this.confirm = confirm;\n        this.cancel = cancel;\n    }\n\n    get flatMenus() {\n        return this.state.flatMenus;\n    }\n\n    get mainItem() {\n        return this.state.tree;\n    }\n\n    getTree() {\n        let currentApp = this.menus.getCurrentApp();\n        if (!currentApp) {\n            return null;\n        }\n        currentApp = this.menus.getMenuAsTree(currentApp.id);\n        const item = this._getItemFromMenu(currentApp, null);\n        item.isDraggable = false;\n        item.isRemovable = false;\n        return item;\n    }\n\n    _getItemFromMenu(menu, parentId) {\n        const item = {\n            id: menu.id,\n            name: menu.name,\n            isDraggable: true,\n            isRemovable: true,\n            parentId,\n        };\n        item.children = menu.childrenTree.map((menu) => this._getItemFromMenu(menu, item.id));\n        this.flatMenus[item.id] = item;\n        return item;\n    }\n\n    moveMenu({ element, parent, previous }) {\n        const menuId = parseInt(element.dataset.itemId);\n        const menu = this.flatMenus[menuId];\n\n        // Remove element from parent's children (since we are moving it, this is the mandatory first step)\n        let parentMenu = this.flatMenus[menu.parentId];\n        parentMenu.children = parentMenu.children.filter((m) => m.id !== menuId);\n\n        // Determine next parent\n        const parentLi = parent?.closest(\"li\");\n        const parentMenuId = parentLi ? parseInt(parentLi.dataset.itemId) : this.mainItem.id;\n        if (parentMenuId !== parentMenu.id) {\n            parentMenu = this.flatMenus[parentMenuId];\n            menu.parentId = parentMenu.id;\n        }\n\n        // Determine at which position we should place the element\n        if (previous) {\n            const previousMenu = this.flatMenus[previous.dataset.itemId];\n            const index = parentMenu.children.findIndex((child) => child === previousMenu);\n            parentMenu.children.splice(index + 1, 0, menu);\n        } else {\n            parentMenu.children.unshift(menu);\n        }\n\n        // Last step: prepare the data that can be sent to the server.\n        this.toMove[menuId] = {\n            parent_menu_id: menu.parentId,\n        };\n\n        parentMenu.children.forEach((m, index) => {\n            this.toMove[m.id] = this.toMove[m.id] || {};\n            this.toMove[m.id].sequence = index + 1;\n        });\n    }\n\n    removeItem(menu) {\n        const parentMenu = this.flatMenus[menu.parentId];\n        if (!parentMenu) {\n            return;\n        }\n        parentMenu.children = parentMenu.children.filter((m) => m.id !== menu.id);\n        this.toDelete.push(menu.id);\n    }\n\n    editItem(menu) {\n        this.addDialog(FormViewDialog, {\n            resModel: \"ir.ui.menu\",\n            resId: menu.id,\n            onRecordSaved: async () => {\n                await this.saveChanges(true);\n            },\n        });\n    }\n\n    async saveChanges(reload = false) {\n        if (Object.keys(this.toMove).length || this.toDelete.length) {\n            await this.orm.call(\"ir.ui.menu\", \"customize\", [], {\n                to_move: this.toMove,\n                to_delete: this.toDelete,\n            });\n            reload = true;\n        }\n        if (reload) {\n            await this.menus.reload();\n        }\n    }\n\n    onNewMenu() {\n        this.addDialog(MenuCreatorDialog, {\n            confirm: async (data) => {\n                await this.rpc(\"/web_studio/create_new_menu\", {\n                    menu_name: data.menuName,\n                    model_id: data.modelId[0],\n                    model_choice: data.modelChoice,\n                    model_options: data.modelOptions || {},\n                    parent_menu_id: this.mainItem.id,\n                    context: this.user.context,\n                });\n                this.env.bus.trigger(\"CLEAR-CACHES\");\n                this.menus.reload();\n            },\n        });\n    }\n}\n\nexport class AppMenuEditor extends Component {\n    static props = {\n        env: { type: Object },\n    };\n    static template = \"web_studio.AppMenuEditor\";\n\n    setup() {\n        this.menus = useService(\"menu\");\n        // original bus from webClient\n        const bus = this.env.bus;\n        // ovverride the whole env coming from within studio\n        // contains an override of dialog and an override of action\n        useSubEnvAndServices(this.props.env);\n        this.addDialog = useOwnedDialogs();\n        useBus(bus, \"MENUS:APP-CHANGED\", () => this.render());\n    }\n\n    onClick(ev) {\n        ev.preventDefault();\n        this.addDialog(EditMenuDialog);\n    }\n}\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { toRaw, useState, useEnv, reactive, onMounted, onWillUnmount, markRaw } from \"@odoo/owl\";\nimport { Reactive } from \"@web_studio/client_action/utils\";\n\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport { KeepLast } from \"@web/core/utils/concurrency\";\n\n/**\n * Provides standard shortcuts for the ActionEditor and  ViewEditor.\n * Used as a communcation interface between the editorMenu\n * and the ActionEditor or the ViewEditor\n *\n * Supports snackBar, breadcrumbs, operation stack\n */\nexport class EditionFlow extends Reactive {\n    constructor(env, services) {\n        super();\n        this.env = env;\n        for (const [servName, serv] of Object.entries(services)) {\n            this[servName] = serv;\n        }\n        this.setup();\n    }\n    setup() {\n        let requestId;\n        const updateBreadcrumbs = (studio) => {\n            if (studio.requestId !== requestId) {\n                this.breadcrumbs = [];\n            }\n            requestId = studio.requestId;\n        };\n        const studio = reactive(this.studio, () => updateBreadcrumbs(studio));\n        this.studio = studio;\n        this.breadcrumbs = [];\n        updateBreadcrumbs(studio);\n    }\n\n    pushBreadcrumb(crumb) {\n        const bcLength = this.breadcrumbs.length;\n        const handler = () => {\n            this.breadcrumbs.length = bcLength + 1;\n            // Reset studio to its own state\n            // In case another action has been done\n            this.studio.setParams({}, false);\n        };\n        this.breadcrumbs.push({ data: crumb, handler });\n    }\n\n    async loadViews({ forceSearch = false } = {}) {\n        const editedAction = this.studio.editedAction;\n        const { context, res_model, id } = editedAction;\n        const views = [...editedAction.views];\n        if (forceSearch && !views.some((tuple) => tuple[1] === \"search\")) {\n            views.push([false, \"search\"]);\n        }\n        const newContext = { ...context, lang: false };\n        const options = { loadIrFilters: true, loadActionMenus: false, id, studio: true };\n        const res = await this.view.loadViews(\n            { resModel: res_model, views, context: newContext },\n            options\n        );\n        return JSON.parse(JSON.stringify(res));\n    }\n    restoreDefaultView(viewId, viewType) {\n        return new Promise((resolve) => {\n            const confirm = async () => {\n                if (!viewId && viewType) {\n                    // To restore the default view from an inherited one, we need first to retrieve the default view id\n                    const result = await this.loadViews();\n                    viewId = result.views[viewType].id;\n                }\n                const res = await this.rpc(\"/web_studio/restore_default_view\", {\n                    view_id: viewId,\n                });\n                this.env.bus.trigger(\"CLEAR-CACHES\");\n                resolve(res);\n            };\n            this.dialog.add(ConfirmationDialog, {\n                body: _t(\n                    \"Are you sure you want to restore the default view?\\r\\nAll customization done with studio on this view will be lost.\"\n                ),\n                confirm,\n                cancel: () => resolve(false),\n            });\n        });\n    }\n}\n\nexport function useEditorBreadcrumbs(initialCrumb) {\n    const env = useEnv();\n    const editionFlow = env.editionFlow;\n\n    if (initialCrumb && !editionFlow.breadcrumbs.length) {\n        onMounted(() => editionFlow.pushBreadcrumb(initialCrumb));\n    }\n\n    const crumbs = useState(editionFlow.breadcrumbs);\n    const push = (crumb) => editionFlow.pushBreadcrumb(crumb);\n    return { crumbs, push };\n}\n\nexport function useEditorMenuItem(MenuItem) {\n    const editionFlow = useEnv().editionFlow;\n    onMounted(() => {\n        editionFlow.MenuItem = MenuItem;\n    });\n    onWillUnmount(() => {\n        if (toRaw(editionFlow).MenuItem === MenuItem) {\n            editionFlow.MenuItem = null;\n        }\n    });\n}\n\n/**\n * Indicates whether a the concrete editor has finished its async operation\n * with its state: loaded/loading\n */\n\n// PAss state instead of proms\n// PAss count ? => error handling ?\n// ecrase prom precedente ?\n//\nexport class SnackbarIndicator extends Reactive {\n    constructor() {\n        super();\n        this.state = \"\";\n        this.keepLast = markRaw(new KeepLast());\n    }\n\n    add(prom) {\n        this.state = \"loading\";\n        const raw = this.raw();\n        this.pending = Promise.all([raw.pending, prom]);\n\n        this.keepLast\n            .add(raw.pending)\n            .then(() => (this.state = \"loaded\"))\n            .catch(() => {\n                this.state = \"error\";\n            })\n            .finally(() => {\n                this.pending = null;\n            });\n        return prom;\n    }\n}\n\n/**\n * A Class that manages undo/redo of some operations\n * in a sort of MutexedKeeLast: doing many calls to \"do\"\n * will just store the arguments and keep only the last call's results\n */\nexport class EditorOperations extends Reactive {\n    constructor(params) {\n        super();\n        this.operations = [];\n        this.undone = [];\n        this._lock = \"\";\n        this._keepLast = markRaw(new KeepLast());\n\n        this._callbacks = {\n            do: params.do,\n            onError: params.onError,\n            onDone: params.onDone,\n        };\n    }\n\n    get canUndo() {\n        return this.operations.length || (this.pending && this.pending.length);\n    }\n\n    get canRedo() {\n        return this.undone.length || (this.pendingUndone && this.pendingUndone.length);\n    }\n\n    _wrapPromise(prom) {\n        return this._keepLast.add(prom);\n    }\n\n    _prepare(mode) {\n        const raw = this.raw();\n        const lock = raw._lock;\n        if (lock && lock !== mode) {\n            this._wrapPromise(Promise.resolve());\n            this._close();\n            return false;\n        }\n        this._lock = mode;\n        const pending = raw.pending;\n        if (!pending) {\n            this.pending = [...raw.operations];\n            this.pendingUndone = [...raw.undone];\n        }\n        return true;\n    }\n\n    async _do(mode, pending, lastOp) {\n        let result;\n        let error;\n        try {\n            result = await this._wrapPromise(\n                this._callbacks.do({ mode, operations: pending, lastOp })\n            );\n        } catch (e) {\n            error = e;\n        }\n        if (error) {\n            return { error };\n        }\n        return { result };\n    }\n\n    _close(done = null) {\n        const raw = this.raw();\n        const mode = raw._lock;\n        this._lock = null;\n        const pending = raw.pending;\n        const pendingUndone = raw.pendingUndone;\n        this.pending = null;\n        this.pendingUndone = null;\n\n        if (!done) {\n            return;\n        }\n\n        if (\"result\" in done) {\n            this.operations = pending;\n            this.undone = pendingUndone;\n            if (typeof done.result !== \"boolean\") {\n                return this._callbacks.onDone({\n                    mode,\n                    pending,\n                    pendingUndone,\n                    result: done.result,\n                });\n            }\n        }\n        if (\"error\" in done) {\n            return this._callbacks.onError({ mode, pending, error: done.error });\n        }\n    }\n\n    async undo(canRedo = true) {\n        if (!this._prepare(\"undo\")) {\n            this._close();\n            return;\n        }\n        const ops = this.raw().pending;\n        if (!ops || !ops.length) {\n            this._close();\n            return;\n        }\n        const op = ops.pop();\n        if (canRedo) {\n            this.pendingUndone.push(op);\n        }\n        const done = await this._do(\"undo\", this.raw().pending, op);\n        this._close(done);\n    }\n\n    pushOp(op) {\n        this.operations.push(op);\n    }\n\n    async redo() {\n        if (!this._prepare(\"redo\")) {\n            this._close();\n            return;\n        }\n\n        const ops = this.raw().pendingUndone;\n        if (!ops || !ops.length) {\n            this._close();\n            return;\n        }\n        const op = ops.pop();\n        this.pending.push(op);\n        const done = await this._do(\"do\", this.raw().pending, op);\n        this._close(done);\n    }\n\n    async doMulti(ops = []) {\n        if (!ops.length) {\n            return;\n        }\n        let prom;\n        for (let i = 0; i < ops.length; i++) {\n            let silent = true;\n            if (i === ops.length - 1) {\n                silent = false;\n            }\n            prom = this.do(ops[i], silent);\n        }\n        return prom;\n    }\n\n    async do(op, silent = false) {\n        if (!this._prepare(\"do\") || !op) {\n            this._close();\n            return;\n        }\n        this.pending.push(op);\n        this.pendingUndone = [];\n        let done = {};\n        if (!silent) {\n            done = await this._do(\"do\", this.raw().pending, op);\n        } else {\n            done = { result: true };\n        }\n        this._close(done);\n    }\n\n    clear(all = true) {\n        this.operations = [];\n        if (all) {\n            this.undone = [];\n        }\n    }\n}\n", "/** @odoo-module **/\nimport { Component, EventBus, onWillDestroy, useState, useSubEnv, xml } from \"@odoo/owl\";\n\nimport { registry } from \"@web/core/registry\";\nimport { actionService } from \"@web/webclient/actions/action_service\";\nimport { useBus, useService } from \"@web/core/utils/hooks\";\n\nimport { StudioActionContainer } from \"./studio_action_container\";\nimport { EditorMenu } from \"./editor_menu/editor_menu\";\n\nimport { AppMenuEditor } from \"./app_menu_editor/app_menu_editor\";\nimport { NewModelItem } from \"./new_model_item/new_model_item\";\nimport { EditionFlow } from \"./edition_flow\";\nimport { useStudioServiceAsReactive } from \"@web_studio/studio_service\";\nimport { useSubEnvAndServices, useServicesOverrides } from \"@web_studio/client_action/utils\";\nimport { omit } from \"@web/core/utils/objects\";\n\nclass DialogWithEnv extends Component {\n    static template = xml`<t t-component=\"props.Component\" t-props=\"componentProps\" />`;\n    static props = [\"*\"];\n\n    setup() {\n        useSubEnvAndServices(this.props.env);\n    }\n\n    get componentProps() {\n        const additionalProps = omit(this.props, \"Component\", \"env\", \"componentProps\");\n        return { ...this.props.componentProps, ...additionalProps };\n    }\n}\nconst dialogService = {\n    dependencies: [\"dialog\"],\n    start(env, { dialog }) {\n        function addDialog(Component, _props, options) {\n            const props = { env, Component, componentProps: _props };\n            return dialog.add(DialogWithEnv, props, options);\n        }\n        return { ...dialog, add: addDialog };\n    },\n};\n\nconst actionServiceStudio = {\n    dependencies: [\"studio\", \"dialog\"],\n    start(env, { studio }) {\n        const action = actionService.start(env);\n        const _doAction = action.doAction;\n\n        async function doAction(actionRequest, options) {\n            if (actionRequest === \"web_studio.action_edit_report\") {\n                return studio.setParams({\n                    editedReport: options.report,\n                });\n            }\n            return _doAction(...arguments);\n        }\n\n        return Object.assign(action, { doAction });\n    },\n};\n\nconst routerService = {\n    start() {\n        return {\n            current: { hash: {} },\n            pushState() {},\n        };\n    },\n};\n\nconst menuButtonsRegistry = registry.category(\"studio_navbar_menubuttons\");\nexport class Editor extends Component {\n    static menuButtonsId = 1;\n    setup() {\n        const globalBus = this.env.bus;\n        const newBus = new EventBus();\n        useBus(globalBus, \"CLEAR-UNCOMMITTED-CHANGES\", (ev) =>\n            newBus.trigger(\"CLEAR-UNCOMMITTED-CHANGES\", ev.detail)\n        );\n        newBus.addEventListener(\"CLEAR-CACHES\", () => globalBus.trigger(\"CLEAR-CACHES\"));\n\n        useSubEnv({\n            bus: newBus,\n        });\n\n        useServicesOverrides({\n            router: routerService,\n            dialog: dialogService,\n            action: actionServiceStudio,\n        });\n        this.studio = useService(\"studio\");\n\n        const editionFlow = new EditionFlow(this.env, {\n            rpc: useService(\"rpc\"),\n            dialog: useService(\"dialog\"),\n            studio: useStudioServiceAsReactive(),\n            view: useService(\"view\"),\n        });\n        useSubEnv({\n            editionFlow,\n        });\n\n        this.actionService = useService(\"action\");\n        this.rpc = useService(\"rpc\");\n\n        this.state = useState({ actionContainerId: 1 });\n        useBus(this.studio.bus, \"UPDATE\", async () => {\n            this.state.actionContainerId++;\n        });\n\n        // Push instance-specific components in the navbar. Because we want those elements\n        // immediately, we add them at setup time, not onMounted.\n        // Also, because they are Editor instance-specific, and that Destroyed is mostly called\n        // after the new instance is created, we need to remove the old entries before adding the new ones\n        menuButtonsRegistry.getEntries().forEach(([name]) => {\n            if (name.startsWith(\"app_menu_editor_\") || name.startsWith(\"new_model_item_\")) {\n                menuButtonsRegistry.remove(name);\n            }\n        });\n        const menuButtonsId = this.constructor.menuButtonsId++;\n        menuButtonsRegistry.add(`app_menu_editor_${menuButtonsId}`, {\n            Component: AppMenuEditor,\n            props: { env: this.env },\n        });\n        menuButtonsRegistry.add(`new_model_item_${menuButtonsId}`, {\n            Component: NewModelItem,\n            props: { env: this.env },\n        });\n        onWillDestroy(() => {\n            menuButtonsRegistry.remove(`app_menu_editor_${menuButtonsId}`);\n            menuButtonsRegistry.remove(`new_model_item_${menuButtonsId}`);\n        });\n    }\n\n    switchView({ viewType }) {\n        this.studio.setParams({ viewType, editorTab: \"views\" });\n    }\n    switchViewLegacy(ev) {\n        this.studio.setParams({ viewType: ev.detail.view_type });\n    }\n\n    switchTab({ tab }) {\n        this.studio.setParams({ editorTab: tab });\n    }\n}\nEditor.template = \"web_studio.Editor\";\nEditor.props = {};\nEditor.components = {\n    EditorMenu,\n    StudioActionContainer,\n};\n", "/** @odoo-module */\nimport { useService } from \"@web/core/utils/hooks\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { localization } from \"@web/core/l10n/localization\";\nimport { registry } from \"@web/core/registry\";\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { useStudioServiceAsReactive } from \"@web_studio/studio_service\";\nconst editorTabRegistry = registry.category(\"web_studio.editor_tabs\");\n\nclass Breadcrumbs extends Component {\n    static template = \"web_studio.EditorMenu.Breadcrumbs\";\n    static props = {\n        currentTab: { type: Object },\n        switchTab: Function,\n    };\n    setup() {\n        this.editionFlow = useState(this.env.editionFlow);\n        this.nextCrumbId = 1;\n    }\n    get breadcrumbs() {\n        const currentTab = this.props.currentTab;\n        const crumbs = [\n            {\n                data: {\n                    name: currentTab.name,\n                },\n                handler: () => this.props.switchTab({ tab: currentTab.id }),\n            },\n        ];\n        const breadcrumbs = this.editionFlow.breadcrumbs;\n        breadcrumbs.forEach((crumb) => {\n            crumbs.push(crumb);\n        });\n        for (const crumb of crumbs) {\n            crumb.id = this.nextCrumbId++;\n        }\n        return crumbs;\n    }\n}\n\nexport class EditorMenu extends Component {\n    static components = { Breadcrumbs };\n    setup() {\n        this.l10n = localization;\n        this.studio = useStudioServiceAsReactive();\n        this.rpc = useService(\"rpc\");\n        this.editionFlow = useState(this.env.editionFlow);\n    }\n\n    get activeViews() {\n        const action = this.studio.editedAction;\n        const viewTypes = (action._views || action.views).map(([, type]) => type);\n        return this.constructor.viewTypes.filter((vt) => viewTypes.includes(vt.type));\n    }\n\n    get editorTabs() {\n        const entries = editorTabRegistry.getEntries();\n        return entries.map((entry) => Object.assign({}, entry[1], { id: entry[0] }));\n    }\n\n    get currentTab() {\n        return this.editorTabs.find((tab) => tab.id === this.studio.editorTab);\n    }\n\n    openTab(tab) {\n        this.props.switchTab({ tab });\n    }\n}\nEditorMenu.props = {\n    switchTab: Function,\n    switchView: Function,\n};\nEditorMenu.template = \"web_studio.EditorMenu\";\nEditorMenu.viewTypes = [\n    {\n        title: _t(\"Form\"),\n        type: \"form\",\n        iconClasses: \"fa fa-address-card\",\n    },\n    {\n        title: _t(\"List\"),\n        type: \"list\",\n        iconClasses: \"oi oi-view-list\",\n    },\n    {\n        title: _t(\"Kanban\"),\n        type: \"kanban\",\n        iconClasses: \"oi oi-view-kanban\",\n    },\n    {\n        title: _t(\"Map\"),\n        type: \"map\",\n        iconClasses: \"fa fa-map-marker\",\n    },\n    {\n        title: _t(\"Calendar\"),\n        type: \"calendar\",\n        iconClasses: \"fa fa-calendar\",\n    },\n    {\n        title: _t(\"Graph\"),\n        type: \"graph\",\n        iconClasses: \"fa fa-area-chart\",\n    },\n    {\n        title: _t(\"Pivot\"),\n        type: \"pivot\",\n        iconClasses: \"oi oi-view-pivot\",\n    },\n    {\n        title: _t(\"Gantt\"),\n        type: \"gantt\",\n        iconClasses: \"fa fa-tasks\",\n    },\n    {\n        title: _t(\"Cohort\"),\n        type: \"cohort\",\n        iconClasses: \"oi oi-view-cohort\",\n    },\n    {\n        title: _t(\"Activity\"),\n        type: \"activity\",\n        iconClasses: \"fa fa-clock-o\",\n    },\n    {\n        title: _t(\"Search\"),\n        type: \"search\",\n        iconClasses: \"oi oi-search\",\n    },\n];\n\neditorTabRegistry\n    .add(\"views\", { name: _t(\"Views\"), action: \"web_studio.action_editor\" })\n    .add(\"reports\", { name: _t(\"Reports\") })\n    .add(\"automations\", { name: _t(\"Automations\") })\n    .add(\"automation_webhooks\", { name: _t(\"Webhooks\") })\n    .add(\"acl\", { name: _t(\"Access Control\") })\n    .add(\"filters\", { name: _t(\"Filter Rules\") });\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useBus, useService, useOwnedDialogs } from \"@web/core/utils/hooks\";\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { ModelConfiguratorDialog } from \"../../model_configurator/model_configurator\";\nimport { useDialogConfirmation, useSubEnvAndServices } from \"../../utils\";\n\nclass SimpleNewModelDialog extends Component {\n    static template = \"web_studio.SimpleNewModelDialog\";\n    static components = { Dialog };\n    static props = { close: { type: Function } };\n\n    setup() {\n        this.addDialog = useOwnedDialogs();\n        this.rpc = useService(\"rpc\");\n        this.menus = useService(\"menu\");\n        this.user = useService(\"user\");\n        this.action = useService(\"action\");\n        this.studio = useService(\"studio\");\n        this.state = useState({ modelName: \"\", showValidation: false });\n        const { confirm, cancel } = useDialogConfirmation({\n            confirm: async (data) => {\n                const { menu_id, action_id } = await this.rpc(\"/web_studio/create_new_menu\", {\n                    menu_name: this.state.modelName,\n                    model_id: false,\n                    model_choice: \"new\",\n                    model_options: data.modelOptions,\n                    parent_menu_id: this.menus.getCurrentApp().id,\n                    context: this.user.context,\n                });\n                await this.menus.reload();\n                const action = await this.action.loadAction(action_id);\n                this.menus.setCurrentMenu(menu_id);\n                this.studio.setParams({ action, viewType: \"form\" });\n            },\n        });\n\n        this._confirm = confirm;\n        this._cancel = cancel;\n    }\n\n    get title() {\n        return _t(\"Create a new Model\");\n    }\n\n    confirm(data = {}) {\n        return this._confirm(data);\n    }\n\n    onConfigureModel() {\n        if (!this.state.modelName) {\n            this.state.showValidation = true;\n            return;\n        }\n\n        this.addDialog(ModelConfiguratorDialog, {\n            confirmLabel: _t(\"Create Model\"),\n            confirm: (data) => {\n                this.confirm({ modelOptions: data });\n            },\n        });\n    }\n}\n\nexport class NewModelItem extends Component {\n    static props = { env: Object };\n    static template = \"web_studio.NewModelItem\";\n\n    setup() {\n        useSubEnvAndServices(this.props.env);\n        this.addDialog = useOwnedDialogs();\n        this.menus = useService(\"menu\");\n        this.studio = useService(\"studio\");\n        this.action = useService(\"action\");\n\n        useBus(this.env.bus, \"MENUS:APP-CHANGED\", () => this.render());\n    }\n\n    onClick(ev) {\n        ev.preventDefault();\n        this.addDialog(SimpleNewModelDialog);\n    }\n}\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { NewViewDialog } from \"@web_studio/client_action/editor/new_view_dialogs/new_view_dialog\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { AlertDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\n\nexport class MapNewViewDialog extends NewViewDialog {\n    setup() {\n        super.setup();\n        this.dialog = useService(\"dialog\");\n        this.fieldsChoice = {\n            res_partner: null,\n        };\n    }\n\n    get viewType() {\n        return \"map\";\n    }\n\n    computeSpecificFields(fields) {\n        this.partnerFields = fields.filter(\n            (field) => field.type === \"many2one\" && field.relation === \"res.partner\"\n        );\n        if (!this.partnerFields.length) {\n            this.dialog.add(AlertDialog, {\n                body: _t(\"Contact Field Required\"),\n                contentClass: \"o_web_studio_preserve_space\",\n            });\n            this.props.close();\n        } else {\n            this.fieldsChoice.res_partner = this.partnerFields[0].name;\n        }\n    }\n}\nMapNewViewDialog.template = \"web_studio.MapNewViewDialog\";\nMapNewViewDialog.props = {\n    ...NewViewDialog.props,\n};\ndelete MapNewViewDialog.props.viewType;\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\n\nimport { onWillStart } from \"@odoo/owl\";\n\nexport class NewViewDialog extends ConfirmationDialog {\n    setup() {\n        super.setup();\n        this.orm = useService(\"orm\");\n        this.rpc = useService(\"rpc\");\n        this.studio = useService(\"studio\");\n        this.user = useService(\"user\");\n        this.mandatoryStopDate = [\"gantt\", \"cohort\"].includes(this.viewType);\n\n        this.title = _t(\"Generate %s View\", this.viewType);\n\n        this.fieldsChoice = {\n            date_start: null,\n            date_stop: null,\n        };\n\n        onWillStart(async () => {\n            const fieldsGet = await this.orm.call(this.studio.editedAction.res_model, \"fields_get\");\n            const fields = Object.entries(fieldsGet).map(([fName, field]) => {\n                field.name = fName;\n                return field;\n            });\n            fields.sort((first, second) => {\n                if (first.string === second.string) {\n                    return 0;\n                }\n                if (first.string < second.string) {\n                    return -1;\n                }\n                if (first.string > second.string) {\n                    return 1;\n                }\n            });\n            this.computeSpecificFields(fields);\n        });\n    }\n\n    get viewType() {\n        return this.props.viewType;\n    }\n\n    /**\n     * Compute date, row and measure fields.\n     */\n    computeSpecificFields(fields) {\n        this.dateFields = [];\n        this.rowFields = [];\n        this.measureFields = [];\n        fields.forEach((field) => {\n            if (field.store) {\n                // date fields\n                if (field.type === \"date\" || field.type === \"datetime\") {\n                    this.dateFields.push(field);\n                }\n                // row fields\n                if (this.constructor.GROUPABLE_TYPES.includes(field.type)) {\n                    this.rowFields.push(field);\n                }\n                // measure fields\n                if (this.constructor.MEASURABLE_TYPES.includes(field.type)) {\n                    // id and sequence are not measurable\n                    if (field.name !== \"id\" && field.name !== \"sequence\") {\n                        this.measureFields.push(field);\n                    }\n                }\n            }\n        });\n        if (this.dateFields.length) {\n            this.fieldsChoice.date_start = this.dateFields[0].name;\n            this.fieldsChoice.date_stop = this.dateFields[0].name;\n        }\n    }\n\n    async _confirm() {\n        await this.rpc(\"/web_studio/create_default_view\", {\n            model: this.studio.editedAction.res_model,\n            view_type: this.viewType,\n            attrs: this.fieldsChoice,\n            context: this.user.context,\n        });\n        super._confirm();\n    }\n}\nNewViewDialog.template = \"web_studio.NewViewDialog\";\nNewViewDialog.GROUPABLE_TYPES = [\"many2one\", \"char\", \"boolean\", \"selection\", \"date\", \"datetime\"];\nNewViewDialog.MEASURABLE_TYPES = [\"integer\", \"float\"];\nNewViewDialog.props = {\n    ...ConfirmationDialog.props,\n    viewType: String,\n};\ndelete NewViewDialog.props.body;\n", "/** @odoo-module **/\n\nimport { ActionContainer } from \"@web/webclient/actions/action_container\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { registry } from \"@web/core/registry\";\nimport { KeepLast } from \"@web/core/utils/concurrency\";\nimport { Component, markup, onWillStart, onWillUnmount, onWillUpdateProps, xml } from \"@odoo/owl\";\nimport { useStudioServiceAsReactive } from \"@web_studio/studio_service\";\nimport { resetViewCompilerCache } from \"@web/views/view_compiler\";\n\nconst editorTabRegistry = registry.category(\"web_studio.editor_tabs\");\n\nexport class StudioActionContainer extends Component {\n    static template = xml`\n        <t t-name=\"web.ActionContainer\">\n        <div class=\"o_action_manager\">\n            <t t-if=\"info.Component\" t-component=\"info.Component\" className=\"'o_action'\" t-props=\"info.componentProps\" t-key=\"info.id\"/>\n        </div>\n        </t>`;\n    static props = {};\n\n    setup() {\n        this.actionService = useService(\"action\");\n        this.studio = useStudioServiceAsReactive();\n        this.rpc = useService(\"rpc\");\n        this.info = {};\n\n        let actionKey = 1;\n        const onUiUpdate = ({ detail: info }) => {\n            this.info = info;\n            actionKey++;\n            this.render();\n        };\n        this.env.bus.addEventListener(\"ACTION_MANAGER:UPDATE\", onUiUpdate);\n        onWillUnmount(() => this.env.bus.removeEventListener(\"ACTION_MANAGER:UPDATE\", onUiUpdate));\n\n        const doAction = async (action, options) => {\n            try {\n                await this.actionService.doAction(action, options);\n                this.actionKey = actionKey;\n            } catch (e) {\n                if (action !== \"web_studio.action_editor\") {\n                    // Fallback on the actionEditor, except if the actionEditor crashes\n                    this.studio.setParams({ editorTab: \"views\" });\n                }\n                // Rethrow anyway: the error doesn't originates from a user's action\n                throw e;\n            }\n        };\n\n        onWillStart(async () => {\n            const action = await this.getStudioAction();\n            this.studioKey = this.studio.requestId;\n            doAction(action);\n            await Promise.resolve();\n        });\n\n        const willUpdateKeepLast = new KeepLast();\n        onWillUpdateProps(async () => {\n            if (this.studio.requestId !== this.studioKey || this.actionKey !== actionKey) {\n                const action = await willUpdateKeepLast.add(this.getStudioAction());\n                resetViewCompilerCache();\n                return new Promise((_resolve) => {\n                    const resolve = () => {\n                        this.env.bus.removeEventListener(\"ACTION_MANAGER:UPDATE\", resolve);\n                        _resolve();\n                    };\n                    this.studioKey = this.studio.requestId;\n                    doAction(action, { clearBreadcrumbs: true, noEmptyTransition: true }).finally(\n                        () => {\n                            this.env.bus.removeEventListener(\"ACTION_MANAGER:UPDATE\", resolve);\n                        }\n                    );\n                    this.env.bus.addEventListener(\"ACTION_MANAGER:UPDATE\", resolve);\n                });\n            }\n        });\n    }\n    async getStudioAction() {\n        const { editorTab, editedAction, editedReport, editedViewType } = this.studio;\n        const tab = editorTabRegistry.get(editorTab);\n        if (editorTab === \"views\") {\n            if (editedViewType) {\n                return \"web_studio.view_editor\";\n            }\n            return tab.action;\n        }\n        if (tab.action) {\n            return tab.action;\n        } else if (editorTab === \"reports\" && editedReport) {\n            return \"web_studio.report_editor\";\n        } else {\n            const action = await this.rpc(\"/web_studio/get_studio_action\", {\n                action_name: editorTab,\n                model: editedAction.res_model,\n                view_id: editedAction.view_id && editedAction.view_id[0], // Not sure it is correct or desirable\n            });\n            action.help = action.help && markup(action.help);\n            return action;\n        }\n    }\n}\nStudioActionContainer.props = {\n    ...ActionContainer.props,\n    reloadId: { type: Number },\n};\n", "/** @odoo-module **/\nimport { COLORS, BG_COLORS, ICONS } from \"@web_studio/utils\";\nimport { FileInput } from \"@web/core/file_input/file_input\";\nimport { useService } from \"@web/core/utils/hooks\";\n\nimport { Component, onWillUpdateProps, useRef, useState } from \"@odoo/owl\";\n\nconst DEFAULT_ICON = {\n    backgroundColor: BG_COLORS[5],\n    color: COLORS[4],\n    iconClass: ICONS[0],\n};\n\n/**\n * Icon creator\n *\n * Component which purpose is to design an app icon. It can be an uploaded image\n * which will be displayed as is, or an icon customized with the help of presets\n * of colors and icon symbols (@see web_studio/static/src/utils for the full list of colors\n * and icon classes).\n * @extends Component\n */\nexport class IconCreator extends Component {\n    /**\n     * @param {Object} [props]\n     * @param {string} [props.backgroundColor] Background color of the custom\n     *      icon.\n     * @param {string} [props.color] Color of the custom icon.\n     * @param {boolean} props.editable\n     * @param {string} [props.iconClass] Font Awesome class of the custom icon.\n     * @param {string} props.type 'base64' (if an actual image) or 'custom_icon'.\n     * @param {number} [props.uploaded_attachment_id] Databse ID of an uploaded\n     *      attachment\n     * @param {string} [props.webIconData] Base64-encoded string representing\n     *      the icon image.\n     */\n    setup() {\n        this.COLORS = COLORS;\n        this.BG_COLORS = BG_COLORS;\n        this.ICONS = ICONS;\n\n        this.iconRef = useRef(\"app-icon\");\n\n        this.orm = useService(\"orm\");\n        this.rpc = useService(\"rpc\");\n        const user = useService(\"user\");\n\n        this.FileInput = FileInput;\n        this.fileInputProps = {\n            acceptedFileExtensions: \"image/png\",\n            resModel: \"res.users\",\n            resId: user.userId,\n        };\n\n        this.state = useState({ iconClass: this.props.iconClass });\n        this.show = useState({\n            backgroundColor: false,\n            color: false,\n            iconClass: false,\n        });\n\n        onWillUpdateProps((nextProps) => {\n            if (\n                this.constructor.enableTransitions &&\n                nextProps.iconClass !== this.props.iconClass\n            ) {\n                this.applyIconTransition(nextProps.iconClass);\n            } else {\n                this.state.iconClass = nextProps.iconClass;\n            }\n        });\n    }\n\n    applyIconTransition(nextIconClass) {\n        const iconEl = this.iconRef.el;\n        if (!iconEl) {\n            return;\n        }\n\n        iconEl.classList.remove(\"o-fading-in\");\n        iconEl.classList.remove(\"o-fading-out\");\n\n        iconEl.onanimationend = () => {\n            this.state.iconClass = nextIconClass;\n            iconEl.onanimationend = () => {\n                iconEl.onanimationend = null;\n                iconEl.classList.remove(\"o-fading-in\");\n            };\n            iconEl.classList.remove(\"o-fading-out\");\n            iconEl.classList.add(\"o-fading-in\");\n        };\n        iconEl.classList.add(\"o-fading-out\");\n    }\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    onDesignIconClick() {\n        this.props.onIconChange({\n            type: \"custom_icon\",\n            ...DEFAULT_ICON,\n        });\n    }\n\n    /**\n     * @param {Object[]} files\n     */\n    async onFileUploaded([file]) {\n        if (!file) {\n            // Happens when cancelling upload\n            return;\n        }\n        const res = await this.orm.read(\"ir.attachment\", [file.id], [\"datas\"]);\n\n        this.props.onIconChange({\n            type: \"base64\",\n            uploaded_attachment_id: file.id,\n            webIconData: \"data:image/png;base64,\" + res[0].datas.replace(/\\s/g, \"\"),\n        });\n    }\n\n    /**\n     * @param {string} palette\n     * @param {string} value\n     */\n    onPaletteItemClick(palette, value) {\n        if (this.props[palette] === value) {\n            return; // same value\n        }\n        this.props.onIconChange({\n            backgroundColor: this.props.backgroundColor,\n            color: this.props.color,\n            iconClass: this.props.iconClass,\n            type: \"custom_icon\",\n            [palette]: value,\n        });\n    }\n\n    /**\n     * @param {string} palette\n     */\n    onTogglePalette(palette) {\n        for (const pal in this.show) {\n            if (pal === palette) {\n                this.show[pal] = !this.show[pal];\n            } else if (this.show[pal]) {\n                this.show[pal] = false;\n            }\n        }\n    }\n}\n\nIconCreator.defaultProps = DEFAULT_ICON;\nIconCreator.props = {\n    backgroundColor: { type: String, optional: 1 },\n    color: { type: String, optional: 1 },\n    editable: { type: Boolean, optional: 1 },\n    iconClass: { type: String, optional: 1 },\n    type: { validate: (t) => [\"base64\", \"custom_icon\"].includes(t) },\n    uploaded_attachment_id: { type: Number, optional: 1 },\n    webIconData: { type: String, optional: 1 },\n    onIconChange: Function,\n};\nIconCreator.template = \"web_studio.IconCreator\";\nIconCreator.enableTransitions = true;\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\nimport { useOwnedDialogs } from \"@web/core/utils/hooks\";\nimport { Dialog } from \"@web/core/dialog/dialog\";\n\nimport { _t } from \"@web/core/l10n/translation\";\n\nimport { useDialogConfirmation } from \"@web_studio/client_action/utils\";\nimport { ModelConfiguratorDialog } from \"../model_configurator/model_configurator\";\nimport { RecordSelector } from \"@web/core/record_selectors/record_selector\";\n\nexport class MenuCreatorModel {\n    constructor({ allowNoModel } = {}) {\n        this.data = {\n            modelId: false,\n            menuName: \"\",\n            modelChoice: \"new\",\n        };\n\n        // Info to select what kind of model is linked to the menu\n        this.modelChoiceSelection = {\n            new: _t(\"New Model\"),\n            existing: _t(\"Existing Model\"),\n        };\n\n        if (allowNoModel) {\n            this.modelChoiceSelection.parent = _t(\"Parent Menu\");\n        }\n    }\n\n    validateField(fieldName) {\n        if (fieldName === \"menuName\") {\n            return !!this.data.menuName;\n        } else if (fieldName === \"modelId\") {\n            return this.data.modelChoice === \"existing\" ? !!this.data.modelId : true;\n        }\n    }\n\n    get isValid() {\n        return [\"menuName\", \"modelId\"].every((fName) => this.validateField(fName));\n    }\n}\n\nexport class MenuCreator extends Component {\n    static template = \"web_studio.MenuCreator\";\n    static components = { RecordSelector };\n    static props = {\n        menuCreatorModel: { type: Object },\n        showValidation: { type: Boolean, optional: true },\n    };\n    static defaultProps = {\n        showValidation: false,\n    };\n\n    get multiRecordSelectorProps() {\n        return {\n            resModel: \"ir.model\",\n            resId: this.state.data.modelId && this.state.data.modelId[0],\n            update: (resId) => (this.state.data.modelId = [resId]),\n            domain: [\n                [\"transient\", \"=\", false],\n                [\"abstract\", \"=\", false],\n            ],\n        };\n    }\n\n    setup() {\n        this.state = useState(this.props.menuCreatorModel);\n    }\n\n    isValid(fieldName) {\n        return this.props.showValidation ? this.state.validateField(fieldName) : true;\n    }\n}\n\nexport class MenuCreatorDialog extends Component {\n    static template = \"web_studio.MenuCreatorDialog\";\n    static components = { Dialog, MenuCreator };\n    static props = { confirm: { type: Function }, close: { type: Function } };\n\n    setup() {\n        this.addDialog = useOwnedDialogs();\n        this.menuCreatorModel = useState(new MenuCreatorModel({ allowNoModel: true }));\n        this.state = useState({ showValidation: false });\n        this.title = _t(\"Create your menu\");\n        const { confirm, cancel } = useDialogConfirmation({\n            confirm: async (data = {}) => {\n                if (!this.menuCreatorModel.isValid) {\n                    this.state.showValidation = true;\n                    return false;\n                }\n                await this.props.confirm(data);\n            },\n        });\n        this._confirm = confirm;\n        this._cancel = cancel;\n    }\n\n    confirm(data = {}) {\n        this._confirm({ ...this.menuCreatorModel.data, ...data });\n    }\n\n    onCreateNewModel() {\n        if (!this.menuCreatorModel.isValid) {\n            this.state.showValidation = true;\n            return;\n        }\n        this.addDialog(ModelConfiguratorDialog, {\n            confirmLabel: _t(\"Create Menu\"),\n            confirm: (data) => {\n                this.confirm({ modelOptions: data });\n            },\n        });\n    }\n}\n", "/** @odoo-module **/\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { Component, useState } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { session } from \"@web/session\";\n\n/** You might wonder why I defined all these strings here and not in the template.\n * The reason is that I wanted clear templates that use a single element to render an option,\n * meaning that the label and helper text had to be defined here in the code.\n */\nfunction getModelOptions() {\n    const modelOptions = {\n        use_partner: {\n            label: _t(\"Contact details\"),\n            help: _t(\"Get contact, phone and email fields on records\"),\n            value: false,\n        },\n        use_responsible: {\n            label: _t(\"User assignment\"),\n            help: _t(\"Assign a responsible to each record\"),\n            value: false,\n        },\n        use_date: {\n            label: _t(\"Date & Calendar\"),\n            help: _t(\"Assign dates and visualize records in a calendar\"),\n            value: false,\n        },\n        use_double_dates: {\n            label: _t(\"Date range & Gantt\"),\n            help: _t(\"Define start/end dates and visualize records in a Gantt chart\"),\n            value: false,\n        },\n        use_stages: {\n            label: _t(\"Pipeline stages\"),\n            help: _t(\"Stage and visualize records in a custom pipeline\"),\n            value: false,\n        },\n        use_tags: {\n            label: _t(\"Tags\"),\n            help: _t(\"Categorize records with custom tags\"),\n            value: false,\n        },\n        use_image: {\n            label: _t(\"Picture\"),\n            help: _t(\"Attach a picture to a record\"),\n            value: false,\n        },\n        lines: {\n            label: _t(\"Lines\"),\n            help: _t(\"Add details to your records with an embedded list view\"),\n            value: false,\n        },\n        use_notes: {\n            label: _t(\"Notes\"),\n            help: _t(\"Write additional notes or comments\"),\n            value: false,\n        },\n        use_value: {\n            label: _t(\"Monetary value\"),\n            help: _t(\"Set a price or cost on records\"),\n            value: false,\n        },\n        use_company: {\n            label: _t(\"Company\"),\n            help: _t(\"Restrict a record to a specific company\"),\n            value: false,\n        },\n        use_sequence: {\n            label: _t(\"Custom Sorting\"),\n            help: _t(\"Manually sort records in the list view\"),\n            value: true,\n        },\n        use_mail: {\n            label: _t(\"Chatter\"),\n            help: _t(\"Send messages, log notes and schedule activities\"),\n            value: true,\n        },\n        use_active: {\n            label: _t(\"Archiving\"),\n            help: _t(\"Archive deprecated records\"),\n            value: true,\n        },\n    };\n    if (!session.display_switch_company_menu) {\n        delete modelOptions.use_company;\n    }\n    return modelOptions;\n}\n\nexport class ModelConfigurator extends Component {\n    setup() {\n        this.state = useState({ saving: false });\n        this.options = useState(getModelOptions());\n    }\n\n    /**\n     * Handle the confirmation of the dialog, just fires an event\n     * to whoever instanciated it.\n     */\n    async onConfirm() {\n        try {\n            this.state.saving = true;\n\n            const mappedOptions = Object.entries(this.options)\n                .filter((opt) => opt[1].value)\n                .map((opt) => opt[0]);\n\n            await this.props.onConfirmOptions(mappedOptions);\n        } finally {\n            this.state.saving = false;\n        }\n    }\n}\n\nModelConfigurator.template = \"web_studio.ModelConfigurator\";\nModelConfigurator.components = {};\nModelConfigurator.props = {\n    embed: { type: Boolean, optional: true },\n    label: { type: String },\n    onConfirmOptions: Function,\n    onPrevious: Function,\n};\n\nexport class ModelConfiguratorDialog extends Component {\n    static components = { Dialog, ModelConfigurator };\n    static template = \"web_studio.ModelConfiguratorDialog\";\n\n    static props = {\n        confirm: { type: Function },\n        close: { type: Function },\n        confirmLabel: { type: String, optional: true },\n    };\n\n    async onConfirm(data) {\n        await this.props.confirm(data);\n        this.props.close();\n    }\n\n    onPrevious() {\n        this.props.close();\n    }\n\n    get title() {\n        return _t(\"Suggested features for your new model\");\n    }\n}\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\nimport { DropdownItem } from \"@web/core/dropdown/dropdown_item\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { browser } from \"@web/core/browser/browser\";\nimport { download } from \"@web/core/network/download\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport { FileInput } from \"@web/core/file_input/file_input\";\n\nimport { Component } from \"@odoo/owl\";\n\nexport class HomeMenuCustomizer extends Component {\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.ui = useService(\"ui\");\n        this.notification = useService(\"notification\");\n        this.company = useService(\"company\");\n        this.user = useService(\"user\");\n        this.actionManager = useService(\"action\");\n        this.menus = useService(\"menu\");\n        this.dialogManager = useService(\"dialog\");\n    }\n\n    setBackgroundImage(attachment_id) {\n        return this.rpc(\"/web_studio/set_background_image\", {\n            attachment_id: attachment_id,\n            context: this.user.context,\n        });\n    }\n    /**\n     * Export all customizations done by Studio in a zip file containing Odoo\n     * modules.\n     */\n    exportCusto() {\n        download({ url: \"/web_studio/export\", data: {} });\n    }\n    /**\n     * Open a dialog allowing to import new modules\n     * (e.g. exported customizations).\n     */\n    importCusto() {\n        const action = {\n            name: \"Import modules\",\n            res_model: \"base.import.module\",\n            views: [[false, \"form\"]],\n            type: \"ir.actions.act_window\",\n            target: \"new\",\n            context: {\n                dialog_size: \"medium\",\n            },\n        };\n        const options = {\n            onClose: () => this.menus.reload(),\n        };\n        this.actionManager.doAction(action, options);\n    }\n\n    async confirmReset() {\n        this.ui.block();\n        try {\n            await this.rpc(\"/web_studio/reset_background_image\", {\n                context: this.user.context,\n            });\n            browser.location.reload();\n        } finally {\n            this.ui.unblock();\n        }\n    }\n\n    resetBackground() {\n        this.dialogManager.add(ConfirmationDialog, {\n            body: _t(\"Are you sure you want to reset the background image?\"),\n            title: _t(\"Confirmation\"),\n            confirm: () => this.confirmReset(),\n        });\n    }\n\n    async onBackgroundUpload([file]) {\n        if (!file) {\n            this.notification.add(_t(\"Could not change the background\"), {\n                sticky: true,\n                type: \"warning\",\n            });\n        } else {\n            this.ui.block();\n            try {\n                await this.setBackgroundImage(file.id);\n                browser.location.reload();\n            } finally {\n                this.ui.unblock();\n            }\n        }\n    }\n}\nHomeMenuCustomizer.template = \"web_studio.HomeMenuCustomizer\";\nHomeMenuCustomizer.props = {};\nHomeMenuCustomizer.components = { Dropdown, DropdownItem, FileInput };\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { onMounted, onWillUnmount } from \"@odoo/owl\";\n\nimport { registry } from \"@web/core/registry\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { EnterpriseNavBar } from \"@web_enterprise/webclient/navbar/navbar\";\nimport { HomeMenuCustomizer } from \"./home_menu_customizer/home_menu_customizer\";\nimport { useStudioServiceAsReactive, NotEditableActionError } from \"@web_studio/studio_service\";\n\nconst menuButtonsRegistry = registry.category(\"studio_navbar_menubuttons\");\nexport class StudioNavbar extends EnterpriseNavBar {\n    setup() {\n        super.setup();\n        this.studio = useStudioServiceAsReactive();\n        this.actionManager = useService(\"action\");\n        this.user = useService(\"user\");\n        this.dialogManager = useService(\"dialog\");\n        this.notification = useService(\"notification\");\n        onMounted(() => {\n            this.env.bus.removeEventListener(\"HOME-MENU:TOGGLED\", this._busToggledCallback);\n            this._updateMenuAppsIcon();\n        });\n\n        const onMenuButtonsUpdate = () => this.render();\n        menuButtonsRegistry.addEventListener(\"UPDATE\", onMenuButtonsUpdate);\n        onWillUnmount(() => menuButtonsRegistry.removeEventListener(\"UPDATE\", onMenuButtonsUpdate));\n    }\n    onMenuToggle() {\n        this.studio.toggleHomeMenu();\n    }\n    closeStudio() {\n        this.studio.leave();\n    }\n    async onNavBarDropdownItemSelection(menu) {\n        if (menu.actionID) {\n            try {\n                await this.studio.open(this.studio.MODES.EDITOR, menu.actionID);\n            } catch (e) {\n                if (e instanceof NotEditableActionError) {\n                    const options = { type: \"danger\" };\n                    this.notification.add(_t(\"This action is not editable by Studio\"), options);\n                    return;\n                }\n                throw e;\n            }\n        }\n    }\n    get hasBackgroundAction() {\n        return this.studio.editedAction || this.studio.MODES.APP_CREATOR === this.studio.mode;\n    }\n    get isInApp() {\n        return this.studio.mode === this.studio.MODES.EDITOR;\n    }\n    get menuButtons() {\n        return Object.fromEntries(menuButtonsRegistry.getEntries());\n    }\n}\nStudioNavbar.template = \"web_studio.StudioNavbar\";\nStudioNavbar.components.HomeMenuCustomizer = HomeMenuCustomizer;\n", "/** @odoo-module */\nimport { Component, onWillRender, useState } from \"@odoo/owl\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { humanReadableError } from \"@web_studio/client_action/report_editor/utils\";\n\nexport class ErrorDisplay extends Component {\n    static template = \"web_studio.ErrorDisplay\";\n    static props = { error: Object };\n\n    setup() {\n        this.state = useState({ showTrace: false });\n        this.action = useService(\"action\");\n        onWillRender(() => {\n            this.error = humanReadableError(this.props.error);\n        });\n    }\n    openRecord(resModel, resId) {\n        const action = {\n            type: \"ir.actions.act_window\",\n            target: \"new\",\n            res_model: resModel,\n            res_id: resId,\n            views: [[false, \"form\"]],\n            context: {\n                studio: \"0\",\n            },\n        };\n        this.action.doAction(action);\n    }\n    urlFor(model, resId, viewType = \"form\") {\n        const searchParams = new URLSearchParams();\n        Object.entries({ model, id: resId, view_type: viewType }).forEach(([k, v]) =>\n            searchParams.set(k, v)\n        );\n        return `/web#${searchParams}`;\n    }\n}\n", "/** @odoo-module */\nimport { Component } from \"@odoo/owl\";\nimport { registry } from \"@web/core/registry\";\n\nimport { useReportEditorModel } from \"@web_studio/client_action/report_editor/report_editor_model\";\nimport { ReportEditorWysiwyg } from \"@web_studio/client_action/report_editor/report_editor_wysiwyg/report_editor_wysiwyg\";\nimport { ReportEditorXml } from \"@web_studio/client_action/report_editor/report_editor_xml/report_editor_xml\";\n\nimport { getCssFromPaperFormat } from \"./utils\";\nimport { standardActionServiceProps } from \"@web/webclient/actions/action_service\";\n\nclass ReportEditor extends Component {\n    static template = \"web_studio.ReportEditor\";\n    static components = { ReportEditorWysiwyg, ReportEditorXml };\n    static props = { ...standardActionServiceProps };\n\n    setup() {\n        this.reportEditorModel = useReportEditorModel();\n    }\n\n    get paperFormatStyle() {\n        const {\n            margin_top,\n            margin_left,\n            margin_right,\n            print_page_height,\n            print_page_width,\n            header_spacing,\n        } = this.reportEditorModel.paperFormat;\n        const marginTop = Math.max(0, (margin_top || 0) - (header_spacing || 0));\n        return getCssFromPaperFormat({\n            margin_top: marginTop,\n            margin_left,\n            margin_right,\n            print_page_height,\n            print_page_width,\n        });\n    }\n}\nregistry.category(\"actions\").add(\"web_studio.report_editor\", ReportEditor);\n", "/** @odoo-module */\nimport { Component, useRef, useState } from \"@odoo/owl\";\nimport { getCssFromPaperFormat } from \"@web_studio/client_action/report_editor/utils\";\nimport { useThrottleForAnimation } from \"@web/core/utils/timing\";\nimport { ErrorDisplay } from \"@web_studio/client_action/report_editor/error_display\";\n\nexport class ReportEditorIframe extends Component {\n    static components = { ErrorDisplay };\n    static template = \"web_studio.ReportEditor.Iframe\";\n    static props = {\n        iframeKey: String,\n        iframeSource: String,\n        onIframeLoaded: Function,\n    };\n\n    setup() {\n        this.reportEditorModel = useState(this.env.reportEditorModel);\n        this.iframeRef = useRef(\"iframeRef\");\n        this.onContainerScroll = useThrottleForAnimation(() => {\n            if (this.iframeRef.el?.contentDocument) {\n                this.iframeRef.el.contentDocument.dispatchEvent(new Event(\"scroll\"));\n            }\n        });\n    }\n\n    get paperFormatStyle() {\n        const {\n            margin_top,\n            margin_left,\n            margin_right,\n            print_page_height,\n            print_page_width,\n            header_spacing,\n        } = this.reportEditorModel.paperFormat;\n        const marginTop = Math.max(0, (margin_top || 0) - (header_spacing || 0));\n        return getCssFromPaperFormat({\n            margin_top: marginTop,\n            margin_left,\n            margin_right,\n            print_page_height,\n            print_page_width,\n        });\n    }\n    get iframeStyle() {\n        const { print_page_height } = this.reportEditorModel.paperFormat;\n        return getCssFromPaperFormat({ print_page_height });\n    }\n\n    get iframeSource() {\n        return this.props.iframeSource;\n    }\n\n    get iframeKey() {\n        return this.reportEditorModel.renderKey + \"_\" + (this.props.iframeKey || \"\");\n    }\n\n    async onIframeLoaded() {\n        await this.resizeIframeContent({ iframeRef: this.iframeRef });\n        this.props.onIframeLoaded({ iframeRef: this.iframeRef });\n    }\n\n    async resizeIframeContent({ iframeRef }) {\n        const paperFormat = this.reportEditorModel.paperFormat;\n        const iframeEl = iframeRef.el;\n        const iframeContent = iframeEl.contentDocument;\n\n        // zoom content from 96 (default browser DPI) to paperformat DPI\n        const zoom = 96 / paperFormat.dpi;\n        Array.from(iframeContent.querySelector(\"main\")?.children || []).forEach((el) => {\n            let sectionZoom = zoom;\n            if (!paperFormat.disable_shrinking) {\n                const { width } = el.getBoundingClientRect();\n                sectionZoom = Math.min(zoom, width / el.scrollWidth);\n            }\n            el.setAttribute(\"oe-origin-style\", el.getAttribute(\"style\") || \"\");\n            el.style.setProperty(\"zoom\", sectionZoom);\n        });\n        // WHY --> so that after the load of the iframe, if there are images,\n        // the iframe height is recomputed to the height of the content images included\n        const computeIframeHeight = () =>\n            (iframeEl.style.height = iframeContent.body.scrollHeight + \"px\");\n        //computeIframeHeight();\n\n        // TODO: it seems that the paperformat doesn't exactly do that\n        // this.$content.find('.header').css({\n        //     'margin-bottom': (this.paperFormat.header_spacing || 0) + 'mm',\n        // });\n        // TODO: won't be pretty if the content is larger than the format\n\n        const footer = iframeContent.querySelector(\".footer\");\n        const footerStyle = footer?.style;\n        if (footerStyle) {\n            const { width } = iframeContent.querySelector(\".page\")?.getBoundingClientRect() || {};\n            footer.setAttribute(\"oe-origin-style\", footer.getAttribute(\"style\") || \"\");\n            footerStyle.setProperty(\"position\", \"fixed\");\n            footerStyle.setProperty(\"bottom\", \"0\");\n            if (width) {\n                footerStyle.setProperty(\"width\", `${width}px`);\n            }\n        }\n\n        iframeContent.querySelector(\"html\").style.overflow = \"hidden\";\n\n        // set the size of the iframe\n        const proms = [];\n        Array.from(iframeContent.querySelectorAll(\"img[src]\") || []).forEach((img) => {\n            if (img.complete) {\n                return;\n            }\n            const prom = new Promise((resolve) => {\n                img.onload = resolve;\n            });\n            proms.push(prom);\n        });\n        await Promise.all(proms);\n        computeIframeHeight();\n    }\n}\n", "/** @odoo-module */\nimport { Reactive } from \"@web_studio/client_action/utils\";\nimport {\n    EventBus,\n    markRaw,\n    onWillStart,\n    reactive,\n    toRaw,\n    useEnv,\n    useState,\n    useSubEnv,\n} from \"@odoo/owl\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { omit, pick } from \"@web/core/utils/objects\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useEditorBreadcrumbs } from \"@web_studio/client_action/editor/edition_flow\";\nimport { KeepLast } from \"@web/core/utils/concurrency\";\nimport { renderToMarkup } from \"@web/core/utils/render\";\nimport { makeActiveField } from \"@web/model/relational_model/utils\";\nimport { humanReadableError } from \"@web_studio/client_action/report_editor/utils\";\n\nconst notificationErrorTemplate = \"web_studio.ReportEditor.NotificationError\";\nconst errorQweb = `<html><div>The report could not be rendered due to an error</div><html>`;\n\nexport class ReportEditorModel extends Reactive {\n    constructor({ services, debug }) {\n        super();\n        this.debug = debug;\n        this.bus = markRaw(new EventBus());\n        this.mode = \"wysiwyg\";\n        this.warningMessage = \"\";\n        this._isDirty = false;\n        this._isInEdition = false;\n        this._services = markRaw(services);\n        this._errorMessage = false;\n        this.paperFormat = {\n            margin_top: 0,\n            margin_left: 0,\n            margin_right: 0,\n            print_page_width: 210,\n            print_page_height: 297,\n        };\n        this.reportFields = markRaw({\n            id: { name: \"id\", type: \"number\" },\n            name: { name: \"name\", type: \"char\" },\n            model: { name: \"model\", type: \"char\" },\n            report_name: { name: \"report_name\", type: \"char\" },\n            groups_id: {\n                name: \"groups_id\",\n                type: \"many2many\",\n                relation: \"res.groups\",\n                relatedFields: {\n                    display_name: { type: \"char\" },\n                },\n            },\n            paperformat_id: {\n                name: \"paperformat_id\",\n                type: \"many2one\",\n                relation: \"report.paperformat\",\n            },\n            binding_model_id: { name: \"binding_model_id\", type: \"many2one\", relation: \"ir.model\" },\n            attachment_use: { name: \"attachment_use\", type: \"boolean\" },\n            attachment: { name: \"attachment\", type: \"char\" },\n            // fake field\n            display_in_print_menu: { name: \"display_in_print_menu\", type: \"boolean\" },\n        });\n        this.reportActiveFields = markRaw({\n            id: makeActiveField(),\n            name: makeActiveField(),\n            model: makeActiveField(),\n            report_name: makeActiveField(),\n            groups_id: {\n                ...makeActiveField(),\n                related: {\n                    fields: { display_name: { name: \"display_name\", type: \"char\" } },\n                    activeFields: { display_name: makeActiveField() },\n                },\n            },\n            paperformat_id: makeActiveField(),\n            binding_model_id: makeActiveField(),\n            attachment_use: makeActiveField(),\n            attachment: makeActiveField(),\n            // fake field\n            display_in_print_menu: makeActiveField(),\n        });\n        this.reportEnv = {};\n        this.loadHtmlKeepLast = markRaw(new KeepLast());\n\n        this._reportArchs = {};\n        this.renderKey = 1;\n        this.routesContext = pick(this._services.user.context, \"allowed_company_ids\");\n    }\n\n    get reportData() {\n        return this._reportChanges || this._reportData;\n    }\n\n    set reportData(_data) {\n        const fields = this.reportFields;\n        const data = { ..._data };\n        for (const [fName, value] of Object.entries(data)) {\n            const field = fields[fName];\n            if (field.type === \"many2many\") {\n                data[fName] = [...value.currentIds];\n            }\n        }\n        this._reportChanges = data;\n    }\n\n    get reportResModel() {\n        return this._reportData.model;\n    }\n\n    get recordToDisplay() {\n        return this.reportEnv.currentId || this.reportEnv.ids.find((i) => !!i) || false;\n    }\n\n    get editedReportId() {\n        return this._services.studio.editedReport.res_id;\n    }\n\n    get reportQweb() {\n        return this._reportArchs.reportQweb;\n    }\n\n    get reportHtml() {\n        return this._reportArchs.reportHtml;\n    }\n\n    get isDirty() {\n        return this._reportChanges || this._isDirty;\n    }\n\n    set isDirty(bool) {\n        this._isDirty = bool;\n    }\n\n    get isInEdition() {\n        return this._isInEdition;\n    }\n\n    get fullErrorDisplay() {\n        return this.debug ? this._errorMessage : false;\n    }\n\n    setInEdition(value) {\n        // Reactivity limitation: if we used a setter, the reactivity will trigger the getter\n        // thus subscribing us to the key. This is not what we want here.\n        value = !!value; // enforce boolean\n        if (reactive(this)._isInEdition === value) {\n            return;\n        }\n        this._isInEdition = value;\n        if (value) {\n            this._services.ui.block();\n        } else {\n            this._services.ui.unblock();\n        }\n    }\n\n    _resetInternalArchs() {\n        // We do this by explicitly bypassing reactivity, we don't want any re-render doing this.\n        // _reportsArchs acts as flag, meaning that if one of the arch is not present\n        // the relevant function will fetch them. see @loadReportQweb and @loadReportHtml\n        toRaw(this)._reportArchs = {};\n    }\n\n    async loadReportEditor() {\n        await this.loadReportData();\n        return this.loadModelEnv();\n    }\n\n    async loadReportData() {\n        const data = await this._services.rpc(\"/web_studio/load_report_editor\", {\n            report_id: this.editedReportId,\n            fields: Object.keys(omit(this.reportActiveFields, \"display_in_print_menu\")),\n            context: this.routesContext,\n        });\n        this._reportData = this._parseFakeFields(data.report_data);\n        Object.assign(this.paperFormat, data.paperformat);\n\n        this._errorMessage = data.qweb_error;\n        this._reportArchs.reportQweb = data.report_qweb || errorQweb;\n        this._isLoaded = true;\n    }\n\n    async loadReportQweb() {\n        if (!this._isLoaded) {\n            return;\n        }\n        if (this._reportArchs.reportQweb) {\n            return;\n        }\n\n        try {\n            const reportQweb = await this.loadHtmlKeepLast.add(\n                this._services.rpc(\"/web_studio/get_report_qweb\", {\n                    report_id: this.editedReportId,\n                    context: this.routesContext,\n                })\n            );\n            this._errorMessage = false;\n            this._reportArchs.reportQweb = reportQweb;\n        } catch (e) {\n            this._errorMessage = e;\n            this._reportArchs.reportQweb = errorQweb;\n        }\n        this.setInEdition(false);\n    }\n\n    async loadReportHtml({ resId } = {}) {\n        if (!this._isLoaded) {\n            return;\n        }\n        if (resId === undefined && this._reportArchs.reportHtml) {\n            return;\n        }\n        this.reportEnv.currentId = resId !== undefined ? resId : this.reportEnv.currentId;\n        try {\n            const reportHtml = await this.loadHtmlKeepLast.add(\n                this._services.rpc(\"/web_studio/get_report_html\", {\n                    report_id: this.editedReportId,\n                    record_id: this.reportEnv.currentId || 0,\n                    context: this.routesContext,\n                })\n            );\n            this._errorMessage = false;\n            this._reportArchs.reportHtml = reportHtml;\n        } catch (e) {\n            this._errorMessage = e;\n            this._reportArchs.reportHtml = errorQweb;\n        }\n        this.setInEdition(false);\n    }\n\n    async saveReport({ htmlParts, urgent, xmlVerbatim } = {}) {\n        const hasPartsToSave = htmlParts && Object.keys(htmlParts).length;\n        const hasVerbatimToSave = xmlVerbatim && Object.keys(xmlVerbatim).length;\n        const hasDataToSave = this.isDirty;\n        this.warningMessage = \"\";\n        if (hasVerbatimToSave && hasPartsToSave) {\n            throw new Error(_t(\"Saving both some report's parts and full xml is not permitted.\"));\n        }\n        if (this._errorMessage && hasPartsToSave) {\n            throw new Error(\n                _t(\"The report is in error. Only editing the XML sources is permitted\")\n            );\n        }\n        if (!hasVerbatimToSave && !hasPartsToSave && !hasDataToSave) {\n            return;\n        }\n        if (!urgent) {\n            this.setInEdition(true);\n        }\n\n        let result;\n        try {\n            result = await this._services.unProtectedRpc(\n                \"/web_studio/save_report\",\n                {\n                    report_id: this.editedReportId,\n                    report_changes: this._reportChanges || null,\n                    html_parts: htmlParts || null,\n                    xml_verbatim: xmlVerbatim || null,\n                    record_id: this.reportEnv.currentId || null,\n                    context: this.routesContext,\n                },\n                { silent: urgent }\n            );\n            this._errorMessage = false;\n        } catch (e) {\n            this.setInEdition(false);\n            const message = renderToMarkup(notificationErrorTemplate, {\n                reportName: this._reportData.name,\n                recordId: this.reportEnv.currentId,\n                error: humanReadableError(e),\n            });\n            this._services.unProtectedNotification.add(message, {\n                type: \"warning\",\n                title: _t(\"Report edition failed\"),\n            });\n            this.warningMessage = _t(\"Report edition failed\");\n\n            if (this._errorMessage) {\n                this._errorMessage = e;\n            }\n\n            return false;\n        }\n\n        if (hasPartsToSave || hasVerbatimToSave) {\n            this._resetInternalArchs();\n        }\n        const { report_data, paperformat, report_html, report_qweb } = result || {};\n        if (!urgent && report_data) {\n            this._reportData = this._parseFakeFields(report_data);\n            this._reportChanges = null;\n            this.paperFormat = paperformat;\n        }\n\n        this.isDirty = false;\n        if (!urgent) {\n            this._reportArchs.reportHtml = report_html;\n            this._reportArchs.reportQweb = report_qweb;\n        }\n        this.setInEdition(false);\n    }\n\n    discardReport() {\n        this.setInEdition(true);\n        this.warningMessage = \"\";\n        this.isDirty = false;\n        this.renderKey++;\n    }\n\n    /**\n     * Load and set the report environment.\n     *\n     * If the report is associated to the same model as the Studio action, the\n     * action ids will be used ; otherwise a search on the report model will be\n     * performed.\n     *\n     * @private\n     * @returns {Promise}\n     */\n    async loadModelEnv() {\n        if (this.reportEnv.ids) {\n            return;\n        }\n        const modelName = this.reportResModel;\n        const result = await this._services.orm.search(modelName, this.getModelDomain(), {\n            context: this._services.user.context,\n        });\n\n        this.reportEnv = {\n            ids: result,\n            currentId: result[0] || false,\n        };\n    }\n\n    getModelDomain() {\n        // TODO: Since 13.0, journal entries are also considered as 'account.move',\n        // therefore must filter result to remove them; otherwise not possible\n        // to print invoices and hard to lookup for them if lot of journal entries.\n        const modelName = this.reportResModel;\n        let domain = [];\n        if (modelName === \"account.move\") {\n            domain = [[\"move_type\", \"!=\", \"entry\"]];\n        }\n        return domain;\n    }\n\n    async resetReport(includeHeaderFooter = true) {\n        this.setInEdition(true);\n        await this._services.rpc(\"/web_studio/reset_report_archs\", {\n            report_id: this.editedReportId,\n            include_web_layout: includeHeaderFooter,\n        });\n\n        this._resetInternalArchs();\n        await this.loadReportQweb();\n    }\n\n    _parseFakeFields(reportData) {\n        reportData.display_in_print_menu = !!reportData.binding_model_id;\n        return reportData;\n    }\n}\n\nexport function useReportEditorModel() {\n    const services = Object.fromEntries(\n        [\"orm\", \"user\", \"rpc\", \"ui\"].map((name) => {\n            return [name, useService(name)];\n        })\n    );\n    const env = useEnv();\n    services.studio = { ...env.services.studio };\n    services.unProtectedRpc = env.services.rpc;\n    services.unProtectedNotification = env.services.notification;\n    const reportEditorModel = new ReportEditorModel({ services, debug: env.debug });\n    useSubEnv({ reportEditorModel });\n\n    function getName(rem) {\n        return rem.reportData?.name;\n    }\n    const crumb = reactive({});\n    const rem = reactive(reportEditorModel, () => {\n        crumb.name = getName(rem);\n    });\n    crumb.name = getName(rem);\n    useEditorBreadcrumbs(crumb);\n\n    onWillStart(() => reportEditorModel.loadReportEditor());\n\n    return useState(reportEditorModel);\n}\n", "/** @odoo-module */\nimport { Component } from \"@odoo/owl\";\n\nexport class ReportEditorSnackbar extends Component {\n    static template = \"web_studio.ReportEditor.SnackBar\";\n    static props = {\n        onSave: Function,\n        state: Object,\n        onDiscard: { type: Function, optional: true },\n    };\n}\n", "/** @odoo-module */\nimport {\n    Component,\n    onWillStart,\n    onMounted,\n    onWillDestroy,\n    onWillUnmount,\n    reactive,\n    useState,\n} from \"@odoo/owl\";\nimport { loadBundle } from \"@web/core/assets\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { omit } from \"@web/core/utils/objects\";\nimport { usePopover } from \"@web/core/popover/popover_hook\";\nimport { useHotkey } from \"@web/core/hotkeys/hotkey_hook\";\nimport { sortBy } from \"@web/core/utils/arrays\";\nimport { useOwnedDialogs, useService } from \"@web/core/utils/hooks\";\nimport { SelectMenu } from \"@web/core/select_menu/select_menu\";\nimport { QWebPlugin } from \"@web_editor/js/backend/QWebPlugin\";\nimport { setSelection, startPos, endPos } from \"@web_editor/js/editor/odoo-editor/src/utils/utils\";\n\nimport { StudioDynamicPlaceholderPopover } from \"./studio_dynamic_placeholder_popover\";\nimport { Many2ManyTagsField } from \"@web/views/fields/many2many_tags/many2many_tags_field\";\nimport { CharField } from \"@web/views/fields/char/char_field\";\nimport { Record as _Record } from \"@web/model/record\";\nimport { Many2OneField } from \"@web/views/fields/many2one/many2one_field\";\nimport { BooleanField } from \"@web/views/fields/boolean/boolean_field\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\n\nimport { ReportEditorSnackbar } from \"@web_studio/client_action/report_editor/report_editor_snackbar\";\nimport { useEditorMenuItem } from \"@web_studio/client_action/editor/edition_flow\";\nimport { memoizeOnce } from \"@web_studio/client_action/utils\";\nimport { ReportEditorIframe } from \"../report_editor_iframe\";\n\nfunction extendWysiwyg(Wysiwyg) {\n    return class CustomWysiwyg extends Wysiwyg {\n        setup() {\n            super.setup();\n            this.overlay = useService(\"overlay\");\n        }\n        _showImageCrop() {\n            const lastMedia = this.lastMediaClicked;\n            const props = { ...this.imageCropProps };\n            props.media = lastMedia;\n            props.activeOnStart = true;\n            const removeOverlay = this.overlay.add(this.constructor.components.ImageCrop, props);\n            const onDestroyed = async () => {\n                removeOverlay();\n                $(lastMedia).off(\"image_cropper_destroyed\", onDestroyed);\n                await Promise.resolve();\n                this.focus();\n                this.odooEditor.toolbarShow();\n            };\n            $(lastMedia).on(\"image_cropper_destroyed\", onDestroyed);\n        }\n    };\n}\n\nclass __Record extends _Record.components._Record {\n    setup() {\n        super.setup();\n        const willSaveUrgently = () => this.model.bus.trigger(\"WILL_SAVE_URGENTLY\");\n        onMounted(() => {\n            this.env.reportEditorModel.bus.addEventListener(\"WILL_SAVE_URGENTLY\", willSaveUrgently);\n        });\n\n        onWillDestroy(() =>\n            this.env.reportEditorModel.bus.removeEventListener(\n                \"WILL_SAVE_URGENTLY\",\n                willSaveUrgently\n            )\n        );\n    }\n}\n\nclass Record extends _Record {\n    static components = { ..._Record.components, _Record: __Record };\n}\n\nfunction getOrderedTAs(node) {\n    const results = [];\n    while (node) {\n        const closest = node.closest(\"[t-foreach]\");\n        if (closest) {\n            results.push(closest.getAttribute(\"t-as\"));\n            node = closest.parentElement;\n        } else {\n            node = null;\n        }\n    }\n    return results;\n}\n\nclass FieldDynamicPlaceholder extends Component {\n    static components = { StudioDynamicPlaceholderPopover, SelectMenu };\n    static template = \"web_studio.FieldDynamicPlaceholder\";\n    static props = {\n        resModel: String,\n        availableQwebVariables: Object,\n        close: Function,\n        validate: Function,\n        isEditingFooterHeader: Boolean,\n        initialQwebVar: { optional: true, type: String },\n        showOnlyX2ManyFields: Boolean,\n    };\n\n    static defaultProps = {\n        initialQwebVar: \"\",\n    };\n\n    setup() {\n        this.state = useState({ currentVar: this.getDefaultVariable() });\n        useHotkey(\"escape\", () => this.props.close());\n    }\n\n    get currentResModel() {\n        const currentVar = this.state.currentVar;\n        const resModel = currentVar && this.props.availableQwebVariables[currentVar].model;\n        return resModel || this.props.resModel;\n    }\n\n    get sortedVariables() {\n        const entries = Object.entries(this.props.availableQwebVariables).filter(\n            ([k, v]) => v.in_foreach && !this.props.isEditingFooterHeader\n        );\n        const resModel = this.props.resModel;\n        const sortFn = ([k, v]) => {\n            let score = 0;\n            if (k === \"doc\") {\n                score += 2;\n            }\n            if (k === \"docs\") {\n                score -= 2;\n            }\n            if (k === \"o\") {\n                score++;\n            }\n            if (v.model === resModel) {\n                score++;\n            }\n            return score;\n        };\n\n        const mapFn = ([k, v]) => {\n            return {\n                value: k,\n                label: `${k} (${v.name})`,\n            };\n        };\n        return sortBy(entries, sortFn, \"desc\").map((e) => mapFn(e));\n    }\n\n    validate(...args) {\n        this.props.validate(this.state.currentVar, ...args);\n    }\n\n    getDefaultVariable() {\n        const initialQwebVar = this.props.initialQwebVar;\n        if (initialQwebVar && initialQwebVar in this.props.availableQwebVariables) {\n            return initialQwebVar;\n        }\n        if (this.props.isEditingFooterHeader) {\n            const companyVar = Object.entries(this.props.availableQwebVariables).find(\n                ([k, v]) => v.model === \"res.company\"\n            );\n            return companyVar && companyVar[0];\n        }\n\n        let defaultVar = this.sortedVariables.find((v) => {\n            return [\"doc\", \"o\"].includes(v.value);\n        });\n        defaultVar =\n            defaultVar ||\n            this.sortedVariables.find(\n                (v) => this.props.availableQwebVariables[v.value].model === this.props.resModel\n            );\n        return defaultVar && defaultVar.value;\n    }\n}\n\nclass UndoRedo extends Component {\n    static template = \"web_studio.ReportEditorWysiwyg.UndoRedo\";\n    static props = {\n        state: Object,\n    };\n}\n\nclass ResetConfirmatiopnPopup extends ConfirmationDialog {\n    static template = \"web_studio.ReportEditorWysiwyg.ResetConfirmatiopnPopup\";\n    static props = {\n        ...omit(ConfirmationDialog.props, \"body\"),\n        state: Object,\n    };\n}\n\nfunction getMaxColumns(row) {\n    let cols = [];\n    const children = Array.from(row.children);\n\n    if (children.every((el) => el.tagName === \"T\")) {\n        for (const child of children) {\n            const subCols = getMaxColumns(child);\n            if (subCols.length > cols.length) {\n                cols = subCols;\n            }\n        }\n    } else {\n        cols = children.filter((el) => el.tagName !== \"T\");\n    }\n\n    return cols;\n}\n\nfunction computeTableLayout(table) {\n    const allRows = table.querySelectorAll(\"[oe-origin-tag='tr']\");\n    let refCols = [];\n    for (const row of allRows) {\n        const cols = getMaxColumns(row);\n        if (cols.length > refCols.length) {\n            refCols = cols;\n        }\n    }\n\n    let numCols = 0;\n    for (const col of refCols) {\n        const colSpan = parseInt(col.getAttribute(\"colspan\") || \"1\");\n        numCols += colSpan;\n    }\n    const baseColSize = Math.floor(100 / numCols);\n    const gap = 10;\n    for (const row of allRows) {\n        const cols = row.querySelectorAll(\"[oe-origin-tag='td'],[oe-origin-tag='th']\");\n        for (const col of cols) {\n            let colSpan = parseInt(col.getAttribute(\"colspan\") || \"1\");\n            if (colSpan > numCols) {\n                colSpan = numCols;\n            }\n            col.setAttribute(\"style\", `width: calc(${baseColSize * colSpan}% - ${gap}px);`);\n        }\n    }\n}\n\nconst CUSTOM_BRANDING_ATTR = [\"ws-view-id\", \"ws-call-key\", \"ws-call-group-key\", \"ws-real-children\"];\nfunction visitNode(el, callback) {\n    const els = [el];\n    while (els.length) {\n        const el = els.pop();\n        callback(el);\n        els.push(...el.children);\n    }\n}\n\nexport class ReportEditorWysiwyg extends Component {\n    static components = {\n        CharField,\n        Record,\n        Many2ManyTagsField,\n        Many2OneField,\n        BooleanField,\n        UndoRedo,\n        ReportEditorIframe,\n    };\n    static props = {\n        paperFormatStyle: String,\n    };\n    static template = \"web_studio.ReportEditorWysiwyg\";\n\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.action = useService(\"action\");\n        this.user = useService(\"user\");\n        this.addDialog = useOwnedDialogs();\n        this.notification = useService(\"notification\");\n\n        this._getReportQweb = memoizeOnce(() => {\n            const tree = new DOMParser().parseFromString(\n                this.reportEditorModel.reportQweb,\n                \"text/html\"\n            );\n            for (const table of tree.querySelectorAll(\"[oe-origin-tag='table']\")) {\n                computeTableLayout(table);\n            }\n            return tree.firstElementChild;\n        });\n\n        const reportEditorModel = (this.reportEditorModel = useState(this.env.reportEditorModel));\n\n        this.state = useState({ wysiwygKey: 0 });\n        this.fieldPopover = usePopover(FieldDynamicPlaceholder);\n        useEditorMenuItem({\n            component: ReportEditorSnackbar,\n            props: {\n                state: reportEditorModel,\n                onSave: this.save.bind(this),\n                onDiscard: this.discard.bind(this),\n            },\n        });\n\n        onWillStart(async () => {\n            await Promise.all([\n                loadBundle(\"web_editor.backend_assets_wysiwyg\"),\n                this.reportEditorModel.loadReportQweb(),\n            ]);\n            const Wysiwyg = (await odoo.loader.modules.get(\"@web_editor/js/wysiwyg/wysiwyg\"))\n                .Wysiwyg;\n            this.Wysiwyg = extendWysiwyg(Wysiwyg);\n        });\n\n        onWillUnmount(() => {\n            this.reportEditorModel.bus.trigger(\"WILL_SAVE_URGENTLY\");\n            this.save({ urgent: true });\n        });\n\n        this.setWysiwygInstance = async (wysiwyg) => {\n            await wysiwyg.startEdition();\n            if (this.observer) {\n                this.observer.disconnect();\n                this.observer = null;\n            }\n            this.wysiwyg = wysiwyg;\n            const odooEditor = this.wysiwyg.odooEditor;\n\n            const undoRedoState = this.undoRedoState;\n            undoRedoState.canUndo = false;\n            undoRedoState.canRedo = false;\n\n            odooEditor.addEventListener(\"historyStep\", () => {\n                undoRedoState.canUndo = odooEditor.historyCanUndo();\n                undoRedoState.canRedo = odooEditor.historyCanRedo();\n                this.reportEditorModel.isDirty = this.undoRedoState.canUndo;\n            });\n\n            const observe = () => {\n                this.observer.observe(wysiwyg.$editable[0], {\n                    childList: true,\n                    subtree: true,\n                    attributes: true,\n                    attributeOldValue: true,\n                    characterData: true,\n                });\n            };\n\n            this.observer = new MutationObserver((records) =>\n                this.domChangesDirtyMutations(odooEditor, records)\n            );\n            odooEditor.addEventListener(\"observerUnactive\", () => {\n                if (this.observer) {\n                    this.domChangesDirtyMutations(odooEditor, this.observer.takeRecords());\n                    this.observer.disconnect();\n                }\n            });\n\n            odooEditor.addEventListener(\"observerActive\", observe);\n\n            odooEditor.observerUnactive();\n            if (odoo.debug) {\n                [\"t-esc\", \"t-out\", \"t-field\"].forEach((tAtt) => {\n                    odooEditor.document.querySelectorAll(`*[${tAtt}]`).forEach((e) => {\n                        // Save the previous title to set it back before saving the report\n                        if (e.hasAttribute(\"title\")) {\n                            e.setAttribute(\"data-oe-title\", e.getAttribute(\"title\"));\n                        }\n                        e.setAttribute(\"title\", e.getAttribute(tAtt));\n                    });\n                });\n            }\n            odooEditor.observerActive();\n        };\n\n        this.undoRedoState = reactive({\n            canUndo: false,\n            canRedo: false,\n            undo: () => this.wysiwyg?.odooEditor.historyUndo(),\n            redo: () => this.wysiwyg?.odooEditor.historyRedo(),\n        });\n    }\n\n    onIframeLoaded({ iframeRef }) {\n        this.iframeRef = iframeRef;\n        const doc = iframeRef.el.contentDocument;\n        const _jquery = window.$;\n        doc.defaultView.$ = (...args) => {\n            if (args.length <= 2 && typeof args[0] === \"string\") {\n                return _jquery(args[0], args[1] || doc);\n            } else {\n                return _jquery(...args);\n            }\n        };\n        doc.body.classList.remove(\"container\");\n        this.state.wysiwygKey++;\n        this.reportEditorModel.setInEdition(false);\n    }\n\n    get reportQweb() {\n        const model = this.reportEditorModel;\n        return this._getReportQweb(`${model.renderKey}_${model.reportQweb}`).outerHTML;\n    }\n\n    get wysiwygProps() {\n        const iframe = this.iframeRef.el;\n        const options = {\n            get editable() {\n                return $(iframe.contentDocument.querySelector(\"#wrapwrap\"));\n            },\n            get document() {\n                return iframe.contentDocument;\n            },\n            powerboxCategories: [{ name: _t(\"Report Tools\"), priority: 100 }], // on Top\n            powerboxCommands: this.getPowerboxCommands(),\n            allowCommandVideo: false,\n            editorPlugins: [QWebPlugin],\n            savableSelector: \"[ws-view-id]\",\n            autostart: true,\n            sideAttach: true,\n            getContextFromParentRect: () => {\n                return this.iframeRef.el.getBoundingClientRect();\n            },\n        };\n\n        return { options, startWysiwyg: this.setWysiwygInstance };\n    }\n\n    get reportRecordProps() {\n        const model = this.reportEditorModel;\n        return {\n            fields: model.reportFields,\n            activeFields: model.reportActiveFields,\n            values: model.reportData,\n        };\n    }\n\n    async save({ urgent = false } = {}) {\n        if (!this.wysiwyg) {\n            return;\n        }\n        const htmlParts = {};\n        const editableClone = this.wysiwyg.$editable.clone()[0];\n\n        this.wysiwyg._saveElement = async ($el) => {\n            const el = $el[0].cloneNode(true);\n            const viewId = el.getAttribute(\"ws-view-id\");\n            if (!viewId) {\n                return;\n            }\n            Array.from(el.querySelectorAll(\"[t-call]\")).forEach((el) => {\n                el.replaceChildren();\n            });\n\n            Array.from(el.querySelectorAll(\"[oe-origin-t-out]\")).forEach((el) => {\n                el.replaceChildren();\n            });\n\n            const callGroupKey = el.getAttribute(\"ws-call-group-key\");\n            const type = callGroupKey ? \"in_t_call\" : \"full\";\n\n            const escaped_html = el.outerHTML;\n            htmlParts[viewId] = htmlParts[viewId] || [];\n\n            htmlParts[viewId].push({\n                call_key: el.getAttribute(\"ws-call-key\"),\n                call_group_key: callGroupKey,\n                type,\n                html: escaped_html,\n            });\n        };\n        // Clean technical title\n        if (odoo.debug) {\n            editableClone.querySelectorAll(\"*[t-field],*[t-out],*[t-esc]\").forEach((e) => {\n                if (e.hasAttribute(\"data-oe-title\")) {\n                    e.setAttribute(\"title\", e.getAttribute(\"data-oe-title\"));\n                    e.removeAttribute(\"data-oe-title\");\n                } else {\n                    e.removeAttribute(\"title\");\n                }\n            });\n        }\n\n        await this.wysiwyg.saveContent(false, editableClone);\n        await this.reportEditorModel.saveReport({ htmlParts, urgent });\n    }\n\n    async discard() {\n        this.wysiwyg.odooEditor.document.getSelection().removeAllRanges();\n        try {\n            await this.wysiwyg.cancel(false);\n        } catch {\n            return\n        }\n        await this.reportEditorModel.discardReport();\n    }\n\n    domChangesDirtyMutations(odooEditor, records) {\n        if (this.wysiwyg.savingContent) {\n            return;\n        }\n        records = odooEditor.filterMutationRecords(records);\n\n        for (const record of records) {\n            if (record.type === \"attributes\") {\n                if (record.attributeName === \"contenteditable\") {\n                    continue;\n                }\n                if (record.attributeName.startsWith(\"data-oe-t\")) {\n                    continue;\n                }\n            }\n            if (record.type === \"childList\") {\n                Array.from(record.addedNodes).forEach((el) => {\n                    if (el.nodeType !== 1) {\n                        return;\n                    }\n                    visitNode(el, (node) => {\n                        CUSTOM_BRANDING_ATTR.forEach((attr) => {\n                            node.removeAttribute(attr);\n                        });\n                        node.classList.remove(\"o_dirty\");\n                    });\n                });\n            }\n\n            let target = record.target;\n            if (!target.isConnected) {\n                continue;\n            }\n            if (target.nodeType !== Node.ELEMENT_NODE) {\n                target = target.parentElement;\n            }\n            if (!target) {\n                continue;\n            }\n\n            target = target.closest(`[ws-view-id]`);\n            if (!target) {\n                continue;\n            }\n            target.classList.add(\"o_dirty\");\n        }\n    }\n\n    getPowerboxCommands() {\n        return [\n            {\n                category: _t(\"Report Tools\"),\n                name: _t(\"Field\"),\n                priority: 150,\n                description: _t(\"Insert a field\"),\n                fontawesome: \"fa-magic\",\n                callback: () => this.insertField(),\n            },\n            {\n                category: _t(\"Report Tools\"),\n                name: _t(\"Dynamic Table\"),\n                priority: 140,\n                description: _t(\"Insert a table based on a relational field.\"),\n                fontawesome: \"fa-magic\",\n                callback: () => this.insertTableX2Many(),\n            },\n        ];\n    }\n\n    getFieldPopoverParams() {\n        const odooEditor = this.wysiwyg.odooEditor;\n        const doc = odooEditor.document;\n\n        const resModel = this.reportEditorModel.reportResModel;\n        const docSelection = doc.getSelection();\n        const { anchorNode } = docSelection;\n        const isEditingFooterHeader =\n            !!(doc.querySelector(\".header\") && doc.querySelector(\".header\").contains(anchorNode)) ||\n            !!(doc.querySelector(\".footer\") && doc.querySelector(\".footer\").contains(anchorNode));\n\n        const popoverAnchor = anchorNode.nodeType === 1 ? anchorNode : anchorNode.parentElement;\n\n        const nodeOeContext = popoverAnchor.closest(\"[oe-context]\");\n        const availableQwebVariables =\n            nodeOeContext && JSON.parse(nodeOeContext.getAttribute(\"oe-context\"));\n\n        return {\n            popoverAnchor,\n            props: {\n                availableQwebVariables,\n                initialQwebVar: getOrderedTAs(popoverAnchor)[0] || \"\",\n                isEditingFooterHeader,\n                resModel,\n            },\n        };\n    }\n\n    async insertTableX2Many() {\n        const { popoverAnchor, props } = this.getFieldPopoverParams();\n        await this.fieldPopover.open(popoverAnchor, {\n            ...props,\n            showOnlyX2ManyFields: true,\n            validate: (\n                qwebVar,\n                fieldNameChain,\n                defaultValue = \"\",\n                is_image,\n                relation,\n                relationName\n            ) => {\n                this.wysiwyg.focus();\n                const doc = this.wysiwyg.odooEditor.document;\n\n                const table = doc.createElement(\"table\");\n                table.classList.add(\"table\", \"table-sm\");\n\n                const tBody = table.createTBody();\n\n                const topRow = tBody.insertRow();\n                topRow.classList.add(\n                    \"border-bottom\",\n                    \"border-top-0\",\n                    \"border-start-0\",\n                    \"border-end-0\",\n                    \"border-2\",\n                    \"border-dark\",\n                    \"fw-bold\"\n                );\n                const topTd = doc.createElement(\"td\");\n                topTd.appendChild(doc.createTextNode(defaultValue || \"Column name\"));\n                topRow.appendChild(topTd);\n\n                const tr = doc.createElement(\"tr\");\n                tr.setAttribute(\"t-foreach\", `${qwebVar}.${fieldNameChain}`);\n                tr.setAttribute(\"t-as\", \"x2many_record\");\n                tr.setAttribute(\n                    \"oe-context\",\n                    JSON.stringify({\n                        x2many_record: {\n                            model: relation,\n                            in_foreach: true,\n                            name: relationName,\n                        },\n                        ...props.availableQwebVariables,\n                    })\n                );\n                tBody.appendChild(tr);\n\n                const td = doc.createElement(\"td\");\n                td.textContent = _t(\"Insert a field...\");\n                tr.appendChild(td);\n\n                this.wysiwyg.odooEditor.execCommand(\"insert\", table);\n                this.iframeRef.el.focus();\n                setSelection(...startPos(td), ...endPos(td), true);\n            },\n        });\n    }\n\n    async insertField() {\n        const { popoverAnchor, props } = this.getFieldPopoverParams();\n        await this.fieldPopover.open(popoverAnchor, {\n            ...props,\n            showOnlyX2ManyFields: false,\n            validate: (qwebVar, fieldNameChain, defaultValue = \"\", is_image) => {\n                this.wysiwyg.focus();\n                const doc = this.wysiwyg.odooEditor.document;\n                const span = doc.createElement(\"span\");\n                span.textContent = defaultValue;\n                span.setAttribute(\"t-field\", `${qwebVar}.${fieldNameChain}`);\n\n                if (odoo.debug) {\n                    span.setAttribute(\"title\", `${qwebVar}.${fieldNameChain}`);\n                }\n\n                if (is_image) {\n                    span.setAttribute(\"t-options-widget\", \"'image'\");\n                    span.setAttribute(\"t-options-qweb_img_raw_data\", 1);\n                }\n                this.wysiwyg.odooEditor.execCommand(\"insert\", span);\n            },\n        });\n    }\n\n    async printPreview() {\n        const model = this.reportEditorModel;\n        await this.save();\n        const recordId = model.reportEnv.currentId || model.reportEnv.ids.find((i) => !!i) || false;\n        if (!recordId) {\n            this.notification.add(\n                _t(\n                    \"There is no record on which this report can be previewed. Create at least one record to preview the report.\"\n                ),\n                {\n                    type: \"danger\",\n                    title: _t(\"Report preview not available\"),\n                }\n            );\n            return;\n        }\n\n        const action = await this.rpc(\"/web_studio/print_report\", {\n            record_id: recordId,\n            report_id: model.editedReportId,\n        });\n        this.reportEditorModel.renderKey++;\n        return this.action.doAction(action, { clearBreadcrumbs: true });\n    }\n\n    async resetReport() {\n        if (this.wysiwyg?.odooEditor) {\n            this.wysiwyg.odooEditor.document.getSelection()?.removeAllRanges();\n        }\n        const state = reactive({ includeHeaderFooter: true });\n        this.addDialog(ResetConfirmatiopnPopup, {\n            title: _t(\"Reset report\"),\n            confirmLabel: _t(\"Reset report\"),\n            confirmClass: \"btn-danger\",\n            cancelLabel: _t(\"Go back\"),\n            state,\n            cancel: () => {},\n            confirm: async () => {\n                await this.reportEditorModel.saveReport();\n                try {\n                    await this.reportEditorModel.resetReport(state.includeHeaderFooter);\n                } finally {\n                    this.reportEditorModel.renderKey++;\n                }\n            },\n        });\n    }\n\n    async openReportFormView() {\n        await this.save();\n        return this.action.doAction(\n            {\n                type: \"ir.actions.act_window\",\n                res_model: \"ir.actions.report\",\n                res_id: this.reportEditorModel.editedReportId,\n                views: [[false, \"form\"]],\n                target: \"current\",\n            },\n            { clearBreadcrumbs: true }\n        );\n    }\n\n    async editSources() {\n        await this.save();\n        this.reportEditorModel.mode = \"xml\";\n    }\n}\n", "/** @odoo-module **/\n\nimport { DynamicPlaceholderPopover } from \"@web/views/fields/dynamic_placeholder_popover\";\nimport { useLoadFieldInfo } from \"@web/core/model_field_selector/utils\";\n\nexport class StudioDynamicPlaceholderPopover extends DynamicPlaceholderPopover {\n    static template = \"web_studio.StudioDynamicPlaceholderPopover\";\n    static props = [...DynamicPlaceholderPopover.props, \"showOnlyX2ManyFields\"];\n    setup() {\n        super.setup();\n        this.loadFieldInfo = useLoadFieldInfo();\n    }\n\n    filter(fieldDef) {\n        if (this.props.showOnlyX2ManyFields) {\n            return [\"one2many\", \"many2many\"].includes(fieldDef.type);\n        } else {\n            /**\n             * We don't want to display x2many fields inside a report as it would not make sense.\n             * We also don't want to display boolean fields.\n             * This override is necessary because we want to be able to select non-searchable fields.\n             * There is no reason as to why this wouldn't be allowed inside a report as we don't search on those fields,\n             * we simply render them.\n             */\n            return ![\"one2many\", \"boolean\", \"many2many\"].includes(fieldDef.type);\n        }\n    }\n\n    async validate() {\n        const fieldInfo = (await this.loadFieldInfo(this.props.resModel, this.state.path)).fieldDef;\n        const filename_exists = (\n            await this.loadFieldInfo(this.props.resModel, this.state.path + \"_filename\")\n        ).fieldDef;\n        const is_image = fieldInfo.type == \"binary\" && !filename_exists;\n        this.props.close();\n        this.props.validate(this.state.path, this.state.defaultValue, is_image, fieldInfo.relation, fieldInfo.string);\n    }\n}\n", "/** @odoo-module */\nimport { Component, onWillStart, onWillUnmount, toRaw, useState } from \"@odoo/owl\";\nimport { XmlResourceEditor } from \"@web_studio/client_action/xml_resource_editor/xml_resource_editor\";\nimport { useEditorMenuItem } from \"@web_studio/client_action/editor/edition_flow\";\nimport { ReportEditorSnackbar } from \"@web_studio/client_action/report_editor/report_editor_snackbar\";\nimport { ReportRecordNavigation } from \"./report_record_navigation\";\nimport { useBus, useOwnedDialogs, useService } from \"@web/core/utils/hooks\";\nimport { ReportEditorIframe } from \"../report_editor_iframe\";\nimport { localization } from \"@web/core/l10n/localization\";\nimport { TranslationDialog } from \"@web/views/fields/translation_dialog\";\nimport { View } from \"@web/views/view\";\n\nclass ReportResourceEditor extends XmlResourceEditor {\n    static props = { ...XmlResourceEditor.props, slots: Object };\n    setup() {\n        super.setup();\n        useBus(this.env.reportEditorModel.bus, \"node-clicked\", (ev) => {\n            const { viewId } = ev.detail;\n            const nextResource = this.state.resourcesOptions.find((opt) => opt.value === viewId);\n            if (nextResource) {\n                this.state.currentResourceId = nextResource.value;\n            }\n        });\n    }\n}\n\nclass TranslationButton extends Component {\n    static template = \"web.TranslationButton\";\n    static props = {\n        resourceId: Number,\n    };\n\n    setup() {\n        this.user = useService(\"user\");\n        this.addDialog = useOwnedDialogs();\n    }\n\n    get isMultiLang() {\n        return localization.multiLang;\n    }\n    get lang() {\n        return this.user.lang.split(\"_\")[0].toUpperCase();\n    }\n    onClick() {\n        this.addDialog(TranslationDialog, {\n            fieldName: \"arch_db\",\n            resModel: \"ir.ui.view\",\n            resId: this.props.resourceId,\n            onSave: () => {\n                const model = this.env.reportEditorModel;\n                model.loadReportHtml({ resId: model.reportEnv.currentId });\n            },\n        });\n    }\n}\n\nclass _View extends View {\n    async loadView() {\n        const res = await super.loadView(...arguments);\n        const Controller = this.Controller;\n        if (\n            !(\"afterExecuteActionButton\" in Controller.props) &&\n            \"afterExecuteActionButton\" in Controller.prototype\n        ) {\n            class _Controller extends Controller {\n                afterExecuteActionButton(clickParams) {\n                    const res = super.afterExecuteActionButton(...arguments);\n                    this.props.afterExecuteActionButton(this.model, ...arguments);\n                    return res;\n                }\n            }\n            _Controller.props = {\n                ...Controller.props,\n                afterExecuteActionButton: { type: Function },\n            };\n            this.Controller = _Controller;\n        }\n        return res;\n    }\n}\n\nexport class ReportEditorXml extends Component {\n    static components = {\n        XmlResourceEditor: ReportResourceEditor,\n        ReportRecordNavigation,\n        ReportEditorIframe,\n        TranslationButton,\n        View: _View,\n    };\n    static template = \"web_studio.ReportEditorXml\";\n    static props = {\n        paperFormatStyle: String,\n    };\n\n    setup() {\n        this.reportEditorModel = useState(this.env.reportEditorModel);\n        this.state = useState({\n            xmlChanges: null,\n            reloadSources: 1,\n            viewIdToDiff: false,\n            warningMessage: \"\",\n            get isDirty() {\n                return !!this.xmlChanges;\n            },\n        });\n\n        useEditorMenuItem({\n            component: ReportEditorSnackbar,\n            props: {\n                state: this.state,\n                onSave: this.save.bind(this),\n                onDiscard: this.discardChanges.bind(this),\n            },\n        });\n\n        onWillStart(() => this.reportEditorModel.loadReportHtml());\n\n        onWillUnmount(() => {\n            this.save({ urgent: true });\n        });\n    }\n\n    get minWidth() {\n        const factor = this.state.viewIdToDiff ? 0.2 : 0.4;\n        return Math.floor(document.documentElement.clientWidth * factor);\n    }\n\n    async onCloseXmlEditor() {\n        await this.save();\n        this.reportEditorModel.mode = \"wysiwyg\";\n    }\n\n    onXmlChanged(changes) {\n        this.state.xmlChanges = changes;\n    }\n\n    getDefaultResource(resourcesOptions, mainKey) {\n        let mainResource;\n        if (mainKey) {\n            mainResource = resourcesOptions.find(opt => opt.resource.key === mainKey);\n        }\n        if (mainResource) {\n            const studioExtension = resourcesOptions.find(opt => {\n                const key = opt.resource.key;\n                const parentId = opt.resource.inherit_id && opt.resource.inherit_id[0];\n                return key.includes(\"web_studio.report_editor_customization\") &&\n                    parentId === mainResource.resource.id;\n            })\n            return studioExtension || mainResource;\n        }\n    }\n\n    async save({ urgent = false } = {}) {\n        const changes = { ...toRaw(this.state.xmlChanges) };\n        const result = await this.reportEditorModel.saveReport({\n            urgent,\n            xmlVerbatim: changes,\n        });\n        this.state.warningMessage = this.reportEditorModel.warningMessage;\n        if (result !== false) {\n            this.state.xmlChanges = null;\n            if (!urgent && Object.keys(changes).length) {\n                this.state.reloadSources++;\n            }\n        }\n    }\n\n    async discardChanges() {\n        this.state.xmlChanges = null;\n        this.state.reloadSources++;\n    }\n\n    onIframeLoaded({ iframeRef }) {\n        iframeRef.el.contentWindow.document.addEventListener(\"click\", (ev) => {\n            const target = ev.target;\n            const brandingTarget = target.closest(\n                `[data-oe-model=\"ir.ui.view\"][data-oe-field=\"arch\"]`\n            );\n            if (!brandingTarget) {\n                return;\n            }\n            const viewId = parseInt(brandingTarget.getAttribute(\"data-oe-id\"));\n            this.reportEditorModel.bus.trigger(\"node-clicked\", { viewId });\n        });\n        this.reportEditorModel.setInEdition(false);\n    }\n\n    async switchToDiff(viewId) {\n        await this.save();\n        this.state.viewIdToDiff = viewId;\n    }\n\n    get diffProps() {\n        return {\n            type: \"form\",\n            resModel: \"reset.view.arch.wizard\",\n            context: {\n                studio: false,\n                studio_report_diff: true,\n                active_ids: [this.state.viewIdToDiff],\n                active_model: \"ir.ui.view\",\n            },\n            afterExecuteActionButton: (model, clickParams) => {\n                if (\n                    model.root.resModel === \"reset.view.arch.wizard\" &&\n                    clickParams.name === \"reset_view_button\"\n                ) {\n                    this.state.reloadSources++;\n                    this.reportEditorModel._resetInternalArchs();\n                    this.reportEditorModel.loadReportHtml();\n                }\n            },\n            preventCreate: true,\n        };\n    }\n\n    onResourceChanged(resource) {\n        if (this.state.viewIdToDiff) {\n            this.state.viewIdToDiff = resource.id;\n        }\n    }\n}\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\n\nimport { Pager } from \"@web/core/pager/pager\";\nimport { RecordSelector } from \"@web/core/record_selectors/record_selector\";\n\nexport class ReportRecordNavigation extends Component {\n    static components = { RecordSelector, Pager };\n    static template = \"web_studio.ReportEditor.ReportRecordNavigation\";\n    static props = {};\n\n    setup() {\n        this.reportEditorModel = useState(this.env.reportEditorModel);\n    }\n\n    get multiRecordSelectorProps() {\n        const currentId = this.reportEditorModel.reportEnv.currentId;\n        return {\n            resModel: this.reportEditorModel.reportResModel,\n            update: (resId) => {\n                this.reportEditorModel.loadReportHtml({ resId });\n            },\n            resId: currentId,\n            domain: this.reportEditorModel.getModelDomain(),\n            context: { studio: false },\n        };\n    }\n\n    get pagerProps() {\n        const { reportEnv } = this.reportEditorModel;\n        const { ids, currentId } = reportEnv;\n        return {\n            limit: 1,\n            offset: ids.indexOf(currentId),\n            total: ids.length,\n        };\n    }\n\n    updatePager({ offset }) {\n        const ids = this.reportEditorModel.reportEnv.ids;\n        const resId = ids[offset];\n        this.reportEditorModel.loadReportHtml({ resId });\n    }\n}\n", "/** @odoo-module */\n\nconst PAPER_TO_CSS = {\n    margin_top: \"padding-top\",\n    margin_left: \"padding-left\",\n    margin_right: \"padding-right\",\n    print_page_width: \"width\",\n    print_page_height: \"min-height\",\n};\n\nexport function getCssFromPaperFormat(paperFormat, unit = \"mm\") {\n    return Object.entries(paperFormat)\n        .map((f) => `${PAPER_TO_CSS[f[0]]}:${f[1]}${unit}`)\n        .join(\";\");\n}\n\nconst RECORDSET_RE = /(?<resModel>(\\w+.?)*)\\((?<resIds>(\\d*,?)*)\\)/;\nfunction recordSetReprToData(string) {\n    const { resModel, resIds } = string.match(RECORDSET_RE).groups;\n    return {\n        resModel,\n        resIds: resIds.split(\",\").flatMap((id) => (id ? parseInt(id) : [])),\n    };\n}\n\nexport function humanReadableError(error) {\n    if (error.code === 200 && error.data) {\n        error = error.data;\n    }\n    let viewError;\n    if (error.context?.view) {\n        // see @ def _raise_view_error.\n        const { resIds, resModel } = recordSetReprToData(error.context.view);\n        const { resIds: parentIds } = recordSetReprToData(error.context[\"view.parent\"]);\n        const viewName = error.context.name;\n        viewError = {\n            viewModel: resModel,\n            completeName: error.context.xml_id ? `${viewName} (${error.context.xml_id})` : viewName,\n            resIds,\n            resModel: error.context[\"view.model\"],\n            parentIds,\n        };\n    }\n    return {\n        ...error,\n        traceback: error.debug,\n        viewError,\n    };\n}\n", "/** @odoo-module **/\n\nimport { registry } from \"@web/core/registry\";\nimport { useBus, useService } from \"@web/core/utils/hooks\";\nimport { standardActionServiceProps } from \"@web/webclient/actions/action_service\";\nimport { computeAppsAndMenuItems, reorderApps } from \"@web/webclient/menus/menu_helpers\";\n\nimport { useServicesOverrides } from \"@web_studio/client_action/utils\";\nimport { AppCreator } from \"./app_creator/app_creator\";\nimport { Editor } from \"./editor/editor\";\nimport { StudioNavbar } from \"./navbar/navbar\";\nimport { StudioHomeMenu } from \"./studio_home_menu/studio_home_menu\";\n\nimport { Component, onWillStart, onMounted, onPatched, onWillUnmount } from \"@odoo/owl\";\nimport { ormService } from \"@web/core/orm_service\";\n\nconst studioUserService = {\n    dependencies: [\"user\"],\n    start(env, { user }) {\n        const originalUserService = user;\n        user = Object.create(user);\n        Object.defineProperty(user, \"context\", {\n            get() {\n                return { ...originalUserService.context, studio: 1 };\n            },\n        });\n        return user;\n    },\n};\n\nexport class StudioClientAction extends Component {\n    setup() {\n        // Reinstanciate the ORM service with a custom user service.\n        // The ORM calls down the line will be done with the studio context key\n        // The ORM calls made from the original ORM service, in particular the viewService:loadViews\n        // are not affected and will be made without the studio context key.\n        useServicesOverrides({ orm: ormService, user: studioUserService });\n\n        const user = useService(\"user\");\n        const homemenuConfig = JSON.parse(user.settings?.homemenu_config || \"null\");\n        this.studio = useService(\"studio\");\n        useBus(this.studio.bus, \"UPDATE\", () => {\n            this.render();\n        });\n\n        this.menus = useService(\"menu\");\n        this.actionService = useService(\"action\");\n        let apps = computeAppsAndMenuItems(this.menus.getMenuAsTree(\"root\")).apps;\n        if (homemenuConfig) {\n            reorderApps(apps, homemenuConfig);\n        }\n        this.homeMenuProps = {\n            apps: apps,\n        };\n        useBus(this.env.bus, \"MENUS:APP-CHANGED\", () => {\n            apps = computeAppsAndMenuItems(this.menus.getMenuAsTree(\"root\")).apps;\n            if (homemenuConfig) {\n                reorderApps(apps, homemenuConfig);\n            }\n            this.homeMenuProps = {\n                apps: apps,\n            };\n            this.render();\n        });\n\n        onWillStart(this.onWillStart);\n        onMounted(this.onMounted);\n        onPatched(this.onPatched);\n        onWillUnmount(this.onWillUnmount);\n    }\n\n    onWillStart() {\n        return this.studio.ready;\n    }\n\n    onMounted() {\n        this.studio.pushState();\n        document.body.classList.add(\"o_in_studio\"); // FIXME ?\n    }\n\n    onPatched() {\n        this.studio.pushState();\n    }\n\n    onWillUnmount() {\n        document.body.classList.remove(\"o_in_studio\");\n    }\n\n    async onNewAppCreated({ action_id, menu_id }) {\n        await this.menus.reload();\n        this.menus.setCurrentMenu(menu_id);\n        const action = await this.actionService.loadAction(action_id);\n\n        let initViewType = \"form\";\n        if (!action.views.some((vTuple) => vTuple[1] === initViewType)) {\n            initViewType = action.views[0][1];\n        }\n\n        this.studio.setParams({\n            mode: this.studio.MODES.EDITOR,\n            editorTab: \"views\",\n            action,\n            viewType: initViewType,\n        });\n    }\n}\nStudioClientAction.template = \"web_studio.StudioClientAction\";\nStudioClientAction.props = { ...standardActionServiceProps };\nStudioClientAction.components = {\n    StudioNavbar,\n    StudioHomeMenu,\n    Editor,\n    AppCreator,\n};\nStudioClientAction.target = \"fullscreen\";\n\nregistry.category(\"lazy_components\").add(\"StudioClientAction\", StudioClientAction);\n// force: true to bypass the studio lazy loading action next time and just use this one directly\nregistry.category(\"actions\").add(\"studio\", StudioClientAction, { force: true });\n", "/** @odoo-module **/\n\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { IconCreator } from \"@web_studio/client_action/icon_creator/icon_creator\";\n\nimport { Component, useState } from \"@odoo/owl\";\n\nexport class IconCreatorDialog extends Component {\n    setup() {\n        this.user = useService(\"user\");\n        this.rpc = useService(\"rpc\");\n        this.menus = useService(\"menu\");\n        this.initialAppData = { ...this.props.editedAppData };\n        this.editedAppData = useState(this.props.editedAppData);\n    }\n\n    /**\n     * @param {Object} icon\n     */\n    onIconChanged(icon) {\n        for (const key in this.editedAppData) {\n            delete this.editedAppData[key];\n        }\n        for (const key in icon) {\n            this.editedAppData[key] = icon[key];\n        }\n    }\n\n    async saveIcon() {\n        const { type } = this.initialAppData;\n        const appId = this.props.appId;\n        let iconValue;\n        if (this.editedAppData.type !== type) {\n            // different type\n            if (this.editedAppData.type === \"base64\") {\n                iconValue = this.editedAppData.uploaded_attachment_id;\n            } else {\n                const { iconClass, color, backgroundColor } = this.editedAppData;\n                iconValue = [iconClass, color, backgroundColor];\n            }\n        } else if (this.editedAppData.type === \"custom_icon\") {\n            // custom icon changed\n            const { iconClass, color, backgroundColor } = this.editedAppData;\n            if (\n                this.initialAppData.iconClass !== iconClass ||\n                this.initialAppData.color !== color ||\n                this.initialAppData.backgroundColor !== backgroundColor\n            ) {\n                iconValue = [iconClass, color, backgroundColor];\n            }\n        } else if (this.editedAppData.uploaded_attachment_id) {\n            // new attachment\n            iconValue = this.editedAppData.uploaded_attachment_id;\n        }\n\n        if (iconValue) {\n            await this.rpc(\"/web_studio/edit_menu_icon\", {\n                context: this.user.context,\n                icon: iconValue,\n                menu_id: appId,\n            });\n            await this.menus.reload();\n        }\n        this.props.close();\n    }\n}\nIconCreatorDialog.title = _t(\"Edit Application Icon\");\nIconCreatorDialog.props = {\n    editedAppData: Object,\n    appId: Number,\n    close: Function,\n};\nIconCreatorDialog.template = \"web_studio.IconCreatorDialog\";\nIconCreatorDialog.components = { Dialog, IconCreator };\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { HomeMenu } from \"@web_enterprise/webclient/home_menu/home_menu\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { NotEditableActionError } from \"../../studio_service\";\nimport { IconCreatorDialog } from \"./icon_creator_dialog/icon_creator_dialog\";\n\nimport { onMounted, onWillUnmount, useRef } from \"@odoo/owl\";\nconst NEW_APP_BUTTON = {\n    isNewAppButton: true,\n    label: _t(\"New App\"),\n    webIconData: \"/web_studio/static/src/img/default_icon_app.png\",\n};\n\n/**\n * Studio home menu\n *\n * Studio version of the standard enterprise home menu. It has roughly the same\n * implementation, with the exception of the app icon edition and the app creator.\n * @extends HomeMenu\n */\nexport class StudioHomeMenu extends HomeMenu {\n    /**\n     * @param {Object} props\n     * @param {Object[]} props.apps application icons\n     * @param {string} props.apps[].action\n     * @param {number} props.apps[].id\n     * @param {string} props.apps[].label\n     * @param {string} props.apps[].parents\n     * @param {(boolean|string|Object)} props.apps[].webIcon either:\n     *      - boolean: false (no webIcon)\n     *      - string: path to Odoo icon file\n     *      - Object: customized icon (background, class and color)\n     * @param {string} [props.apps[].webIconData]\n     * @param {string} props.apps[].xmlid\n     */\n    setup() {\n        super.setup(...arguments);\n\n        this.user = useService(\"user\");\n        this.studio = useService(\"studio\");\n        this.notifications = useService(\"notification\");\n        this.dialog = useService(\"dialog\");\n        this.root = useRef(\"root\");\n\n        onMounted(() => {\n            this.canEditIcons = true;\n            document.body.classList.add(\"o_home_menu_background\");\n            document.body.classList.toggle(\n                \"o_home_menu_background_custom\",\n                this.menus.getMenu(\"root\").backgroundImage\n            );\n        });\n\n        onWillUnmount(() => {\n            document.body.classList.remove(\n                \"o_home_menu_background\",\n                \"o_home_menu_background_custom\"\n            );\n        });\n    }\n\n    //--------------------------------------------------------------------------\n    // Getters\n    //--------------------------------------------------------------------------\n\n    get displayedApps() {\n        return [...super.displayedApps, NEW_APP_BUTTON];\n    }\n\n    //--------------------------------------------------------------------------\n    // Protected\n    //--------------------------------------------------------------------------\n\n    async _openMenu(menu) {\n        if (menu.isNewAppButton) {\n            this.canEditIcons = false;\n            return this.studio.open(this.studio.MODES.APP_CREATOR);\n        } else {\n            try {\n                await this.studio.open(this.studio.MODES.EDITOR, menu.actionID);\n                this.menus.setCurrentMenu(menu);\n            } catch (e) {\n                if (e instanceof NotEditableActionError) {\n                    const options = { type: \"danger\" };\n                    this.notifications.add(_t(\"This action is not editable by Studio\"), options);\n                    return;\n                }\n                throw e;\n            }\n        }\n    }\n\n    _enableAppsSorting() {\n        return false;\n    }\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @param {Object} app\n     */\n    onEditIconClick(app) {\n        if (!this.canEditIcons) {\n            return;\n        }\n        const editedAppData = {};\n        if (app.webIconData) {\n            Object.assign(editedAppData, {\n                webIconData: app.webIconData,\n                type: \"base64\",\n            });\n        } else {\n            Object.assign(editedAppData, {\n                backgroundColor: app.webIcon.backgroundColor,\n                color: app.webIcon.color,\n                iconClass: app.webIcon.iconClass,\n                type: \"custom_icon\",\n            });\n        }\n\n        const dialogProps = {\n            editedAppData,\n            appId: app.id,\n        };\n        this.dialog.add(IconCreatorDialog, dialogProps);\n    }\n}\n\nStudioHomeMenu.props = { apps: HomeMenu.props.apps };\nStudioHomeMenu.template = \"web_studio.StudioHomeMenu\";\n", "/** @odoo-module */\nimport { reactive, useComponent, useEnv, useSubEnv } from \"@odoo/owl\";\n\nexport function getFieldsInArch(xmlDoc) {\n    return Array.from(xmlDoc.querySelectorAll(\"field\"))\n        .filter((el) => !el.parentElement.closest(\"field,groupby\"))\n        .map((n) => n.getAttribute(\"name\"));\n}\n\nexport function useDialogConfirmation({ confirm, cancel, before, close }) {\n    before = before || (() => {});\n    confirm = confirm || (() => {});\n    cancel = cancel || (() => {});\n    if (!close) {\n        const component = useComponent();\n        close = () => component.props.close();\n    }\n\n    let isProtected = false;\n    async function canExecute() {\n        if (isProtected) {\n            return false;\n        }\n        isProtected = true;\n        await before();\n        return true;\n    }\n\n    async function execute(cb, ...args) {\n        let succeeded = false;\n        try {\n            succeeded = await cb(...args);\n        } catch (e) {\n            close();\n            throw e;\n        }\n        if (succeeded === undefined || succeeded) {\n            return close();\n        }\n        isProtected = false;\n    }\n\n    async function _confirm(...args) {\n        if (!(await canExecute())) {\n            return;\n        }\n        return execute(confirm, ...args);\n    }\n\n    async function _cancel(...args) {\n        if (!(await canExecute())) {\n            return;\n        }\n        return execute(cancel, ...args);\n    }\n\n    const env = useEnv();\n    env.dialogData.dismiss = () => _cancel();\n\n    return { confirm: _confirm, cancel: _cancel };\n}\n\nexport class Reactive {\n    constructor() {\n        const raw = this;\n        // A function not bound to this returning the original not reactive object\n        // This is usefull to be able to read stuff without subscribing the caller\n        // eg: when reading internals just for checking\n        this.raw = () => {\n            return raw;\n        };\n        return reactive(this);\n    }\n}\n\n// A custom memoize function that doesn't store all results\n// First the core/function/memoize tool may yield incorrect result in our case.\n// Second, the keys we use usually involve archs themselves that could be heavy in the long run.\nexport function memoizeOnce(callback) {\n    let key, value;\n    return function (...args) {\n        if (key === args[0]) {\n            return value;\n        }\n        key = args[0];\n        value = callback.call(this, ...args);\n        return value;\n    };\n}\n\nexport function useSubEnvAndServices(env) {\n    const services = env.services;\n    const bus = env.bus;\n    useSubEnv(env);\n    useSubEnv({ services, bus });\n}\n\n/**\n * Sorts a list topologically, each element's dependencies should be defined\n * with the getDependencies callback.\n * This is a copy of what is done in python: odoo.tools.misc.py:def topological_sort\n * @params [Array] elems\n * @params [Function] getDependencies\n */\nfunction topologicalSort(elems, getDependencies) {\n    const result = [];\n    const visited = new Set();\n    function visit(n) {\n        if (visited.has(n)) {\n            return;\n        }\n        visited.add(n);\n        if (!elems.includes(n)) {\n            return;\n        }\n        // first visit all dependencies of n, then append n to result\n        for (const dep of getDependencies(n)) {\n            visit(dep);\n        }\n        result.push(n);\n    }\n\n    for (const el of elems) {\n        visit(el);\n    }\n\n    return result;\n}\n\n/**\n * Allows to override the services defined in the env with a new instance\n * of each one defined in \"overrides\".\n * This function assumes all services in overrides start synchronously\n * @params [Object] overrides: new instances of services to create\n *     the key is the service's name, the value is the service definition\n */\nexport function useServicesOverrides(overrides) {\n    let env = useEnv();\n    const services = Object.create(env.services);\n\n    useSubEnv({ services });\n    env = useEnv();\n    const getDependencies = (name) => overrides[name]?.dependencies || [];\n    const topoSorted = topologicalSort(Object.keys(overrides), getDependencies);\n\n    for (const servName of topoSorted) {\n        services[servName] = overrides[servName].start(env, services);\n    }\n}\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\n\nexport class DefaultViewSidebar extends Component {\n    static template = \"web_studio.ViewEditor.DefaultViewSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n    }\n}\n", "/** @odoo-module */\n\nimport { calendarView } from \"@web/views/calendar/calendar_view\";\nimport { registry } from \"@web/core/registry\";\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { fieldsToChoices } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { SCALE_LABELS } from \"@web/views/calendar/calendar_controller\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nexport class CalendarEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.CalendarEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        Property,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n    }\n\n    get archInfo() {\n        return this.viewEditorModel.controllerProps.archInfo;\n    }\n\n    onViewAttributeChanged(value, name) {\n        return this.editArchAttributes({ [name]: value });\n    }\n\n    get quickCreateFields() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) => field.type === \"char\" && field.store\n        );\n    }\n\n    get startDateFields() {\n        return fieldsToChoices(this.viewEditorModel.fields, (field) =>\n            [\"date\", \"datetime\"].includes(field.type)\n        );\n    }\n\n    get delayFields() {\n        return fieldsToChoices(this.viewEditorModel.fields, (field) =>\n            [\"float\", \"integer\"].includes(field.type)\n        );\n    }\n\n    get colorFields() {\n        return fieldsToChoices(this.viewEditorModel.fields, (field) =>\n            [\"many2one\", \"selection\"].includes(field.type)\n        );\n    }\n\n    get allDayFields() {\n        return fieldsToChoices(this.viewEditorModel.fields, (field) => field.type === \"boolean\");\n    }\n\n    get modeChoices() {\n        return this.viewEditorModel.controllerProps.archInfo.scales.map((value) => {\n            return {\n                value,\n                label: SCALE_LABELS[value],\n            };\n        });\n    }\n}\n\nregistry.category(\"studio_editors\").add(\"calendar\", {\n    ...calendarView,\n    Sidebar: CalendarEditorSidebar,\n});\n", "/** @odoo-module */\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { registry } from \"@web/core/registry\";\nimport { cohortView } from \"@web_cohort/cohort_view\";\n\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { fieldsToChoices } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nexport class CohortEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.CohortEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        Property,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n    }\n\n    onViewAttributeChanged(value, name) {\n        value = value ? value : \"\";\n        return this.editArchAttributes({ [name]: value });\n    }\n\n    get modelParams() {\n        return this.env.viewEditorModel.controllerProps.modelParams;\n    }\n\n    get dateFields() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) => field.store && [\"date\", \"datetime\"].includes(field.type)\n        );\n    }\n\n    get measureFields() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) =>\n                field.name !== \"id\" &&\n                field.store &&\n                [\"integer\", \"float\", \"monetary\"].includes(field.type)\n        );\n    }\n\n    get intervalChoices() {\n        return [\n            { label: _t(\"Day\"), value: \"day\" },\n            { label: _t(\"Week\"), value: \"week\" },\n            { label: _t(\"Month\"), value: \"month\" },\n            { label: _t(\"Year\"), value: \"year\" },\n        ];\n    }\n\n    get modeChoices() {\n        return [\n            { label: _t(\"Retention\"), value: \"retention\" },\n            { label: _t(\"Churn\"), value: \"churn\" },\n        ];\n    }\n\n    get timelineChoices() {\n        return [\n            { label: _t(\"Forward\"), value: \"forward\" },\n            { label: _t(\"Backwards\"), value: \"backward\" },\n        ];\n    }\n}\n\nregistry.category(\"studio_editors\").add(\"cohort\", {\n    ...cohortView,\n    Sidebar: CohortEditorSidebar,\n});\n", "/** @odoo-module */\nimport { _t } from \"@web/core/l10n/translation\";\nimport { Component, xml } from \"@odoo/owl\";\nimport { viewTypeToString } from \"@web_studio/studio_service\";\n\n/*\n * Injected in the Field.js template\n * Allows to overlay the Field's Component widget to prompt\n * for editing a x2many subview\n */\nexport class FieldContentOverlay extends Component {\n    static template = xml`\n    <div class=\"position-relative\">\n      <t t-slot=\"default\" />\n      <div class=\"o-web-studio-edit-x2manys-buttons w-100 h-100 d-flex justify-content-center gap-3 position-absolute start-0 top-0 opacity-75 bg-dark\" t-if=\"props.displayOverlay\" style=\"z-index: 1000;\">\n          <button class=\"btn btn-primary btn-secondary o_web_studio_editX2Many align-self-center\"\n          t-foreach=\"['list', 'form']\" t-as=\"vType\" t-key=\"vType\"\n          t-on-click.stop=\"() => props.onEditViewType(vType)\"\n          t-att-data-type=\"vType\">\n          <t t-esc=\"getButtonText(vType)\" />\n          </button>\n      </div>\n    </div>`;\n\n    static props = {\n        displayOverlay: { type: Boolean },\n        slots: { type: Object },\n        onEditViewType: { type: Function },\n    };\n\n    getButtonText(viewType) {\n        return _t(\"Edit %s view\", viewTypeToString(viewType));\n    }\n}\n", "/** @odoo-module */\n\nimport { Dialog } from \"@web/core/dialog/dialog\";\n\nimport { Component, useRef } from \"@odoo/owl\";\n\nexport class FieldSelectorDialog extends Component {\n    static props = {\n        close: { type: Function },\n        onConfirm: { type: Function },\n        fields: { type: Array },\n        showNew: { type: Boolean, optional: true },\n    };\n    static defaultProps = {\n        showNew: false,\n    };\n    setup() {\n        this.selectRef = useRef(\"select\");\n    }\n    onConfirm() {\n        const field = this.selectRef.el.value;\n        this.props.onConfirm(field);\n        this.props.close();\n    }\n    onCancel() {\n        this.props.close();\n    }\n}\nFieldSelectorDialog.template = \"web_studio.FieldSelectorDialog\";\nFieldSelectorDialog.components = { Dialog };\n", "/** @odoo-module */\nimport { Field } from \"@web/views/fields/field\";\nimport { FieldContentOverlay } from \"./field_content_overlay\";\n\nimport { useStudioRef, studioIsVisible } from \"@web_studio/client_action/view_editor/editors/utils\";\n\nimport { useState } from \"@odoo/owl\";\n\n/*\n * Field:\n * - Displays an Overlay for X2Many fields\n * - handles invisible\n */\nexport class FieldStudio extends Field {\n    setup() {\n        super.setup();\n        this.state = useState({\n            displayOverlay: false,\n        });\n        useStudioRef(\"rootRef\", this.onClick);\n    }\n    get fieldComponentProps() {\n        const fieldComponentProps = super.fieldComponentProps;\n        delete fieldComponentProps.studioXpath;\n        delete fieldComponentProps.hasEmptyPlaceholder;\n        delete fieldComponentProps.hasLabel;\n        delete fieldComponentProps.studioIsVisible;\n        return fieldComponentProps;\n    }\n    get classNames() {\n        const classNames = super.classNames;\n        classNames[\"o_web_studio_show_invisible\"] = !studioIsVisible(this.props);\n        classNames[\"o-web-studio-editor--element-clickable\"] = !!this.props.studioXpath;\n        if (this.studioIsEmpty()) {\n            delete classNames[\"o_field_empty\"];\n            classNames[\"o_web_studio_widget_empty\"] = true;\n        }\n        return classNames;\n    }\n\n    studioIsEmpty() {\n        const { name, record, hasLabel } = this.props;\n        if (hasLabel) {\n            return false;\n        }\n        return \"isEmpty\" in this.field ? this.field.isEmpty(record, name) : !record.data[name];\n    }\n\n    getEmptyPlaceholder() {\n        const { hasEmptyPlaceholder, name, record, fieldInfo } = this.props;\n        if (!hasEmptyPlaceholder) {\n            return false;\n        }\n        return this.studioIsEmpty() && (fieldInfo.string || record.fields[name].string);\n    }\n\n    isX2ManyEditable(props) {\n        const { name, record } = props;\n        const field = record.fields[name];\n        if (![\"one2many\", \"many2many\"].includes(field.type)) {\n            return false;\n        }\n        return !!this.props.fieldInfo.field.useSubView;\n    }\n\n    onEditViewType(viewType) {\n        const { name, record, studioXpath } = this.props;\n        this.env.viewEditorModel.editX2ManyView({\n            viewType,\n            fieldName: name,\n            record,\n            xpath: studioXpath,\n            fieldContext: this.fieldComponentProps.context,\n        });\n    }\n\n    onClick(ev) {\n        if (ev.target.classList.contains(\"o_web_studio_editX2Many\")) {\n            return;\n        }\n        ev.stopPropagation();\n        ev.preventDefault();\n        this.env.config.onNodeClicked(this.props.studioXpath);\n        this.state.displayOverlay = !this.state.displayOverlay;\n    }\n}\nFieldStudio.components = { ...Field.components, FieldContentOverlay };\nFieldStudio.template = \"web_studio.Field\";\n", "/** @odoo-module **/\nimport { Component, xml } from \"@odoo/owl\";\n\nconst formGrid = xml`\n    <div class=\"o_web_studio_hook\"\n        t-attf-class=\"g-col-sm-{{ props.colSpan }}\"\n        t-att-data-xpath=\"props.xpath\"\n        t-att-data-position=\"props.position\"\n        t-att-data-type=\"props.type\">\n            <span class=\"o_web_studio_hook_separator\" />\n    </div>\n`;\n\nconst kanbanRecord = xml`\n    <span class=\"o_web_studio_hook\"\n        t-att-data-xpath=\"props.xpath\"\n        t-att-data-position=\"props.position\"\n        t-att-data-type=\"props.type\" />\n`;\n\nconst defaultTemplate = xml`\n<div class=\"o_web_studio_hook\" t-att-data-xpath=\"props.xpath\" t-att-data-position=\"props.position\" t-att-data-type=\"props.type\" t-att-data-infos=\"props.infos\">\n    <span class=\"o_web_studio_hook_separator\" />\n</div>\n`;\n\nexport class StudioHook extends Component {\n    getTemplate(templateName) {\n        return this.constructor.subTemplates[templateName || \"defaultTemplate\"];\n    }\n}\nStudioHook.template = xml`<t t-call=\"{{ getTemplate(props.subTemplate) }}\" />`;\nStudioHook.props = [\"xpath?\", \"position?\", \"type?\", \"colSpan?\", \"subTemplate?\", \"width?\", \"infos?\"];\nStudioHook.subTemplates = {\n    formGrid,\n    defaultTemplate,\n    kanbanRecord,\n};\n", "/** @odoo-module */\nimport { ViewButton } from \"@web/views/view_button/view_button\";\nimport { useStudioRef, studioIsVisible } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { useBus } from \"@web/core/utils/hooks\";\n\n/*\n * ViewButton:\n * - Deals with invisible\n * - Click is overriden not to trigger the bound action\n */\nexport class ViewButtonStudio extends ViewButton {\n    setup() {\n        super.setup();\n        useStudioRef(\"rootRef\");\n\n        if (this.props.studioApproval) {\n            useBus(this.env.viewEditorModel.env.bus, \"approval-update\", () => {\n                this.approval.fetchApprovals();\n            });\n        }\n    }\n    getClassName() {\n        let className = super.getClassName();\n        if (!studioIsVisible(this.props)) {\n            className += \" o_web_studio_show_invisible\";\n        }\n        if (this.props.studioXpath) {\n            className += \" o-web-studio-editor--element-clickable\";\n        }\n        return className;\n    }\n\n    onClick(ev) {\n        if (this.props.tag === \"a\") {\n            ev.preventDefault();\n        }\n        if (!this.props.studioXpath) {\n            return;\n        }\n        this.env.config.onNodeClicked(this.props.studioXpath);\n    }\n}\nViewButtonStudio.template = \"web_studio.ViewButton\";\nViewButtonStudio.props = [...ViewButton.props, \"studioIsVisible?\", \"studioXpath?\"];\n", "/** @odoo-module */\nimport { Widget } from \"@web/views/widgets/widget\";\n\nexport class WidgetStudio extends Widget {\n    get widgetProps() {\n        const widgetProps = super.widgetProps;\n        delete widgetProps.studioXpath;\n        delete widgetProps.hasEmptyPlaceholder;\n        delete widgetProps.hasLabel;\n        delete widgetProps.studioIsVisible;\n        return widgetProps;\n    }\n}\n", "/** @odoo-module */\n\nimport { Chatter } from \"@mail/core/web/chatter\";\n\nimport { Component } from \"@odoo/owl\";\n\nexport class ChatterContainer extends Chatter {\n    onClick(ev) {\n        this.env.config.onNodeClicked(this.props.studioXpath);\n    }\n}\nChatterContainer.template = \"web_studio.ChatterContainer\";\nChatterContainer.props = [...Chatter.props, \"studioXpath?\"];\n\nexport class ChatterContainerHook extends Component {\n    onClick() {\n        this.env.viewEditorModel.doOperation({\n            type: \"chatter\",\n            model: this.env.viewEditorModel.resModel,\n            ...this.props.chatterData,\n        });\n    }\n}\nChatterContainerHook.template = \"web_studio.ChatterContainerHook\";\nChatterContainerHook.components = { Chatter };\nChatterContainerHook.props = {\n    chatterData: Object,\n    threadModel: String,\n};\n", "/** @odoo-module */\n\nimport { formView } from \"@web/views/form/form_view\";\nimport { FormEditorRenderer } from \"./form_editor_renderer/form_editor_renderer\";\nimport { FormEditorController } from \"./form_editor_controller/form_editor_controller\";\nimport { FormEditorCompiler } from \"./form_editor_compiler\";\nimport { registry } from \"@web/core/registry\";\nimport { omit } from \"@web/core/utils/objects\";\nimport { makeModelErrorResilient } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { getModifier } from \"@web/views/view_compiler\";\nimport { FormEditorSidebar } from \"./form_editor_sidebar/form_editor_sidebar\";\nimport { getStudioNoFetchFields } from \"../utils\";\n\nclass EditorArchParser extends formView.ArchParser {\n    parse() {\n        const archInfo = super.parse(...arguments);\n        this.omitStudioNoFetchFields(archInfo);\n        return archInfo;\n    }\n\n    omitStudioNoFetchFields(archInfo) {\n        const noFetch = getStudioNoFetchFields(archInfo.fieldNodes);\n        archInfo.fieldNodes = omit(archInfo.fieldNodes, ...noFetch.fieldNodes);\n\n        for (const fieldNode of Object.values(archInfo.fieldNodes)) {\n            if (fieldNode.views) {\n                for (const fieldArchInfo of Object.values(fieldNode.views)) {\n                    this.omitStudioNoFetchFields(fieldArchInfo);\n                }\n            }\n        }\n\n    }\n}\n\nclass Model extends formView.Model {}\nModel.Record = class RecordNoEdit extends formView.Model.Record {\n    get isInEdition() {\n        return false;\n    }\n};\n\nconst formEditor = {\n    ...formView,\n    ArchParser: EditorArchParser,\n    Compiler: FormEditorCompiler,\n    Renderer: FormEditorRenderer,\n    Controller: FormEditorController,\n    props(genericProps, editor, config) {\n        const arch = genericProps.arch;\n        Array.from(arch.querySelectorAll(\"field > tree, field > form, field > kanban\")).forEach(\n            (el) => {\n                // Inline subviews sometimes have a \"groups\" attribute, allowing to have different\n                // x2many views depending on access rights. Outside Studio, this has no impact\n                // client side, because the view processing in python would remove nodes with groups\n                // the user doesn't belong to. However, when there's a \"studio\" key in the context,\n                // nodes are no longer removed but they are set as invisible=\"1\" instead. This means\n                // that in Studio, we can have several x2many subviews for the same view type (even\n                // tough, only one of them should be visible). Here, we're only interested in the\n                // views that are visible (the ones the user has access to), so we remove the others.\n                if (getModifier(el, \"invisible\")) {\n                    el.remove();\n                }\n            }\n        );\n        const props = formView.props(genericProps, editor, config);\n        props.Model = makeModelErrorResilient(Model);\n        props.preventEdit = true;\n        return props;\n    },\n    Sidebar: FormEditorSidebar,\n};\nregistry.category(\"studio_editors\").add(\"form\", formEditor);\n\n/**\n *  Drag/Drop Validation\n */\nconst HOOK_CLASS_WHITELIST = [\n    \"o_web_studio_field_signature\",\n    \"o_web_studio_field_html\",\n    \"o_web_studio_field_many2many\",\n    \"o_web_studio_field_one2many\",\n    \"o_web_studio_field_tabs\",\n    \"o_web_studio_field_columns\",\n    \"o_web_studio_field_lines\",\n];\nconst HOOK_TYPE_BLACKLIST = [\"genericTag\", \"afterGroup\", \"afterNotebook\", \"insideSheet\"];\n\nconst isBlackListedHook = (draggedEl, hookEl) =>\n    !HOOK_CLASS_WHITELIST.some((cls) => draggedEl.classList.contains(cls)) &&\n    HOOK_TYPE_BLACKLIST.some((t) => hookEl.dataset.type === t);\n\nfunction canDropNotebook(hookEl) {\n    if (hookEl.dataset.type === \"page\") {\n        return false;\n    }\n    if (hookEl.closest(\".o_group\") || hookEl.closest(\".o_inner_group\")) {\n        return false;\n    }\n    return true;\n}\n\nfunction canDropGroup(hookEl) {\n    if (hookEl.dataset.type === \"insideGroup\") {\n        return false;\n    }\n    if (hookEl.closest(\".o_group\") || hookEl.closest(\".o_inner_group\")) {\n        return false;\n    }\n    return true;\n}\n\nfunction isValidFormHook({ hook, element }) {\n    const draggingStructure = element.dataset.structure;\n    switch (draggingStructure) {\n        case \"notebook\": {\n            if (!canDropNotebook(hook)) {\n                return false;\n            }\n            break;\n        }\n        case \"group\": {\n            if (!canDropGroup(hook)) {\n                return false;\n            }\n            break;\n        }\n    }\n    if (isBlackListedHook(element, hook)) {\n        return false;\n    }\n\n    return true;\n}\nformEditor.isValidHook = isValidFormHook;\n", "/** @odoo-module */\n\nimport { isComponentNode } from \"@web/views/view_compiler\";\nimport {\n    computeXpath,\n    applyInvisible,\n} from \"@web_studio/client_action/view_editor/editors/xml_utils\";\nimport { createElement } from \"@web/core/utils/xml\";\nimport { formView } from \"@web/views/form/form_view\";\nimport { objectToString } from \"@web/views/form/form_compiler\";\n\nconst interestingSelector = [\n    \":not(field) sheet\", // A hook should be present to add elements in the sheet\n    \":not(field) field\", // should be clickable and draggable\n    \":not(field) notebook\", // should be able to add pages\n    \":not(field) page\", // should be clickable\n    \":not(field) button\", // should be clickable\n    \":not(field) label\", // should be clickable\n    \":not(field) group\", // any group: outer or inner\n    \":not(field) div.oe_chatter\",\n    \":not(field) .oe_avatar\",\n].join(\", \");\n\nexport class FormEditorCompiler extends formView.Compiler {\n    compile(key, params = {}) {\n        const xml = this.templates[key];\n\n        // One pass to compute and add the xpath for the arch's node location\n        // onto that node.\n        for (const el of xml.querySelectorAll(interestingSelector)) {\n            const xpath = computeXpath(el);\n            el.setAttribute(\"studioXpath\", xpath);\n        }\n\n        // content of inner groups serves as main dropzone\n        // TODO in master: add `:not(field) group:not(:has(> group)) > *` to interestingSelector\n        for (const el of xml.querySelectorAll(\"group\")) {\n            const children = [...el.children];\n            if (children.some((node) => node.tagName === \"group\")) {\n                continue;\n            }\n            children.forEach((node) => node.setAttribute(\"studioXpath\", computeXpath(node)));\n        }\n\n        // done after construction of xpaths\n        this.addChatter = true;\n        this.chatterData = {\n            remove_message_ids: false,\n            remove_follower_ids: false,\n            remove_activity_ids: false,\n        };\n        this.avatars = [];\n\n        const compiled = super.compile(key, params);\n\n        const sheetBg = compiled.querySelector(\".o_form_sheet_bg\");\n        if (sheetBg) {\n            const studioHook = createElement(\"StudioHook\", {\n                xpath: `\"${sheetBg.getAttribute(\"studioXpath\")}\"`,\n                position: \"'inside'\",\n                type: \"'insideSheet'\",\n            });\n            sheetBg.querySelector(\".o_form_sheet\").prepend(studioHook);\n        }\n\n        if (this.addChatter) {\n            const chatterContainerHook = createElement(\"ChatterContainerHook\", {\n                threadModel: `__comp__.props.record.resModel`,\n                chatterData: objectToString(this.chatterData),\n            });\n            const el = compiled.querySelector(\".o_form_sheet\") || compiled;\n            el.after(chatterContainerHook);\n        } else {\n            const parent = compiled.querySelector(\".o-mail-Form-chatter\");\n            parent.removeAttribute(\"t-attf-class\"); // avoid class o-aside\n            parent.removeAttribute(\"t-if\");\n        }\n\n        const checkStatusBarButtons = compiled.querySelector(\"StatusBarButtons\");\n        if(!checkStatusBarButtons) {\n            const addButtonAction = createElement(\"AddButtonAction\");     \n            const el = compiled.querySelector(\".o_form_sheet_bg\") || compiled;\n            el.prepend(addButtonAction);\n        }\n\n        const fieldStatus = compiled.querySelector(`Field[type=\"'statusbar'\"]`); // change selector at some point\n        if (!fieldStatus) {\n            const addStatusBar = !compiled.querySelector(\".o_form_statusbar\");\n            const statusBarFieldHook = createElement(\"StatusBarFieldHook\", { addStatusBar });\n            const el = compiled.querySelector(\".o_form_sheet_bg\") || compiled;\n            el.prepend(statusBarFieldHook);\n        }\n\n        // the button box is included in the control panel, which is not visible in Studio\n        // re-add it to the form view\n        const buttonBoxXml = xml.querySelector(\"div[name='button_box']:not(field div)\");\n        let buttonBox;\n        const buttonBoxContainer = createElement(\"div\", {\n            class: \"d-flex justify-content-end my-2\",\n        });\n        if (buttonBoxXml) {\n            buttonBox = this.compileNode(buttonBoxXml, params);\n        } else {\n            buttonBox = createElement(\"ButtonBox\");\n        }\n        buttonBoxContainer.append(buttonBox);\n        const el = compiled.querySelector(\".o_form_sheet_bg\") || compiled;\n        el.prepend(buttonBoxContainer);\n\n        const buttonHook = createElement(\n            \"t\",\n            [createElement(\"ButtonHook\", { add_buttonbox: !buttonBoxXml })],\n            { \"t-set-slot\": `slot_button_hook` }\n        );\n\n        buttonBox.insertAdjacentElement(\"afterbegin\", buttonHook);\n\n        // Note: the ribon does not allow to remove an existing avatar!\n        const title = compiled.querySelector(\".oe_title\");\n        if (title) {\n            if (\n                !title.querySelector(\":scope > h1 > [isAvatar]\") && // check it works with <field class=\"oe_avatar\" ... />\n                !title.parentElement.querySelector(\":scope > [isAvatar]\")\n            ) {\n                const avatarHook = createElement(\"AvatarHook\", {\n                    fields: `__comp__.props.record.fields`,\n                });\n                avatarHook.setAttribute(\n                    \"class\",\n                    `'oe_avatar d-flex align-items-center justify-content-center ms-3 o_web_studio_avatar h4'`\n                );\n                title.before(avatarHook);\n            }\n        }\n        for (const el of this.avatars) {\n            el.removeAttribute(\"isAvatar\");\n        }\n\n        compiled.querySelectorAll(\":not(.o_form_statusbar) Field\").forEach((el) => {\n            el.setAttribute(\"hasEmptyPlaceholder\", \"true\");\n        });\n\n        compiled\n            .querySelectorAll(`InnerGroup > t[t-set-slot][subType=\"'item_component'\"] Field`)\n            .forEach((el) => {\n                el.setAttribute(\"hasLabel\", \"true\");\n            });\n\n        return compiled;\n    }\n\n    applyInvisible(invisible, compiled, params) {\n        return applyInvisible(invisible, compiled, params);\n    }\n\n    createLabelFromField(fieldId, fieldName, fieldString, label, params) {\n        const studioXpath = label.getAttribute(\"studioXpath\");\n        const formLabel = super.createLabelFromField(...arguments);\n        formLabel.setAttribute(\"studioXpath\", `\"${studioXpath}\"`);\n        if (formLabel.hasAttribute(\"t-if\")) {\n            formLabel.setAttribute(\"studioIsVisible\", formLabel.getAttribute(\"t-if\"));\n            formLabel.removeAttribute(\"t-if\");\n        }\n        return formLabel;\n    }\n\n    compileNode(node, params = {}, evalInvisible = true) {\n        const nodeType = node.nodeType;\n        // Put a xpath on the currentSlot containing the future compiled element.\n        // Do it early not to be bothered by recursive call to compileNode.\n        const currentSlot = params.currentSlot;\n        if (nodeType === 1 && currentSlot && !currentSlot.hasAttribute(\"studioXpath\")) {\n            const parentElement = node.parentElement;\n            if (parentElement && parentElement.tagName === \"page\") {\n                const xpath = computeXpath(node.parentElement);\n                currentSlot.setAttribute(\"studioXpath\", `\"${xpath}\"`);\n                // If the page has an OuterGroup as last child, don't add a page studioHook\n                if (!parentElement.querySelector(\":scope > group:last-child > group\")) {\n                    const pageHookProps = {\n                        position: \"'inside'\",\n                        type: \"'page'\",\n                        xpath: `\"${xpath}\"`,\n                    };\n                    currentSlot.setAttribute(\"studioHookProps\", objectToString(pageHookProps));\n                }\n            } else {\n                const xpath = node.getAttribute(\"studioXpath\");\n                currentSlot.setAttribute(\"studioXpath\", `\"${xpath}\"`);\n            }\n        }\n\n        if (nodeType === 1 && node.getAttribute(\"studio_no_fetch\")) {\n            return;\n        }\n\n        const compiled = super.compileNode(node, { ...params, compileInvisibleNodes: true }, true); // always evalInvisible\n\n        if (nodeType === 1) {\n            // Put a xpath on anything of interest.\n            if (node.hasAttribute(\"studioXpath\")) {\n                const xpath = node.getAttribute(\"studioXpath\");\n                if (isComponentNode(compiled)) {\n                    compiled.setAttribute(\"studioXpath\", `\"${xpath}\"`);\n                } else if (!compiled.hasAttribute(\"studioXpath\")) {\n                    compiled.setAttribute(\"studioXpath\", xpath);\n                }\n            }\n\n            if (node.tagName === \"notebook\") {\n                // Since empty pages are not compiled, this compiler has not applied the studioXpath attribute.\n                // We must need to add one as well as the other pages, to make sure we can edit its content properly.\n                const originalChildren = Array.from(node.children).filter(\n                    (e) => e.tagName === \"page\"\n                );\n                Array.from(compiled.children).forEach((elem, index) => {\n                    if (!elem.hasAttribute(\"studioXpath\")) {\n                        const studioXpath = originalChildren[index].getAttribute(\"studioXpath\");\n                        elem.setAttribute(\"studioXpath\", `\"${studioXpath}\"`);\n                        const pageHookProps = {\n                            position: \"'inside'\",\n                            type: \"'page'\",\n                            xpath: `\"${studioXpath}\"`,\n                        };\n                        elem.setAttribute(\"studioHookProps\", objectToString(pageHookProps));\n                    }\n                });\n            }\n\n            if (node.classList.contains(\"oe_chatter\")) {\n                this.addChatter = false;\n                const chatterNode = compiled.querySelector(\n                    \"t[t-component='__comp__.mailComponents.Chatter']\"\n                );\n                const xpath = node.getAttribute(\"studioXpath\");\n                chatterNode.setAttribute(\"studioXpath\", `\"${xpath}\"`);\n                compiled.setAttribute(\"data-studio-xpath\", xpath);\n                compiled.classList.add(\"o-web-studio-editor--element-clickable\");\n            }\n            if (node.classList.contains(\"oe_avatar\")) {\n                compiled.setAttribute(\"isAvatar\", true);\n                this.avatars.push(compiled);\n            }\n\n            if (node.classList.contains(\"o_td_label\") && !node.children.length && !node.textContent.trim()) {\n                compiled.classList.add(\"o-web-studio-editor--element-clickable\");\n                const xpath = node.getAttribute(\"studioXpath\");\n                compiled.setAttribute(\n                    \"t-on-click\",\n                    `(ev) => __comp__.env.config.onNodeClicked(\"${xpath}\")`\n                );\n            }\n\n            const name = node.getAttribute(\"name\"); // not sure that part works\n            if (name === \"message_ids\") {\n                this.chatterData.remove_message_ids = true;\n            } else if (name === \"message_follower_ids\") {\n                this.chatterData.remove_follower_ids = true;\n            } else if (name === \"activity_ids\") {\n                this.chatterData.remove_activity_ids = true;\n            }\n        }\n        return compiled;\n    }\n}\n", "/** @odoo-module */\n\nimport { useState, onMounted, onPatched } from \"@odoo/owl\";\nimport { formView } from \"@web/views/form/form_view\";\nimport { useModelConfigFetchInvisible } from \"@web_studio/client_action/view_editor/editors/utils\";\n\n/**\n * This hook ensures that a record datapoint has the \"parent\" key in its evalContext, allowing\n * to access to field values of the parent record. This is useful in Studio because an x2many\n * record can be opened, but in a standalone fashion. It will be the root of its model, even\n * though, in practice, there's a parent record and a parent form view. This allows snippets like\n * `<field name=\"...\" invisible=\"not parent.id\" />` in the child view to work.\n */\nfunction useExternalParentInModel(model, parentRecord) {\n    model._createRoot = (config, data) => {\n        return new model.constructor.Record(model, config, data, { parentRecord });\n    };\n}\n\nexport class FormEditorController extends formView.Controller {\n    setup() {\n        super.setup();\n        useModelConfigFetchInvisible(this.model);\n        this.mailTemplate = null;\n        this.hasFileViewerInArch = false;\n\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n\n        if (this.props.parentRecord) {\n            useExternalParentInModel(this.model, this.props.parentRecord);\n        }\n\n        onMounted(() => {\n            const xpath = this.viewEditorModel.lastActiveNodeXpath;\n            if (xpath && xpath.includes(\"notebook\")) {\n                const tabXpath = xpath.match(/.*\\/page\\[\\d+\\]/)[0];\n                const tab = document.querySelector(`[data-studio-xpath='${tabXpath}'] a`);\n                if (tab) {\n                    // store the targetted element to restore it after being patched\n                    this.notebookElementData = {\n                        xpath,\n                        restore: Boolean(this.viewEditorModel.activeNodeXpath),\n                        sidebarTab: this.viewEditorModel.sidebarTab,\n                        isTab: xpath.length === tabXpath.length,\n                    };\n                    tab.click();\n                }\n            } else {\n                this.notebookElementData = null;\n            }\n        });\n\n        onPatched(() => {\n            if (this.notebookElementData) {\n                if (\n                    this.notebookElementData.isTab &&\n                    this.viewEditorModel.lastActiveNodeXpath !== this.notebookElementData.xpath\n                ) {\n                    return;\n                }\n                if (this.notebookElementData.restore) {\n                    this.env.config.onNodeClicked(this.notebookElementData.xpath);\n                } else {\n                    // no element was currently highlighted, the editor sidebar must display the stored tab\n                    this.viewEditorModel.resetSidebar(this.notebookElementData.sidebarTab);\n                }\n                this.notebookElementData = null;\n            }\n        });\n    }\n\n    beforeUnload() {}\n}\nFormEditorController.props = {\n    ...formView.Controller.props,\n    parentRecord: { type: [Object, { value: null }], optional: true },\n};\n", "/** @odoo-module */\n\nimport { formView } from \"@web/views/form/form_view\";\nimport { studioIsVisible } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { StudioHook } from \"@web_studio/client_action/view_editor/editors/components/studio_hook_component\";\n\nimport { Component, useEffect, useRef, useState } from \"@odoo/owl\";\n\nconst components = formView.Renderer.components;\n\n/*\n * Overrides for FormGroups: Probably the trickiest part of all, especially InnerGroup\n * - Append droppable hooks below every visible field, or on empty OuterGroup\n * - Elements deal with invisible themselves\n */\n\n// An utility function that extends the common API parts of groups\nfunction extendGroup(GroupClass) {\n    class Group extends GroupClass {\n        setup() {\n            super.setup();\n            this.viewEditorModel = useState(this.env.viewEditorModel);\n            this.rootRef = useRef(\"rootRef\");\n        }\n        get allClasses() {\n            let classes = super.allClasses;\n            if (!studioIsVisible(this.props)) {\n                classes = `${classes || \"\"} o_web_studio_show_invisible`;\n            }\n            if (this.props.studioXpath) {\n                classes = `${classes || \"\"} o-web-studio-editor--element-clickable`;\n            }\n            return classes;\n        }\n        _getItems() {\n            const items = super._getItems();\n            return items.map(([k, v]) => {\n                v = Object.assign({}, v);\n                v.studioIsVisible = v.isVisible;\n                v.isVisible = v.isVisible || this.viewEditorModel.showInvisible;\n                if (v.subType === \"item_component\") {\n                    v.props.studioIsVisible = v.studioIsVisible;\n                    v.props.studioXpath = v.studioXpath;\n                }\n                return [k, v];\n            });\n        }\n\n        onGroupClicked(ev) {\n            if (ev.target.closest(\".o-web-studio-editor--element-clickable\") !== this.rootRef.el) {\n                return;\n            }\n            this.env.config.onNodeClicked(this.props.studioXpath);\n        }\n    }\n    Group.props = [...GroupClass.props, \"studioXpath?\", \"studioIsVisible?\"];\n    Group.components = { ...GroupClass.components, StudioHook };\n    return Group;\n}\n\n// A component to display fields with an automatic label.\n// Those are the only ones (for now), to be draggable internally\n// It should shadow the Field and its Label below\nclass InnerGroupItemComponent extends Component {\n    static props = {\n        cell: { type: Object },\n        slots: { type: Object },\n    };\n    setup() {\n        const labelRef = useRef(\"labelRef\");\n        const fieldRef = useRef(\"fieldRef\");\n\n        this.labelRef = labelRef;\n\n        useEffect(\n            (studioIsVisible, labelEl, fieldEl) => {\n                // Only label act as the business unit for studio\n                if (labelEl) {\n                    const clickable = labelEl.querySelector(\n                        \".o-web-studio-editor--element-clickable\"\n                    );\n                    if (clickable) {\n                        clickable.classList.remove(\"o-web-studio-editor--element-clickable\");\n                    }\n                    labelEl.classList.add(\"o-web-studio-editor--element-clickable\");\n                    const invisible = labelEl.querySelector(\".o_web_studio_show_invisible\");\n                    if (invisible) {\n                        invisible.classList.remove(\"o_web_studio_show_invisible\");\n                    }\n                    labelEl.classList.toggle(\"o_web_studio_show_invisible\", !studioIsVisible);\n                    labelEl.classList.add(\"o-draggable\");\n                }\n\n                if (fieldEl) {\n                    const clickable = fieldEl.querySelector(\n                        \".o-web-studio-editor--element-clickable\"\n                    );\n                    if (clickable) {\n                        clickable.classList.remove(\"o-web-studio-editor--element-clickable\");\n                    }\n                    const invisible = fieldEl.querySelector(\".o_web_studio_show_invisible\");\n                    if (invisible) {\n                        invisible.classList.remove(\"o_web_studio_show_invisible\");\n                    }\n                    fieldEl.classList.add(\"o-web-studio-element-ghost\");\n                }\n            },\n            () => [this.cell.studioIsVisible, labelRef.el, fieldRef.el]\n        );\n\n        this.onMouseFieldIO = (ev) => {\n            labelRef.el.classList.toggle(\"o-web-studio-ghost-hovered\", ev.type === \"mouseover\");\n        };\n    }\n    get cell() {\n        return this.props.cell;\n    }\n\n    onClicked(ev) {\n        if (ev.target.closest(\".o-web-studio-element-ghost\")) {\n            ev.stopPropagation();\n        }\n        this.env.config.onNodeClicked(this.cell.studioXpath);\n    }\n}\nInnerGroupItemComponent.template = \"web_studio.Form.InnerGroup.ItemComponent\";\n\nconst _InnerGroup = extendGroup(components.InnerGroup);\nexport class InnerGroup extends _InnerGroup {\n    getRows() {\n        const rows = super.getRows();\n        if (!this.viewEditorModel.showInvisible) {\n            rows.forEach((row) => {\n                row.isVisible = row.some((cell) => cell.studioIsVisible);\n            });\n        }\n        return rows;\n    }\n\n    getStudioHooks() {\n        const hooks = new Map();\n        const rows = this.getRows();\n        const hasRows = rows.length >= 1 && rows[0].length;\n\n        if (!hasRows) {\n            hooks.set(\"inside\", {\n                xpath: this.props.studioXpath,\n                position: \"inside\",\n                subTemplate: \"formGrid\",\n                colSpan: this.props.maxCols,\n            });\n        }\n\n        for (const rowIdx in rows) {\n            const row = rows[rowIdx];\n            const colSpan = row.reduce((acc, val) => acc + val.itemSpan || 1, 0);\n            if (!hooks.has(\"beforeFirst\")) {\n                const cell = row[0];\n                if (cell) {\n                    hooks.set(\"beforeFirst\", {\n                        xpath: cell.studioXpath,\n                        position: \"before\",\n                        subTemplate: \"formGrid\",\n                        width: cell.width,\n                        colSpan,\n                    });\n                }\n            }\n\n            if (row.every((cell) => !cell.studioIsVisible) && !this.viewEditorModel.showInvisible) {\n                continue;\n            }\n            const cell = row[row.length - 1];\n            if (cell) {\n                hooks.set(`afterRow ${rowIdx}`, {\n                    xpath: cell.studioXpath,\n                    position: \"after\",\n                    subTemplate: \"formGrid\",\n                    width: cell.width,\n                    colSpan,\n                });\n            }\n        }\n        return hooks;\n    }\n}\n\nInnerGroup.components.InnerGroupItemComponent = InnerGroupItemComponent;\nInnerGroup.template = \"web_studio.Form.InnerGroup\";\n\n// Simple override for OuterGroups\nexport const OuterGroup = extendGroup(components.OuterGroup);\nOuterGroup.template = \"web_studio.Form.OuterGroup\";\n", "/** @odoo-module */\n\nimport { useRef, useEffect, useState } from \"@odoo/owl\";\nimport { formView } from \"@web/views/form/form_view\";\nimport * as formEditorRendererComponents from \"@web_studio/client_action/view_editor/editors/form/form_editor_renderer/form_editor_renderer_components\";\n\nimport { ChatterContainer, ChatterContainerHook } from \"../chatter_container\";\nimport { StudioHook } from \"@web_studio/client_action/view_editor/editors/components/studio_hook_component\";\nimport { FieldStudio } from \"@web_studio/client_action/view_editor/editors/components/field_studio\";\nimport { WidgetStudio } from \"@web_studio/client_action/view_editor/editors/components/widget_studio\";\nimport { ViewButtonStudio } from \"@web_studio/client_action/view_editor/editors/components/view_button_studio\";\nimport { InnerGroup, OuterGroup } from \"./form_editor_groups\";\nimport { AddButtonAction } from \"@web_studio/client_action/view_editor/interactive_editor/action_button/action_button\";\n\nconst components = formView.Renderer.components;\n\nexport class FormEditorRenderer extends formView.Renderer {\n    setup() {\n        super.setup();\n        const rootRef = useRef(\"compiled_view_root\");\n        this.rootRef = rootRef;\n        const viewEditorModel = this.env.viewEditorModel;\n        this.viewEditorModel = useState(viewEditorModel);\n        this.mailComponents.Chatter = ChatterContainer;\n\n        // Deals with invisible modifier by reacting to config.studioShowVisible.\n        useEffect(\n            (rootEl, showInvisible) => {\n                if (!rootEl) {\n                    return;\n                }\n                rootEl.classList.add(\"o_web_studio_form_view_editor\");\n                if (showInvisible) {\n                    rootEl\n                        .querySelectorAll(\":not(.o-mail-Form-chatter) .o_invisible_modifier\")\n                        .forEach((el) => {\n                            el.classList.add(\"o_web_studio_show_invisible\");\n                            el.classList.remove(\"o_invisible_modifier\");\n                        });\n                } else {\n                    rootEl\n                        .querySelectorAll(\":not(.o-mail-Form-chatter) .o_web_studio_show_invisible\")\n                        .forEach((el) => {\n                            el.classList.remove(\"o_web_studio_show_invisible\");\n                            el.classList.add(\"o_invisible_modifier\");\n                        });\n                }\n            },\n            () => [rootRef.el, viewEditorModel.showInvisible]\n        );\n\n        // do this in another way?\n        useEffect(\n            (rootEl) => {\n                if (rootEl) {\n                    const optCols = rootEl.querySelectorAll(\"i.o_optional_columns_dropdown_toggle\");\n                    for (const col of optCols) {\n                        col.classList.add(\"text-muted\");\n                    }\n                }\n            },\n            () => [rootRef.el]\n        );\n    }\n}\n\nclass Setting extends formView.Renderer.components.Setting {\n    static props = {\n        ...formView.Renderer.components.Setting.props,\n        studioXpath: { type: String, optional: true },\n        studioIsVisible: { type: Boolean, optional: true },\n    };\n}\n\nFormEditorRenderer.components = {\n    ...components,\n    ...formEditorRendererComponents,\n    Field: FieldStudio,\n    Widget: WidgetStudio,\n    ViewButton: ViewButtonStudio,\n    ChatterContainerHook,\n    InnerGroup,\n    OuterGroup,\n    StudioHook,\n    Setting,\n    AddButtonAction,\n};\n", "/** @odoo-module */\n\nimport { formView } from \"@web/views/form/form_view\";\nimport { StudioHook } from \"@web_studio/client_action/view_editor/editors/components/studio_hook_component\";\nimport { NewButtonBoxDialog } from \"@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/new_button_box_dialog\";\nimport { FieldSelectorDialog } from \"@web_studio/client_action/view_editor/editors/components/field_selector_dialog\";\nimport { SelectionContentDialog } from \"@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog\";\nimport {\n    randomName,\n    studioIsVisible,\n    useStudioRef,\n} from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useOwnedDialogs } from \"@web/core/utils/hooks\";\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { AddButtonAction } from \"../../../interactive_editor/action_button/action_button\";\n\n/**\n * Overrides and extensions of components used by the FormRenderer\n * As a rule of thumb, elements should be able to handle the props\n * - studioXpath: the xpath to the node in the form's arch to which the component\n *   refers\n * - They generally be clicked on to change their characteristics (in the Sidebar)\n * - The click doesn't trigger default behavior (the view is inert)\n * - They can be draggable (FormLabel referring to a field)\n * - studioIsVisible: all components whether invisible or not, are compiled and rendered\n *   this props allows to toggle the class o_invisible_modifier\n * - They can have studio hooks, that are placeholders for dropping content (new elements, field, or displace elements)\n */\n\nconst components = formView.Renderer.components;\n\n/*\n * FormLabel:\n * - Can be draggable if in InnerGroup\n */\nexport class FormLabel extends components.FormLabel {\n    static template = \"web_studio.FormLabel\";\n    static props = {\n        ...components.FormLabel.props,\n        studioXpath: String,\n        studioIsVisible: { type: Boolean, optional: true },\n    };\n    setup() {\n        super.setup();\n        useStudioRef(\"rootRef\", this.onClick);\n    }\n    get className() {\n        let className = super.className;\n        if (!studioIsVisible(this.props)) {\n            className += \" o_web_studio_show_invisible\";\n        }\n        className += \" o-web-studio-editor--element-clickable\";\n        return className;\n    }\n    onClick(ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n        this.env.config.onNodeClicked(this.props.studioXpath);\n    }\n}\n\n/*\n * Notebook:\n * - Display every page, the elements in the page handle whether they are invisible themselves\n * - Push a droppable hook on every empty page\n * - Can add a new page\n */\nexport class Notebook extends components.Notebook {\n    static template = \"web_studio.Notebook.Hook\";\n    static components = { ...components.Notebook.components, StudioHook };\n    static props = {\n        ...components.Notebook.props,\n        studioIsVisible: { type: Boolean, optional: true },\n        studioXpath: String,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        super.setup();\n    }\n    computePages(props) {\n        const pages = super.computePages(props);\n        pages.forEach((p) => {\n            p[1].studioIsVisible = p[1].isVisible;\n            p[1].isVisible = p[1].isVisible || this.viewEditorModel.showInvisible;\n        });\n        return pages;\n    }\n    onNewPageClicked() {\n        const vem = this.viewEditorModel;\n        const node = {\n            tag: \"page\",\n            attrs: {\n                string: _t(\"New Page\"),\n                name: randomName(\"studio_page\"),\n            },\n        };\n        vem.doOperation({\n            type: \"add\",\n            node,\n            target: vem.getFullTarget(this.props.studioXpath),\n            position: \"inside\",\n        });\n    }\n}\n\nexport class StatusBarButtons extends components.StatusBarButtons {\n    static template = `web_studio.FormViewAddButtonAction`;\n    static components = {\n        ...components.StatusBarButtons.components,\n        AddButtonAction,\n    };\n}\n\nexport class StatusBarFieldHook extends Component {\n    static template = \"web_studio.StatusBarFieldHook\";\n    static props = {\n        addStatusBar: { type: Boolean },\n    };\n    setup() {\n        this.addDialog = useOwnedDialogs();\n    }\n    onClick() {\n        this.addDialog(SelectionContentDialog, {\n            defaultChoices: [\n                [\"status1\", _t(\"First Status\")],\n                [\"status2\", _t(\"Second Status\")],\n                [\"status3\", _t(\"Third Status\")],\n            ],\n            onConfirm: (choices) => {\n                const viewEditorModel = this.env.viewEditorModel;\n                if (this.props.addStatusBar) {\n                    viewEditorModel.pushOperation({ type: \"statusbar\" });\n                }\n\n                const target = {\n                    tag: \"header\",\n                };\n                const subViewXpath = viewEditorModel.getSubviewXpath();\n                if (subViewXpath) {\n                    target.subview_xpath = subViewXpath;\n                }\n\n                viewEditorModel.doOperation({\n                    type: \"add\",\n                    target,\n                    position: \"inside\",\n                    node: {\n                        attrs: {\n                            widget: \"statusbar\",\n                            options: \"{'clickable': '1'}\",\n                        },\n                        field_description: {\n                            default_value: true,\n                            field_description: _t(\"Pipeline status bar\"),\n                            model_name: viewEditorModel.resModel,\n                            name: randomName(`x_studio_selection_field`),\n                            selection: JSON.stringify(choices),\n                            type: \"selection\",\n                        },\n                        tag: \"field\",\n                    },\n                });\n            },\n        });\n    }\n}\n\nexport class AvatarHook extends Component {\n    static template = \"web_studio.AvatarHook\";\n    static props = { fields: Object, class: { type: String, optional: true } };\n    setup() {\n        this.addDialog = useOwnedDialogs();\n    }\n    onClick() {\n        const fields = [];\n        for (const field of Object.values(this.props.fields)) {\n            if (field.type === \"binary\") {\n                fields.push(field);\n            }\n        }\n        this.addDialog(FieldSelectorDialog, {\n            fields,\n            showNew: true,\n            onConfirm: (field) => {\n                this.env.viewEditorModel.doOperation({\n                    type: \"avatar_image\",\n                    field,\n                });\n            },\n        });\n    }\n}\n\nexport class ButtonHook extends Component {\n    static template = \"web_studio.ButtonHook\";\n    static props = {\n        add_buttonbox: { type: Boolean, optional: true },\n        studioIsVisible: { type: Boolean, optional: true },\n    };\n    setup() {\n        this.addDialog = useOwnedDialogs();\n    }\n    onClick() {\n        this.addDialog(NewButtonBoxDialog, {\n            model: this.env.viewEditorModel,\n            isAddingButtonBox: Boolean(this.props.add_buttonbox),\n        });\n    }\n}\n\nexport class ButtonBox extends components.ButtonBox {\n    static props = {\n        ...components.ButtonBox.props,\n        studioIsVisible: { type: Boolean, optional: true },\n    };\n\n    setup() {\n        super.setup();\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n    }\n\n    isSlotVisible(slot) {\n        return this.viewEditorModel.showInvisible || super.isSlotVisible(slot);\n    }\n}\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport {\n    ExistingFields,\n    NewFields,\n} from \"@web_studio/client_action/view_editor/view_structures/view_structures\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { Properties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/properties\";\nimport { ButtonProperties } from \"@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/button_properties/button_properties\";\nimport { FieldProperties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties\";\nimport { GroupProperties } from \"@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/group_properties/group_properties\";\nimport { LabelProperties } from \"@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/label_properties/label_properties\";\nimport { PageProperties } from \"@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/page_properties/page_properties\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { ChatterProperties } from \"@web_studio/client_action/view_editor/editors/form/form_editor_sidebar/properties/chatter_properties/chatter_properties\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\nimport { OTdLabelProperties } from \"./properties/o_td_label_properties/o_td_label_properties\";\n\nclass FormComponents extends Component {\n    static template = \"web_studio.FormEditor.Sidebar.Components\";\n    static props = {};\n\n    get structures() {\n        return {\n            notebook: {\n                name: _t(\"Tabs\"),\n                class: \"o_web_studio_field_tabs\",\n            },\n            group: {\n                name: _t(\"Columns\"),\n                class: \"o_web_studio_field_columns\",\n            },\n        };\n    }\n}\n\nexport class FormEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.FormEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        FormComponents,\n        NewFields,\n        ExistingFields,\n        Property,\n        Properties,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.dialog = useService(\"dialog\");\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n    }\n\n    get propertiesComponents() {\n        const activeNode = this.env.viewEditorModel.activeNode;\n        const isOTdLabel =\n            activeNode?.arch.tagName === \"div\" && activeNode.arch.classList.contains(\"o_td_label\");\n        return {\n            button: {\n                component: ButtonProperties,\n                props: {\n                    availableOptions: [\"invisible\"],\n                },\n            },\n            field: {\n                component: FieldProperties,\n                props: {\n                    availableOptions: [\"invisible\", \"required\", \"readonly\", \"string\", \"help\"],\n                },\n            },\n            group: {\n                component: GroupProperties,\n            },\n            label: {\n                component: LabelProperties,\n            },\n            page: {\n                component: PageProperties,\n            },\n            div: {\n                component: isOTdLabel ? OTdLabelProperties : ChatterProperties,\n            },\n        };\n    }\n\n    get activeActions() {\n        return this.viewEditorModel.controllerProps.archInfo.activeActions;\n    }\n\n    getActiveAction(name) {\n        return this.activeActions[name] === true;\n    }\n\n    onAttributeChanged(value, name) {\n        return this.editArchAttributes({ [name]: value });\n    }\n}\n", "/** @odoo-module */\n\nimport { Component, onWillStart, onWillUpdateProps, useState } from \"@odoo/owl\";\nimport { CheckBox } from \"@web/core/checkbox/checkbox\";\nimport { DomainSelectorDialog } from \"@web/core/domain_selector_dialog/domain_selector_dialog\";\nimport { SelectMenu } from \"@web/core/select_menu/select_menu\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { Record } from \"@web/model/record\";\nimport { Many2OneField } from \"@web/views/fields/many2one/many2one_field\";\nimport { Many2ManyTagsField } from \"@web/views/fields/many2many_tags/many2many_tags_field\";\nimport { LimitGroupVisibility } from \"@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility\";\nimport { RainbowEffect } from \"./rainbow_effect\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\nimport { useSnackbarWrapper } from \"@web_studio/client_action/view_editor/view_editor_hook\";\nimport { ModifiersProperties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties\";\n\nexport class ButtonProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Button\";\n    static props = {\n        node: { type: Object },\n        availableOptions: { type: Array, optional: true },\n    };\n    static components = {\n        CheckBox,\n        LimitGroupVisibility,\n        Many2OneField,\n        Many2ManyTagsField,\n        RainbowEffect,\n        Record,\n        SelectMenu,\n        Property,\n        SidebarPropertiesToolbox,\n        ModifiersProperties,\n    };\n\n    setup() {\n        this.dialog = useService(\"dialog\");\n        this.orm = useService(\"orm\");\n        this.rpc = useService(\"rpc\");\n        this.state = useState({});\n        this.editNodeAttributes = useEditNodeAttributes();\n\n        this.decoratedOrmCall = useSnackbarWrapper(this.orm.call.bind(this.orm));\n        this.decoratedOrmWrite = useSnackbarWrapper(this.orm.write.bind(this.orm));\n\n        const m2mFieldsToFetch = {\n            display_name: { type: \"char\" },\n        };\n        const approvalRecordDefinition = {\n            group_id: {\n                type: \"many2one\",\n                relation: \"res.groups\",\n            },\n            responsible_id: {\n                type: \"many2one\",\n                relation: \"res.users\",\n                domain: [[\"share\", \"=\", false]],\n            },\n            users_to_notify: {\n                type: \"many2many\",\n                relation: \"res.users\",\n                related: { activeFields: m2mFieldsToFetch, fields: m2mFieldsToFetch },\n            },\n        };\n        this.recordProps = {\n            resModel: \"studio.approval.rule\",\n            fields: approvalRecordDefinition,\n            activeFields: approvalRecordDefinition,\n        };\n\n        onWillStart(() => {\n            if (this.props.node.attrs.studio_approval) {\n                this.updateApprovalSpec();\n            }\n        });\n\n        onWillUpdateProps((nextProps) => {\n            if (nextProps.node.attrs.studio_approval) {\n                this.updateApprovalSpec(this.getApprovalParams(nextProps.node));\n            } else {\n                delete this.state.approvalSpec;\n            }\n        });\n    }\n\n    onChangeAttribute(value, name) {\n        return this.editNodeAttributes({ [name]: value });\n    }\n\n    async onChangeApprovalRecord(record, changes, id) {\n        await this.decoratedOrmWrite(\"studio.approval.rule\", [id], changes);\n        this.updateApprovalSpec();\n    }\n\n    onEnableApproval(enable) {\n        this.env.viewEditorModel.doOperation({\n            enable,\n            type: \"enable_approval\",\n            btn_name: this.props.node.attrs.name,\n            btn_type: this.props.node.attrs.type,\n            btn_string: this.props.node.attrs.string,\n            model: this.env.viewEditorModel.controllerProps.resModel,\n            view_id: this.env.viewEditorModel.view.id,\n        });\n    }\n\n    get showRainbowMan() {\n        const attrs = this.props.node.attrs;\n        return attrs.class !== \"oe_stat_button\" && attrs.type === \"object\";\n    }\n\n    get isApprovalEnabled() {\n        return this.props.node.attrs.studio_approval === \"True\";\n    }\n\n    async createApprovalRule() {\n        const params = this.getApprovalParams();\n        params[3] = this.props.node.attrs.string;\n        await this.decoratedOrmCall(\"studio.approval.rule\", \"create_rule\", params);\n        this.updateApprovalSpec();\n    }\n\n    getApprovalParams(node = this.props.node) {\n        let method,\n            action = false;\n        if (node.attrs.type === \"object\") {\n            method = node.attrs.name;\n        } else {\n            action = node.attrs.name;\n        }\n        return [this.env.viewEditorModel.resModel, method, action];\n    }\n\n    async getApprovalSpec(approvalParams) {\n        return await this.orm.call(\"studio.approval.rule\", \"get_approval_spec\", approvalParams);\n    }\n\n    async onApprovalArchive(id) {\n        await this.decoratedOrmWrite(\"studio.approval.rule\", [id], {\n            active: false,\n        });\n        this.updateApprovalSpec();\n    }\n\n    async onApprovalEdit(name, id, value) {\n        const isMethod = this.props.node.attrs.type === \"object\";\n        await this.rpc(\"/web_studio/edit_approval\", {\n            model: this.env.viewEditorModel.resModel,\n            method: isMethod ? this.props.node.attrs.name : false,\n            action: isMethod ? false : this.props.node.attrs.name,\n            operations: [[name, id, value]],\n        });\n        this.updateApprovalSpec();\n    }\n\n    onApprovalSelectDomain(id) {\n        const domain = this.state.approvalSpec.rules.find((r) => r.id === id).domain;\n        this.dialog.add(DomainSelectorDialog, {\n            resModel: this.env.viewEditorModel.resModel,\n            domain: JSON.stringify(domain || []),\n            isDebugMode: !!this.env.debug,\n            onConfirm: async (domain) => {\n                await this.decoratedOrmWrite(\"studio.approval.rule\", [id], {\n                    domain,\n                });\n                this.updateApprovalSpec();\n            },\n        });\n    }\n\n    async onChangeNotificationOrder(ev, id) {\n        await this.decoratedOrmWrite(\"studio.approval.rule\", [id], {\n            notification_order: ev.target.value,\n        });\n        this.updateApprovalSpec();\n    }\n\n    async updateApprovalSpec(params = this.getApprovalParams()) {\n        this.state.approvalSpec = await this.getApprovalSpec(params);\n        this.env.viewEditorModel.env.bus.trigger(\"approval-update\");\n    }\n}\n", "/** @odoo-module */\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { Many2XAutocomplete } from \"@web/views/fields/relational_utils\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { ICONS } from \"@web_studio/utils\";\n\nexport class NewButtonBoxDialog extends Component {\n    static template = \"web_studio.NewButtonBoxDialog\";\n    static components = {\n        Dialog,\n        Many2XAutocomplete,\n    };\n    static props = {\n        isAddingButtonBox: { type: Boolean },\n        model: { type: Object },\n        close: { type: Function },\n    };\n    setup() {\n        this.orm = useService(\"orm\");\n        this.notification = useService(\"notification\");\n        this.state = useState({\n            icon: \"fa-diamond\",\n            field: undefined,\n        });\n        this.text = undefined;\n    }\n    get icons() {\n        return ICONS;\n    }\n    get title() {\n        return _t(\"Add a Button\");\n    }\n    async update(selection) {\n        if (!selection[0].display_name) {\n            const resId = selection[0].id;\n            const fields = [\"display_name\"];\n            const record = await this.orm.read(\"ir.model.fields\", [resId], fields);\n            selection[0].display_name = record[0].display_name;\n        }\n        this.state.field = selection[0];\n    }\n    getDomain() {\n        return [\n            [\"relation\", \"=\", this.props.model.resModel],\n            [\"ttype\", \"in\", [\"many2one\", \"many2many\"]],\n            [\"store\", \"=\", true],\n        ];\n    }\n    onConfirm() {\n        if (!this.state.field?.id) {\n            return this.notification.add(_t(\"Select a related field.\"));\n        }\n        if (this.props.isAddingButtonBox) {\n            this.props.model.pushOperation({ type: \"buttonbox\" });\n        }\n        this.props.model.doOperation({\n            type: \"add\",\n            target: {\n                tag: \"div\",\n                attrs: {\n                    class: \"oe_button_box\",\n                },\n            },\n            position: \"inside\",\n            node: {\n                tag: \"button\",\n                field: this.state.field.id,\n                string: this.text || _t(\"New button\"),\n                attrs: {\n                    class: \"oe_stat_button\",\n                    icon: this.state.icon,\n                },\n            },\n        });\n        this.props.close();\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { FileInput } from \"@web/core/file_input/file_input\";\nimport { SelectMenu } from \"@web/core/select_menu/select_menu\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { evaluateExpr } from \"@web/core/py_js/py\";\n\nexport class RainbowEffect extends Component {\n    static template = \"web_studio.ViewEditorSidebar.RainbowEffect\";\n    static props = {\n        effect: { type: true, optional: true },\n        onChange: { type: Function },\n    };\n    static components = {\n        FileInput,\n        SelectMenu,\n        Property,\n    };\n    setup() {\n        this.user = useService(\"user\");\n    }\n    get choices() {\n        return [\n            { label:  _t(\"Fast\"), value: \"fast\" },\n            { label:  _t(\"Medium\"), value: \"medium\" },\n            { label:  _t(\"Slow\"), value: \"slow\" },\n            { label:  _t(\"None\"), value: \"no\" },\n        ];\n    }\n    get rainbowEffect() {\n        const effect = this.props.effect;\n        if (effect === undefined) {\n            return null;\n        }\n        if (effect === \"True\") {\n            return {};\n        }\n        return evaluateExpr(effect);\n    }\n    onRainbowEffectChange(name, value) {\n        const effect = this.rainbowEffect;\n        if (!value || !value.length) {\n            delete effect[name];\n        } else {\n            effect[name] = value;\n        }\n        this.props.onChange(effect, \"effect\");\n    }\n    toggleRainbowMan() {\n        const effect = this.rainbowEffect;\n        const newValue = effect ? \"False\" : \"{}\";\n        this.props.onChange(newValue, \"effect\");\n    }\n}\n", "/** @odoo-module */\n\nimport { Component, useState, onWillStart, onWillUpdateProps } from \"@odoo/owl\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\n\nexport class ChatterProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Chatter\";\n    static components = { Property, SidebarPropertiesToolbox };\n\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.state = useState({});\n\n        onWillStart(async () => {\n            const alias = await this.getMailAlias(this.props.node);\n            this.state.mailAlias = alias.email_alias;\n            this.state.aliasDomain = alias.alias_domain;\n        });\n\n        onWillUpdateProps(async (nextProps) => {\n            const alias = await this.getMailAlias(nextProps.node);\n            this.state.mailAlias = alias.email_alias;\n            this.state.aliasDomain = alias.alias_domain;\n        });\n    }\n\n    async getMailAlias(node) {\n        const mailAliasObj = await this.rpc(\"/web_studio/get_email_alias\", {\n            model_name: this.env.viewEditorModel.resModel,\n        });\n        return mailAliasObj;\n    }\n\n    onChangeMailAlias(value) {\n        this.rpc(\"/web_studio/set_email_alias\", {\n            model_name: this.env.viewEditorModel.resModel,\n            value,\n        });\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { LimitGroupVisibility } from \"@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\nimport { ModifiersProperties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nexport class GroupProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Group\";\n    static components = {\n        ModifiersProperties,\n        LimitGroupVisibility,\n        Property,\n        SidebarPropertiesToolbox,\n    };\n\n    setup() {\n        this.editNodeAttributes = useEditNodeAttributes();\n    }\n\n    onChangeAttribute(value, name) {\n        return this.editNodeAttributes({ [name]: value });\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nexport class LabelProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Label\";\n    static components = { Property, SidebarPropertiesToolbox };\n\n    setup() {\n        this.editNodeAttributes = useEditNodeAttributes();\n    }\n\n    onChangeAttribute(value, name) {\n        return this.editNodeAttributes({ [name]: value });\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\n\nexport class OTdLabelProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.OTdLabelProperties\";\n    static components = { SidebarPropertiesToolbox };\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { LimitGroupVisibility } from \"@web_studio/client_action/view_editor/interactive_editor/properties/limit_group_visibility/limit_group_visibility\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\nimport { ModifiersProperties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/modifiers/modifiers_properties\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nclass PageNodeToolbox extends SidebarPropertiesToolbox {\n    removeNodeFromArch() {\n        const node = this.node;\n        let xpathToRemove = node.xpath;\n        if (node.arch.parentElement.children.length <= 1) {\n            // retarget to the parent notebook\n            xpathToRemove = node.xpath.split(\"/\").slice(0, -1).join(\"/\");\n        }\n        return super.removeNodeFromArch(xpathToRemove);\n    }\n}\n\nexport class PageProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Page\";\n    static components = {\n        Property,\n        LimitGroupVisibility,\n        PageNodeToolbox,\n        ModifiersProperties,\n    };\n\n    setup() {\n        this.editNodeAttributes = useEditNodeAttributes();\n    }\n\n    onChangeAttribute(value, name) {\n        return this.editNodeAttributes({ [name]: value });\n    }\n\n    static props = {\n        node: { type: Object },\n    }\n}\n", "/** @odoo-module */\n\nimport { ganttView } from \"@web_gantt/gantt_view\";\nimport { registry } from \"@web/core/registry\";\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nexport class GanttEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.GanttEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        Property,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n    }\n\n    get modelParams() {\n        return this.viewEditorModel.controllerProps.modelParams.metaData;\n    }\n\n    get colorChoices() {\n        return this.modelParams.decorationFields.map((value) => {\n            return {\n                label: this.modelParams.fields[value].string,\n                value,\n            };\n        });\n    }\n\n    get currentDayPrecision() {\n        return this.dayPrecisionChoices.find((e) => e.value === this.precisionValues.day)?.value;\n    }\n\n    get currentWeekPrecision() {\n        return this.weekAndMonthPrecisionChoices.find((e) => e.value === this.precisionValues.week)\n            ?.value;\n    }\n\n    get currentMonthPrecision() {\n        return this.weekAndMonthPrecisionChoices.find((e) => e.value === this.precisionValues.month)\n            ?.value;\n    }\n\n    get dayPrecisionChoices() {\n        return [\n            { label: _t(\"Quarter Hour\"), value: \"hour:quarter\" },\n            { label: _t(\"Half Hour\"), value: \"hour:half\" },\n            { label: _t(\"Hour\"), value: \"hour:full\" },\n        ];\n    }\n\n    get defaultScalesChoices() {\n        return Object.values(this.modelParams.scales).map((value) => {\n            return { label: value.description, value: value.id };\n        });\n    }\n\n    get fieldsChoices() {\n        return Object.values(this.modelParams.fields)\n            .filter((f) => f.store && this.viewEditorModel.GROUPABLE_TYPES.includes(f.type))\n            .map((f) => {\n                return {\n                    label: f.string,\n                    value: f.name,\n                };\n            });\n    }\n\n    get fieldsDateChoices() {\n        return Object.values(this.modelParams.fields)\n            .filter((f) => f.store && [\"date\", \"datetime\"].includes(f.type))\n            .map((f) => {\n                return {\n                    label: f.string,\n                    value: f.name,\n                };\n            });\n    }\n\n    get weekAndMonthPrecisionChoices() {\n        return [\n            { label: _t(\"Half Day\"), value: \"day:half\" },\n            { label: _t(\"Day\"), value: \"day:full\" },\n        ];\n    }\n\n    get precisionValues() {\n        const precision =\n            this.viewEditorModel.xmlDoc\n                .querySelector(\"gantt\")\n                .getAttribute(\"precision\")\n                ?.replace(/'/g, '\"') || \"{}\";\n        return JSON.parse(precision);\n    }\n\n    onDefaultGroupByChanged(selection) {\n        this.onViewAttributeChanged(selection.join(\",\"), \"default_group_by\");\n    }\n\n    onPrecisionChanged(value, name) {\n        const precision = this.precisionValues;\n        precision[name] = value;\n        this.onViewAttributeChanged(JSON.stringify(precision), \"precision\");\n    }\n\n    onViewAttributeChanged(value, name) {\n        return this.editArchAttributes({ [name]: value });\n    }\n}\n\nregistry.category(\"studio_editors\").add(\"gantt\", {\n    ...ganttView,\n    Sidebar: GanttEditorSidebar,\n});\n", "/** @odoo-module */\n\nimport { Component, onWillPatch, useState } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { registry } from \"@web/core/registry\";\nimport { graphView } from \"@web/views/graph/graph_view\";\n\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport * as operationUtils from \"@web_studio/client_action/view_editor/operations_utils\";\nimport { fieldsToChoices } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nexport class GraphEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.GraphEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        Property,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n\n        onWillPatch(() => {\n            this.oldFieldValues = {\n                firstDimension: this.modelParams.groupBy[0],\n                secondDimension: this.modelParams.groupBy[1],\n                measure:\n                    this.modelParams.measure === \"__count\" ? undefined : this.modelParams.measure,\n            };\n        });\n    }\n\n    onViewAttributeChanged(value, name) {\n        value = value ? value : \"\";\n        return this.editArchAttributes({ [name]: value });\n    }\n\n    onGroupByChanged(type, newField, oldField) {\n        const operation = operationUtils.viewGroupByOperation(\"graph\", type, newField, oldField);\n        this.viewEditorModel.doOperation(operation);\n    }\n\n    get modelParams() {\n        return this.viewEditorModel.controllerProps.modelParams;\n    }\n\n    get typeChoices() {\n        return [\n            { label: _t(\"Bar\"), value: \"bar\" },\n            { label: _t(\"Line\"), value: \"line\" },\n            { label: _t(\"Pie\"), value: \"pie\" },\n        ];\n    }\n\n    get orderChoices() {\n        return [\n            { label: _t(\"Ascending\"), value: \"asc\" },\n            { label: _t(\"Descending\"), value: \"desc\" },\n        ];\n    }\n\n    get firstGroupbyChoices() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) =>\n                field.store &&\n                this.viewEditorModel.GROUPABLE_TYPES.includes(field.type) &&\n                field.name !== this.modelParams.groupBy[1]\n        );\n    }\n\n    get secondGroupbyChoices() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) =>\n                field.store &&\n                this.viewEditorModel.GROUPABLE_TYPES.includes(field.type) &&\n                field.name !== this.modelParams.groupBy[0]\n        );\n    }\n\n    get mesureChoices() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) =>\n                field.name !== \"id\" &&\n                field.store &&\n                [\"integer\", \"float\", \"monetary\"].includes(field.type)\n        );\n    }\n}\n\nregistry.category(\"studio_editors\").add(\"graph\", {\n    ...graphView,\n    Sidebar: GraphEditorSidebar,\n});\n", "/** @odoo-module */\nimport { registry } from \"@web/core/registry\";\nimport { omit } from \"@web/core/utils/objects\";\nimport { kanbanView } from \"@web/views/kanban/kanban_view\";\nimport { KanbanEditorRenderer } from \"@web_studio/client_action/view_editor/editors/kanban/kanban_editor_renderer\";\nimport { makeModelErrorResilient } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { KanbanEditorSidebar } from \"./kanban_editor_sidebar/kanban_editor_sidebar\";\nimport { getStudioNoFetchFields, useModelConfigFetchInvisible } from \"../utils\";\n\nclass EditorArchParser extends kanbanView.ArchParser {\n    parse(arch, models, modelName) {\n        const parsed = super.parse(...arguments);\n        const noFetch = getStudioNoFetchFields(parsed.fieldNodes);\n        parsed.fieldNodes = omit(parsed.fieldNodes, ...noFetch.fieldNodes);\n        parsed.progressAttributes = false;\n        return parsed;\n    }\n}\nclass OneRecordModel extends kanbanView.Model {\n    async load() {\n        this.progressAttributes = false;\n        await super.load(...arguments);\n        let list = this.root;\n        let hasRecords;\n        const isGrouped = list.isGrouped;\n        if (!isGrouped) {\n            hasRecords = list.records.length;\n        } else {\n            hasRecords = list.groups.some((g) => g.list.records.length);\n        }\n        if (!hasRecords) {\n            if (isGrouped) {\n                const commonConfig = {\n                    resModel: list.config.resModel,\n                    fields: list.config.fields,\n                    activeFields: list.config.activeFields,\n                    groupByFieldName: list.groupByField.name,\n                    context: list.context,\n                    list: {\n                        resModel: list.config.resModel,\n                        fields: list.config.fields,\n                        activeFields: list.config.activeFields,\n                        groupBy: [],\n                        context: list.context,\n                    },\n                };\n\n                const data = {\n                    count: 0,\n                    length: 0,\n                    records: [],\n                    __domain: [],\n                    value: \"fake\",\n                    displayName: \"fake\",\n                    groups: [\n                        {\n                            display_name: false,\n                            count: 0,\n                        },\n                    ],\n                };\n\n                list.config.groups.fake = commonConfig;\n\n                const group = list._createGroupDatapoint(data);\n                list.groups.push(group);\n                list = group.list;\n            }\n            await list.addNewRecord();\n        }\n    }\n}\n\nclass KanbanEditorController extends kanbanView.Controller {\n    setup() {\n        super.setup();\n        useModelConfigFetchInvisible(this.model);\n    }\n\n    get modelParams() {\n        const params = super.modelParams;\n        params.groupsLimit = 1;\n        return params;\n    }\n}\n\nconst kanbanEditor = {\n    ...kanbanView,\n    Controller: KanbanEditorController,\n    ArchParser: EditorArchParser,\n    Renderer: KanbanEditorRenderer,\n    Model: OneRecordModel,\n    Sidebar: KanbanEditorSidebar,\n    props(genericProps, editor, config) {\n        const props = kanbanView.props(genericProps, editor, config);\n        props.defaultGroupBy = props.archInfo.defaultGroupBy;\n        props.Model = makeModelErrorResilient(OneRecordModel);\n        props.limit = 1;\n        props.Renderer = KanbanEditorRenderer;\n        return props;\n    },\n};\nregistry.category(\"studio_editors\").add(\"kanban\", kanbanEditor);\n", "/** @odoo-module */\nimport { KanbanCompiler } from \"@web/views/kanban/kanban_compiler\";\nimport { computeXpath, applyInvisible } from \"../xml_utils\";\nimport { isComponentNode } from \"@web/views/view_compiler\";\nimport { createElement } from \"@web/core/utils/xml\";\nimport { _t } from \"@web/core/l10n/translation\";\n\nconst interestingSelector = [\n    \"field\",\n    \"widget\",\n    \".dropdown\",\n    \"img.oe_kanban_avatar\",\n    \".o_kanban_record_body\",\n    \".o_kanban_record_bottom\",\n].join(\", \");\n\nexport class KanbanEditorCompiler extends KanbanCompiler {\n    constructor() {\n        super(...arguments);\n        const kanbanBox = this.templates[\"kanban-box\"];\n        this.isDashboard = kanbanBox.closest(\"kanban\").classList.contains(\"o_kanban_dashboard\");\n    }\n\n    applyInvisible(invisible, compiled, params) {\n        return applyInvisible(invisible, compiled, params);\n    }\n\n    compile(key, params = {}) {\n        const xml = this.templates[key];\n\n        // One pass to compute and add the xpath for the arch's node location\n        // onto that node.\n        const mainDiv = xml.querySelector(\"div\");\n        const interestingArchNodes = [...xml.querySelectorAll(interestingSelector)];\n        if (mainDiv) {\n            interestingArchNodes.push(mainDiv);\n        }\n        for (const el of interestingArchNodes) {\n            const xpath = computeXpath(el, \"kanban\");\n            el.setAttribute(\"studioXpath\", xpath);\n        }\n\n        const compiled = super.compile(key, params);\n\n        const isKanbanBox = key === \"kanban-box\";\n\n        if (isKanbanBox && !this.isDashboard && mainDiv) {\n            const tagsWidget = xml.querySelector(\"field[widget='many2many_tags']\");\n            if (!tagsWidget) {\n                this.addTagsWidgetHook(compiled);\n            }\n\n            const priorityWidget = xml.querySelector(\"field[widget='priority']\");\n            const favoriteWidget = xml.querySelector(\"field[widget='boolean_favorite']\");\n            if (!priorityWidget && !favoriteWidget) {\n                this.addPriorityHook(compiled);\n            }\n\n            const dropdown = this.templates[\"kanban-menu\"];\n            if (!dropdown) {\n                this.addDropdownHook(compiled);\n            }\n\n            const avatarImg = xml.querySelector(\"img.oe_kanban_avatar\");\n            if (!avatarImg) {\n                this.addAvatarHook(compiled);\n            }\n        }\n\n        compiled.querySelectorAll(\".oe_kanban_avatar\").forEach((el) => {\n            const tIf = el.closest(\"[t-if]\");\n            if (tIf) {\n                const tElse = createElement(\"t\", {\n                    \"t-else\": \"\",\n                    \"t-call\": \"web_studio.KanbanEditorRecord.AvatarPlaceholder\",\n                });\n                tIf.insertAdjacentElement(\"afterend\", tElse);\n            }\n        });\n\n        return compiled;\n    }\n\n    compileField(node) {\n        const compiled = super.compileField(...arguments);\n        if (compiled.tagName === \"span\") {\n            const fieldName = node.getAttribute(\"name\");\n            compiled.setAttribute(\"data-field-name\", fieldName);\n        } else {\n            compiled.setAttribute(\"hasEmptyPlaceholder\", true);\n        }\n\n        return compiled;\n    }\n\n    addStudioHook(node, compiled) {\n        const tNode = createElement(\"t\");\n        if (compiled.hasAttribute(\"t-if\")) {\n            // t-if from the invisible modifier\n            tNode.setAttribute(\"t-if\", compiled.getAttribute(\"t-if\"));\n            compiled.removeAttribute(\"t-if\");\n        }\n        tNode.appendChild(compiled);\n        const xpath = node.getAttribute(\"studioXpath\");\n        const studioHook = createElement(\"StudioHook\", {\n            xpath: `\"${xpath}\"`,\n            position: \"'after'\",\n        });\n        tNode.appendChild(studioHook);\n        return tNode;\n    }\n\n    compileNode(node, params) {\n        const nodeType = node.nodeType;\n        if (nodeType === 1 && (isComponentNode(node) || node.getAttribute(\"studio_no_fetch\"))) {\n            return;\n        }\n\n        let compiled = super.compileNode(node, { ...params, compileInvisibleNodes: true });\n\n        if (nodeType === 1 && compiled) {\n            // Put a xpath on anything of interest.\n            if (node.hasAttribute(\"studioXpath\")) {\n                const xpath = node.getAttribute(\"studioXpath\");\n                if (isComponentNode(compiled)) {\n                    compiled.setAttribute(\"studioXpath\", `\"${xpath}\"`);\n                } else if (!compiled.hasAttribute(\"studioXpath\")) {\n                    compiled.setAttribute(\"studioXpath\", xpath);\n                }\n\n                if (node.classList.contains(\"oe_kanban_avatar\")) {\n                    compiled.setAttribute(\n                        \"t-on-click\",\n                        `(ev) => __comp__.env.config.onNodeClicked(\"${xpath}\")`\n                    );\n                    compiled.classList.add(\"o-web-studio-editor--element-clickable\");\n                }\n                if (node.tagName === \"field\" && !isComponentNode(compiled)) {\n                    compiled.setAttribute(\n                        \"t-on-click\",\n                        `(ev) => __comp__.env.config.onNodeClicked(\"${xpath}\")`\n                    );\n                    compiled.classList.add(\"o-web-studio-editor--element-clickable\");\n\n                    const fieldName = node.getAttribute(\"name\");\n                    const isEmptyExpr = `__comp__.isFieldValueEmpty(record[\"${fieldName}\"].value)`;\n\n                    // Set empty class\n                    const tattfClassEmpty = `{{ ${isEmptyExpr} ? \"o_web_studio_widget_empty\" : \"\" }}`;\n\n                    const tattfClass = compiled.getAttribute(\"t-attf-class\");\n\n                    const nextAttfClass = tattfClass\n                        ? `${tattfClass} ${tattfClassEmpty}`\n                        : tattfClassEmpty;\n                    compiled.setAttribute(\"t-attf-class\", nextAttfClass);\n\n                    // Set field name on empty\n                    const fieldId = node.getAttribute(\"field_id\");\n                    const tOut = compiled.getAttribute(\"t-out\");\n                    compiled.setAttribute(\n                        \"t-out\",\n                        `${isEmptyExpr} ? __comp__.props.archInfo.fieldNodes['${fieldId}'].string : ${tOut}`\n                    );\n                }\n                if (node.tagName === \"field\" || node.tagName === \"widget\") {\n                    // Don't append a studio hook if a condition is on the tag itself\n                    // otherwise it may cause inconsistencies in the arch itself\n                    // ie `<field t-elif=\"someCondifiton\" /><field name=\"newField\" /><t t-else=\"\"/>` would be invalid\n                    if (\n                        !Array.from(node.getAttributeNames()).filter((att) =>\n                            [\"t-if\", \"t-elif\", \"t-else\"].includes(att)\n                        )[0]\n                    ) {\n                        compiled = this.addStudioHook(node, compiled);\n                    }\n                }\n            }\n        }\n        return compiled;\n    }\n\n    addTagsWidgetHook(compiled) {\n        const parentElement =\n            compiled.querySelector(\".o_kanban_record_body\") || compiled.querySelector(\"div\");\n        const tagsHook = createElement(\"span\", {\n            class: \"o_web_studio_add_kanban_tags\",\n            \"t-on-click\": `() => __comp__.onAddTagsWidget({\n                xpath: \"${parentElement.getAttribute(\"studioXpath\")}\"\n            })`,\n        });\n        tagsHook.textContent = _t(\"Add tags\");\n\n        if (parentElement.firstChild) {\n            parentElement.insertBefore(tagsHook, parentElement.firstChild);\n        } else {\n            parentElement.appendChild(tagsHook);\n        }\n    }\n\n    addDropdownHook(compiled) {\n        const rootSibling = compiled.querySelector(\"div\");\n        const dropdownHook = createElement(\n            \"div\",\n            [\n                createElement(\"a\", {\n                    class: \"btn fa fa-ellipsis-v\",\n                }),\n            ],\n            {\n                class: \"o_web_studio_add_dropdown o_dropdown_kanban dropdown position-absolute end-0\",\n                style: \"z-index: 1;\",\n                \"t-on-click\": \"() => __comp__.onAddDropdown()\",\n            }\n        );\n        rootSibling.insertAdjacentElement(\"afterend\", dropdownHook);\n    }\n\n    addPriorityHook(compiled) {\n        const parentElement = compiled.querySelector(\"div\");\n        const priorityHook = createElement(\"div\", {\n            class: \"o_web_studio_add_priority oe_kanban_bottom_left align-self-start flex-grow-0\",\n            style: \"z-index: 1;\",\n            \"t-on-click\": \"() => __comp__.onAddPriority()\",\n        });\n        priorityHook.textContent = _t(\"Add a priority\");\n        parentElement.appendChild(priorityHook);\n    }\n\n    addAvatarHook(compiled) {\n        const parentElement =\n            compiled.querySelector(\".o_kanban_record_bottom\") || compiled.querySelector(\"div\");\n        const avatarHook = createElement(\"div\", {\n            class: \"o_web_studio_add_kanban_image oe_kanban_bottom_right pe-auto\",\n            style: \"z-index: 1;\",\n            \"t-on-click\": \"() => __comp__.onAddAvatar()\",\n        });\n        avatarHook.textContent = _t(\"Add an avatar\");\n        parentElement.appendChild(avatarHook);\n    }\n\n    /**\n     * In v16, some views use forbidden owl directives (t-on) directly\n     * in the arch. In master, they will be removed. The validation is deactivated\n     * in the js_class used to render those archs, but as in studio we do not use\n     * the js_class, we have to disable the validation in the editor.\n     * @override\n     */\n    validateNode() {}\n}\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport { kanbanView } from \"@web/views/kanban/kanban_view\";\n\nimport { KanbanEditorCompiler } from \"@web_studio/client_action/view_editor/editors/kanban/kanban_editor_compiler\";\nimport { FieldStudio } from \"@web_studio/client_action/view_editor/editors/components/field_studio\";\nimport { WidgetStudio } from \"@web_studio/client_action/view_editor/editors/components/widget_studio\";\nimport { ViewButtonStudio } from \"@web_studio/client_action/view_editor/editors/components/view_button_studio\";\nimport { StudioHook } from \"@web_studio/client_action/view_editor/editors/components/studio_hook_component\";\nimport { FieldSelectorDialog } from \"@web_studio/client_action/view_editor/editors/components/field_selector_dialog\";\n\nimport { computeXpath } from \"@web_studio/client_action/view_editor/editors/xml_utils\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { AlertDialog, ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\n\nimport { Component, toRaw, useEnv, useState, xml, useEffect, useRef, onError } from \"@odoo/owl\";\n\nclass FieldStudioKanbanRecord extends FieldStudio {\n    isX2ManyEditable() {\n        return false;\n    }\n}\n\nconst OriginDropdown = kanbanView.Renderer.components.KanbanRecord.components.Dropdown;\nclass Dropdown extends OriginDropdown {\n    setup() {\n        super.setup();\n        const rootRef = useRef(\"root\");\n        this.rootRef = rootRef;\n        useEffect(\n            (rootEl) => {\n                if (this.props.studioXpath) {\n                    rootEl.classList.add(\"o-web-studio-editor--element-clickable\");\n                    rootEl.dataset.studioXpath = this.props.studioXpath;\n                }\n\n                if (this.props.hasCoverSetter) {\n                    rootEl.dataset.hasCoverSetter = true;\n                }\n            },\n            () => [rootRef.el]\n        );\n    }\n\n    onTogglerClick() {\n        this.env.config.onNodeClicked(this.props.studioXpath);\n    }\n}\nDropdown.template = \"web_studio.KanbanEditorRecord.Dropdown\";\nDropdown.props = {\n    ...OriginDropdown.props,\n    studioXpath: { type: String, optional: 1 },\n    hasCoverSetter: { type: Boolean, optional: 1 },\n};\n\nconst KanbanRecord = kanbanView.Renderer.components.KanbanRecord;\n\nfunction useSafeKanban() {\n    const state = useState({ hasError: false });\n    const viewEditorModel = toRaw(useEnv().viewEditorModel);\n    onError((error) => {\n        const hasError = state.hasError;\n        if (hasError || viewEditorModel.isInEdition) {\n            throw error;\n        }\n        state.hasError = true;\n    });\n    return state;\n}\n\nclass SafeKanbanRecord extends KanbanRecord {\n    setup() {\n        super.setup();\n        this.safe = useSafeKanban();\n    }\n}\nSafeKanbanRecord.template = \"web_studio.SafeKanbanRecord\";\n\nclass _KanbanEditorRecord extends KanbanRecord {\n    setup() {\n        super.setup();\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        if (this.constructor.KANBAN_MENU_ATTRIBUTE in this.props.templates) {\n            const compiledTemplateMenu =\n                this.props.templates[this.constructor.KANBAN_MENU_ATTRIBUTE];\n            this.dropdownXpath = computeXpath(compiledTemplateMenu, \"kanban\");\n            this.dropdownHasCoverSetter = Boolean(\n                compiledTemplateMenu.querySelectorAll(\"a[data-type='set_cover']\").length\n            );\n        }\n        this.dialogService = useService(\"dialog\");\n\n        this.safe = useSafeKanban();\n\n        useEffect(\n            (el) => {\n                if (!el) {\n                    return;\n                }\n                el.classList.remove(\"oe_kanban_global_click\", \"oe_kanban_global_click_edit\");\n            },\n            () => [this.rootRef.el]\n        );\n    }\n\n    onGlobalClick() {}\n\n    isFieldValueEmpty(value) {\n        if (value === null) {\n            return true;\n        }\n        if (Array.isArray(value)) {\n            return !value.length;\n        }\n        return !value;\n    }\n\n    onAddTagsWidget({ xpath }) {\n        const fields = [];\n        for (const [fName, field] of Object.entries(this.props.record.fields)) {\n            if (field.type === \"many2many\") {\n                const _field = { ...field, name: fName };\n                fields.push(_field);\n            }\n        }\n\n        if (!fields.length) {\n            this.dialogService.add(AlertDialog, {\n                body: _t(\"You first need to create a many2many field in the form view.\"),\n            });\n            return;\n        }\n\n        this.dialogService.add(FieldSelectorDialog, {\n            fields,\n            onConfirm: (field) => {\n                const operation = {\n                    type: \"add\",\n                    node: {\n                        tag: \"field\",\n                        attrs: { name: field },\n                    },\n                    target: this.env.viewEditorModel.getFullTarget(xpath),\n                    position: \"inside\",\n                };\n                this.env.viewEditorModel.doOperation(operation);\n            },\n        });\n    }\n\n    onAddDropdown() {\n        this.dialogService.add(ConfirmationDialog, {\n            body: _t(\"Do you want to add a dropdown with colors?\"),\n            confirm: () => {\n                this.env.viewEditorModel.doOperation({\n                    type: \"kanban_dropdown\",\n                });\n            },\n        });\n    }\n\n    onAddPriority() {\n        const fields = [];\n        const activeFields = Object.keys(this.props.record.activeFields);\n        for (const [fName, field] of Object.entries(this.props.record.fields)) {\n            if (field.type === \"selection\" && !activeFields.includes(fName)) {\n                const _field = { ...field, name: fName };\n                fields.push(_field);\n            }\n        }\n        this.dialogService.add(FieldSelectorDialog, {\n            fields,\n            showNew: true,\n            onConfirm: (field) => {\n                this.env.viewEditorModel.doOperation({\n                    type: \"kanban_priority\",\n                    field,\n                });\n            },\n        });\n    }\n\n    onAddAvatar() {\n        const fields = [];\n        for (const [fName, field] of Object.entries(this.props.record.fields)) {\n            if (\n                field.type === \"many2one\" &&\n                (field.relation === \"res.partner\" || field.relation === \"res.users\")\n            ) {\n                const _field = { ...field, name: fName };\n                fields.push(_field);\n            }\n        }\n        this.dialogService.add(FieldSelectorDialog, {\n            fields,\n            onConfirm: (field) => {\n                this.env.viewEditorModel.doOperation({\n                    type: \"kanban_image\",\n                    field,\n                });\n            },\n        });\n    }\n}\n_KanbanEditorRecord.components = {\n    ...KanbanRecord.components,\n    Dropdown,\n    Field: FieldStudioKanbanRecord,\n    Widget: WidgetStudio,\n    StudioHook,\n    ViewButton: ViewButtonStudio,\n};\n_KanbanEditorRecord.menuTemplate = \"web_studio.SafeKanbanRecordMenu\";\n_KanbanEditorRecord.template = \"web_studio.SafeKanbanRecord\";\n\nexport class KanbanEditorRecord extends Component {\n    static props = [...KanbanRecord.props];\n    get KanbanRecord() {\n        if (this.env.viewEditorModel.mode !== \"interactive\") {\n            return SafeKanbanRecord;\n        } else {\n            return _KanbanEditorRecord;\n        }\n    }\n    get kanbanRecordProps() {\n        const props = { ...this.props };\n        if (this.env.viewEditorModel.mode === \"interactive\") {\n            props.Compiler = KanbanEditorCompiler;\n        }\n        return props;\n    }\n}\nKanbanEditorRecord.template = xml`<t t-component=\"KanbanRecord\" t-props=\"kanbanRecordProps\" />`;\n", "/** @odoo-module */\nimport { kanbanView } from \"@web/views/kanban/kanban_view\";\nimport { KanbanEditorRecord } from \"@web_studio/client_action/view_editor/editors/kanban/kanban_editor_record\";\nimport { useRef, useEffect } from \"@odoo/owl\";\n\nexport class KanbanEditorRenderer extends kanbanView.Renderer {\n    setup() {\n        super.setup();\n        const rootRef = useRef(\"root\");\n        useEffect(\n            (el) => {\n                if (!el) {\n                    return;\n                }\n                el.classList.add(\"o_web_studio_kanban_view_editor\");\n            },\n            () => [rootRef.el]\n        );\n    }\n\n    get canUseSortable() {\n        return false;\n    }\n\n    get showNoContentHelper() {\n        return false;\n    }\n\n    getGroupsOrRecords() {\n        const { list } = this.props;\n        const groupsOrRec = super.getGroupsOrRecords(...arguments);\n        if (list.isGrouped) {\n            return [groupsOrRec.filter((el) => el.group.list.records.length)[0]];\n        } else {\n            return [groupsOrRec[0]];\n        }\n    }\n\n    canCreateGroup() {\n        return false;\n    }\n\n    getGroupUnloadedCount() {\n        return 0;\n    }\n}\nKanbanEditorRenderer.template = \"web_studio.KanbanEditorRenderer\";\nKanbanEditorRenderer.components = {\n    ...kanbanView.Renderer.components,\n    KanbanRecord: KanbanEditorRecord,\n};\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { ExistingFields } from \"@web_studio/client_action/view_editor/view_structures/view_structures\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { Properties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/properties\";\nimport { FieldProperties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties\";\nimport { KanbanCoverProperties } from \"@web_studio/client_action/view_editor/editors/kanban/kanban_editor_sidebar/properties/kanban_cover_properties/kanban_cover_properties\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\nimport { fieldsToChoices } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { getFieldsInArch } from \"@web_studio/client_action/utils\";\n\nclass KanbanFieldProperties extends FieldProperties {\n    onChangeAttribute(value, name) {\n        if (name === \"bold\" && !value) {\n            return this.editNodeAttributes({ [name]: \"\" });\n        }\n        return super.onChangeAttribute(...arguments);\n    }\n}\n\nexport class KanbanEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.KanbanEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        ExistingFields,\n        Property,\n        Properties,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n        this.propertiesComponents = {\n            field: {\n                component: KanbanFieldProperties,\n                props: {\n                    availableOptions: [\"invisible\", \"string\", \"bold\"],\n                },\n            },\n            t: {\n                component: KanbanCoverProperties,\n            },\n        };\n    }\n\n    get archInfo() {\n        return this.viewEditorModel.controllerProps.archInfo;\n    }\n\n    get defaultGroupBy() {\n        return {\n            choices: fieldsToChoices(this.viewEditorModel.fields, (field) => {\n                return field.store && this.viewEditorModel.GROUPABLE_TYPES.includes(field.type);\n            }),\n            required: false,\n        };\n    }\n\n    get kanbanFieldsInArch() {\n        // fields can be present in the xmlDoc to be preloaded, but not in\n        // the actual template. Those must be present in the sidebar\n        const kanbanXmlDoc = this.viewEditorModel.xmlDoc.querySelector(\"[t-name=kanban-box]\")\n        return getFieldsInArch(kanbanXmlDoc);\n    }\n\n    editAttribute(value, name) {\n        return this.editArchAttributes({ [name]: value });\n    }\n\n    editDefaultGroupBy(value) {\n        this.editAttribute(value || \"\", \"default_group_by\");\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { FieldSelectorDialog } from \"@web_studio/client_action/view_editor/editors/components/field_selector_dialog\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\n\nexport class KanbanCoverProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.KanbanCoverProperties\";\n    static props = {\n        node: { type: Object },\n    };\n    static components = { Property, SidebarPropertiesToolbox };\n\n    setup() {\n        this.dialog = useService(\"dialog\");\n    }\n\n    get coverNode() {\n        return this.env.viewEditorModel.xmlDoc.querySelector(\n            \"a[data-type='set_cover'],a[type='set_cover']\"\n        );\n    }\n\n    get coverValue() {\n        return !!this.coverNode;\n    }\n\n    setCover(value, name) {\n        const fields = [];\n\n        for (const field of Object.values(this.env.viewEditorModel.fields)) {\n            if (field.type === \"many2one\" && field.relation === \"ir.attachment\") {\n                fields.push(field);\n            }\n        }\n\n        this.dialog.add(FieldSelectorDialog, {\n            fields: fields,\n            showNew: true,\n            onConfirm: (field) => {\n                const operation = {\n                    type: \"kanban_set_cover\",\n                    field: field,\n                };\n                this.env.viewEditorModel.doOperation(operation);\n            },\n        });\n    }\n\n    onChangeCover(value, name) {\n        if (!value) {\n            const vem = this.env.viewEditorModel;\n            const fieldToRemove = Object.entries(vem.controllerProps.archInfo.fieldNodes).filter(\n                ([fName, fInfo]) => {\n                    return fInfo.widget === \"attachment_image\";\n                }\n            );\n            if (fieldToRemove.length !== 1) {\n                return;\n            }\n\n            const extraNode = this.coverNode;\n            const relevantAttr = [\"type\", \"data-type\"].filter((att) => {\n                return extraNode.hasAttribute(att) && extraNode.getAttribute(att) === \"set_cover\";\n            })[0];\n            const operation = {\n                target: {\n                    attrs: { name: fieldToRemove[0][1].name },\n                    tag: \"field\",\n                    extra_nodes: [\n                        {\n                            tag: extraNode.tagName,\n                            attrs: {\n                                [relevantAttr]: \"set_cover\",\n                            },\n                        },\n                    ],\n                },\n                type: \"remove\",\n            };\n            vem.doOperation(operation);\n        } else {\n            this.setCover(value, name);\n        }\n    }\n}\n", "/** @odoo-module */\nimport { listView } from \"@web/views/list/list_view\";\nimport { computeXpath } from \"../xml_utils\";\nimport { registry } from \"@web/core/registry\";\nimport { omit } from \"@web/core/utils/objects\";\n\nimport { ListEditorRenderer, columnsStyling } from \"./list_editor_renderer\";\n\nimport { Component, xml } from \"@odoo/owl\";\nimport { ListEditorSidebar } from \"./list_editor_sidebar/list_editor_sidebar\";\nimport { getStudioNoFetchFields, useModelConfigFetchInvisible } from \"../utils\";\n\nfunction parseStudioGroups(node) {\n    if (node.hasAttribute(\"studio_groups\")) {\n        return node.getAttribute(\"studio_groups\");\n    }\n}\n\nclass EditorArchParser extends listView.ArchParser {\n    parse(arch, models, modelName) {\n        const parsed = super.parse(...arguments);\n        const noFetch = getStudioNoFetchFields(parsed.fieldNodes);\n        parsed.fieldNodes = omit(parsed.fieldNodes, ...noFetch.fieldNodes);\n        const noFetchFieldNames = noFetch.fieldNames;\n        parsed.columns = parsed.columns.filter(\n            (col) => col.type !== \"field\" || !noFetchFieldNames.includes(col.name)\n        );\n        return parsed;\n    }\n\n    parseFieldNode(node, models, modelName) {\n        const parsed = super.parseFieldNode(...arguments);\n        parsed.studioXpath = computeXpath(node, \"list, tree\");\n        parsed.studio_groups = parseStudioGroups(node);\n        return parsed;\n    }\n\n    parseWidgetNode(node, models, modelName) {\n        const parsed = super.parseWidgetNode(...arguments);\n        parsed.studioXpath = computeXpath(node, \"list, tree\");\n        parsed.studio_groups = parseStudioGroups(node);\n        return parsed;\n    }\n\n    processButton(node) {\n        const parsed = super.processButton(node);\n        parsed.studioXpath = computeXpath(node, \"list, tree\");\n        parsed.studio_groups = parseStudioGroups(node);\n        return parsed;\n    }\n}\n\n/**\n * X2Many fields can have their subview edited. There are some challenges currently with the RelationalModel\n * - We need to inject the parent record in the evalContext. That way, within the subview's arch\n *   a snippet like `<field name=\"...\" invisible=\"not parent.id\" />` works.\n * - We already know the resIds we have, since we are coming from a x2m. There is no need to search_read them, just to read them\n * - The RelationalModel doesn't really supports creatic staticLists as the root record\n *\n * StaticList supports the two first needs and not DynamicList, we assume that the amount of hacking\n * would be slightly bigger if our starting point is DynamicList. Hence, we choose\n * to extend StaticList instead of DynamicList, and make it the root record of the model.\n */\nfunction useParentedStaticList(model, parentRecord, resIds) {\n    const config = model.config;\n    config.resIds = resIds;\n    config.offset = 0;\n    config.limit = Math.max(7, resIds.length); // don't load everything\n\n    model._createRoot = (config, data) => {\n        const options = { parent: parentRecord };\n        const list = new model.constructor.StaticList(model, { ...config }, data, options);\n        list.selection = [];\n        return list;\n    };\n}\n\nclass ListEditorController extends listView.Controller {\n    setup() {\n        super.setup();\n        useModelConfigFetchInvisible(this.model);\n        if (this.props.parentRecord) {\n            useParentedStaticList(this.model, this.props.parentRecord, this.props.resIds);\n        }\n    }\n}\nListEditorController.props = {\n    ...listView.Controller.props,\n    parentRecord: { type: Object, optional: true },\n};\n\nclass ControllerShadow extends Component {\n    static props = { ...ListEditorController.props };\n    get Component() {\n        return ListEditorController;\n    }\n\n    get componentProps() {\n        const props = { ...this.props };\n        props.groupBy = [];\n        return props;\n    }\n}\nControllerShadow.template = xml`<t t-component=\"Component\" t-props=\"componentProps\" />`;\n\nconst listEditor = {\n    ...listView,\n    Controller: ControllerShadow,\n    ArchParser: EditorArchParser,\n    Renderer: ListEditorRenderer,\n    props() {\n        const props = listView.props(...arguments);\n        props.allowSelectors = false;\n        props.editable = false;\n        props.showButtons = false;\n        return props;\n    },\n    Sidebar: ListEditorSidebar,\n};\nregistry.category(\"studio_editors\").add(\"list\", listEditor);\n\n/**\n *  Drag/Drop styling\n */\n\nconst colNearestHookClass = \"o_web_studio_nearest_hook\";\nlistEditor.styleNearestHook = function styleNearestColumn(mainRef, nearestHook) {\n    const xpath = nearestHook.dataset.xpath;\n    const position = nearestHook.dataset.position;\n    columnsStyling(\n        mainRef.el,\n        `.o_web_studio_hook[data-xpath='${xpath}'][data-position='${position}']`,\n        [colNearestHookClass]\n    );\n};\n\nlistEditor.styleClickedElement = (mainRef, params) => {\n    columnsStyling(mainRef.el, `[data-studio-xpath='${params.xpath}']:not(.o_web_studio_hook)`, [\n        \"o-web-studio-editor--element-clicked\",\n    ]);\n};\n", "/** @odoo-module */\nimport { listView } from \"@web/views/list/list_view\";\nimport { useThrottleForAnimation } from \"@web/core/utils/timing\";\nimport { reactive, useEffect, useState } from \"@odoo/owl\";\nimport { AddButtonAction } from \"../../interactive_editor/action_button/action_button\";\n\nconst colSelectedClass = \"o-web-studio-editor--element-clicked\";\nconst colHoverClass = \"o-web-studio--col-hovered\";\n\nfunction cleanStyling(mainEl, classNames) {\n    mainEl.querySelectorAll(`${classNames.map((c) => `.${c}`)}`).forEach((el) => {\n        el.classList.remove(...classNames);\n    });\n}\n\nexport function columnsStyling(mainEl, colSelector, classNames) {\n    mainEl.querySelectorAll(`td${colSelector}, th${colSelector}`).forEach((el) => {\n        el.classList.add(...classNames);\n    });\n}\n\nfunction getSelectableCol(target, colSelector) {\n    if (target.closest(\"button\")) {\n        return null;\n    }\n    const colEl = target.closest(`td${colSelector}, th${colSelector}`);\n    return colEl;\n}\n\nexport class ListEditorRenderer extends listView.Renderer {\n    setup() {\n        const viewEditorModel = useState(this.env.viewEditorModel);\n        this.viewEditorModel = reactive(viewEditorModel, () => {\n            // Little trick to update our columns when showInvisible changes on the viewEditorModel\n            // getActiveColumns reads that value\n            this.state.columns = this.getActiveColumns(this.props.list);\n        });\n        super.setup();\n        this.onTableHover = useThrottleForAnimation(this.onTableHover);\n\n        useEffect(\n            (rootEl) => {\n                rootEl.classList.add(\"o_web_studio_list_view_editor\");\n            },\n            () => [this.rootRef.el]\n        );\n    }\n\n    get canResequenceRows() {\n        return false;\n    }\n\n    getColumnClass(col) {\n        let cls = super.getColumnClass(col);\n        if (col.studioColumnInvisible) {\n            cls += \" o_web_studio_show_invisible\";\n        }\n        return cls;\n    }\n\n    getCellClass(col, record) {\n        let cls = super.getCellClass(col, record);\n        if (col.studioColumnInvisible || super.evalInvisible(col.invisible, record)) {\n            cls += \" o_web_studio_show_invisible\";\n        }\n        return cls;\n    }\n\n    getColumnHookData(col, position) {\n        let xpath;\n        if (!col) {\n            return { xpath: \"/tree\", position: \"inside\" };\n        }\n        if (col.type === \"button_group\") {\n            if (position === \"before\") {\n                xpath = col.buttons[0].studioXpath;\n            } else {\n                xpath = col.buttons[col.buttons.length - 1].studioXpath;\n            }\n        } else {\n            xpath = col.studioXpath;\n        }\n        return {\n            xpath,\n            position,\n        };\n    }\n\n    addColsHooks(_cols) {\n        const attrs = { width: \"1px\" };\n        const options = {};\n        const cols = [];\n        let hookId = 0;\n        const firstCol = _cols.find((c) => c.optional !== \"hide\");\n        const { xpath, position } = this.getColumnHookData(firstCol, \"before\");\n        cols.push({\n            type: \"studio_hook\",\n            position,\n            xpath,\n            id: `studio_hook_${hookId++}_${(firstCol && firstCol.id) || 0}`,\n            attrs,\n            options,\n        });\n        for (const col of _cols) {\n            if (col.optional === \"hide\") {\n                continue;\n            }\n            cols.push(col);\n            const { xpath, position } = this.getColumnHookData(col, \"after\");\n            cols.push({\n                type: \"studio_hook\",\n                position,\n                xpath,\n                id: `studio_hook_${hookId++}_${col.id}`,\n                attrs,\n                options,\n            });\n        }\n        return cols;\n    }\n\n    get allColumns() {\n        let cols = this._allColumns;\n        if (this.viewEditorModel.showInvisible) {\n            cols = cols.map((c) => {\n                return {\n                    ...c,\n                    optional: false,\n                    studioColumnInvisible:\n                        c.optional === \"hide\" || this.props.evalViewModifier(c.column_invisible),\n                };\n            });\n        } else {\n            cols = cols.filter((c) => !this.evalColumnInvisible(c.column_invisible));\n        }\n        return this.addColsHooks(cols);\n    }\n\n    set allColumns(cols) {\n        this._allColumns = cols;\n    }\n\n    evalInvisible(modifier, record) {\n        if (this.viewEditorModel.showInvisible) {\n            return false;\n        }\n        return super.evalInvisible(modifier, record);\n    }\n    evalColumnInvisible(columnInvisible) {\n        if (this.viewEditorModel.showInvisible) {\n            return false;\n        }\n        return super.evalColumnInvisible(columnInvisible);\n    }\n\n    onTableHover(ev) {\n        const table = this.tableRef.el;\n        cleanStyling(table, [colHoverClass]);\n        if (ev.type !== \"mouseover\") {\n            return;\n        }\n        const colEl = getSelectableCol(ev.target, \"[data-studio-xpath]\");\n        if (!colEl) {\n            return;\n        }\n        const xpath = colEl.dataset.studioXpath;\n        columnsStyling(table, `[data-studio-xpath='${xpath}']:not(.o_web_studio_hook)`, [\n            colHoverClass,\n        ]);\n    }\n\n    onTableClicked(ev) {\n        ev.stopPropagation();\n        ev.preventDefault();\n        const table = ev.currentTarget;\n        cleanStyling(table, [colSelectedClass]);\n        const colEl = getSelectableCol(ev.target, \"[data-studio-xpath]\");\n        if (!colEl) {\n            return;\n        }\n        this.env.config.onNodeClicked(colEl.dataset.studioXpath);\n    }\n\n    makeTooltipButton(button) {\n        return JSON.stringify({\n            button: {\n                string: button.string,\n                type: button.clickParams?.type,\n                name: button.clickParams?.name,\n            },\n            debug: true,\n        });\n    }\n}\nListEditorRenderer.template = \"web_studio.ListEditorRenderer\";\nListEditorRenderer.recordRowTemplate = \"web_studio.ListEditorRenderer.RecordRow\";\nListEditorRenderer.components = {\n    ...listView.Renderer.components,\n    AddButtonAction,\n};\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport {\n    ExistingFields,\n    NewFields,\n} from \"@web_studio/client_action/view_editor/view_structures/view_structures\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { Properties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/properties\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { sprintf } from \"@web/core/utils/strings\";\nimport { FieldProperties } from \"@web_studio/client_action/view_editor/interactive_editor/properties/field_properties/field_properties\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\nimport { fieldsToChoices } from \"@web_studio/client_action/view_editor/editors/utils\";\n\nclass ListFieldNodeProperties extends FieldProperties {\n    onChangeAttribute(value, name) {\n        if (name !== \"aggregate\") {\n            return super.onChangeAttribute(...arguments);\n        }\n        const activeNode = this.env.viewEditorModel.activeNode;\n        const newAttrs = {\n            avg: \"\",\n            sum: \"\",\n        };\n        if (value && value !== \"none\") {\n            const humanName = value === \"sum\" ? _t(\"Sum of %s\") : _t(\"Average of %s\");\n            const fieldString = activeNode.attrs.string || activeNode.field.label;\n            newAttrs[value] = sprintf(humanName, fieldString);\n        }\n        return this.editNodeAttributes(newAttrs);\n    }\n}\n\nexport class ListEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.ListEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        NewFields,\n        ExistingFields,\n        Property,\n        Properties,\n        SidebarViewToolbox,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n        this.propertiesComponents = {\n            field: {\n                component: ListFieldNodeProperties,\n                props: {\n                    availableOptions: [\n                        \"invisible\",\n                        \"required\",\n                        \"readonly\",\n                        \"string\",\n                        \"help\",\n                        \"optional\",\n                    ],\n                },\n            },\n        };\n    }\n\n    get archInfo() {\n        return this.viewEditorModel.controllerProps.archInfo;\n    }\n\n    get defaultOrder() {\n        if (this.archInfo.defaultOrder.length >= 1) {\n            return this.archInfo.defaultOrder[0];\n        } else {\n            return { name: \"\", asc: true };\n        }\n    }\n\n    get editableChoices() {\n        return [\n            { value: \"\", label: _t(\"Open form view\") },\n            { value: \"top\", label: _t(\"Add record on top\") },\n            { value: \"bottom\", label: _t(\"Add record at the bottom\") },\n        ];\n    }\n\n    get sortChoices() {\n        return fieldsToChoices(this.archInfo.fieldNodes, (field) => ![\"one2many\", \"many2many\", \"binary\"].includes(field.type));\n    }\n\n    get orderChoices() {\n        return [\n            { value: \"asc\", label: _t(\"Ascending\") },\n            { value: \"desc\", label: _t(\"Descending\") },\n        ];\n    }\n\n    get defaultGroupbyChoices() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) => field.store && this.viewEditorModel.GROUPABLE_TYPES.includes(field.type)\n        );\n    }\n\n    setSortBy(value) {\n        this.onSortingChanged(value, this.defaultOrder.asc ? \"asc\" : \"desc\");\n    }\n\n    setOrder(value) {\n        this.onSortingChanged(this.defaultOrder.name, value);\n    }\n\n    onSortingChanged(sortBy, order) {\n        if (sortBy) {\n            this.onAttributeChanged(`${sortBy} ${order}`, \"default_order\");\n        } else {\n            this.onAttributeChanged(\"\", \"default_order\");\n        }\n    }\n\n    onAttributeChanged(value, name) {\n        return this.editArchAttributes({ [name]: value });\n    }\n}\n", "/** @odoo-module */\n\nimport { mapView } from \"@web_map/map_view/map_view\";\nimport { registry } from \"@web/core/registry\";\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { Record } from \"@web/model/record\";\nimport { Many2ManyTagsField } from \"@web/views/fields/many2many_tags/many2many_tags_field\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\nimport { MultiRecordSelector } from \"@web/core/record_selectors/multi_record_selector\";\n\nexport class MapEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.MapEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        Property,\n        SidebarViewToolbox,\n        Record,\n        Many2ManyTagsField,\n        MultiRecordSelector,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n    }\n\n    get modelParams() {\n        return this.viewEditorModel.controllerProps.modelParams;\n    }\n\n    get multiRecordSelectorProps() {\n        return {\n            resModel: \"ir.model.fields\",\n            update: this.changeAdditionalFields.bind(this),\n            resIds: this.currentAdditionalFieldsIds,\n            domain: [\n                [\"model\", \"=\", this.viewEditorModel.resModel],\n                [\"ttype\", \"not in\", [\"many2many\", \"one2many\", \"binary\"]],\n            ],\n        };\n    }\n\n    get currentAdditionalFieldsIds() {\n        return (\n            JSON.parse(\n                this.viewEditorModel.xmlDoc.firstElementChild.getAttribute(\"studio_map_field_ids\")\n            ) || []\n        );\n    }\n\n    onViewAttributeChanged(value, name) {\n        value = value ? value : \"\";\n        return this.editArchAttributes({ [name]: value });\n    }\n\n    get contactFieldChoices() {\n        return Object.values(this.viewEditorModel.fields)\n            .filter((field) => field.type === \"many2one\" && field.relation === \"res.partner\")\n            .map((field) => ({ label: `${field.string} (${field.name})`, value: field.name }));\n    }\n\n    get defaultOrderChoices() {\n        return Object.values(this.viewEditorModel.fields)\n            .filter(\n                (field) => field.store && ![\"one2many\", \"many2many\", \"binary\"].includes(field.type)\n            )\n            .map((field) => ({ label: `${field.string} (${field.name})`, value: field.name }));\n    }\n\n    /**\n     * @param {Array<Number>} resIds\n     */\n    changeAdditionalFields(resIds) {\n        const currentFullIds = this.currentAdditionalFieldsIds;\n        const newIds = resIds.filter((id) => !currentFullIds.includes(id));\n        let toRemoveIds;\n\n        const operationType = newIds.length ? \"add\" : \"remove\";\n\n        if (operationType === \"remove\") {\n            toRemoveIds = currentFullIds.filter((id) => !resIds.includes(id));\n        }\n\n        this.viewEditorModel.doOperation({\n            type: \"map_popup_fields\",\n            target: {\n                operation_type: operationType,\n                field_ids: operationType === \"add\" ? newIds : toRemoveIds,\n            },\n        });\n    }\n}\n\nregistry.category(\"studio_editors\").add(\"map\", {\n    ...mapView,\n    Sidebar: MapEditorSidebar,\n});\n", "/** @odoo-module */\n\nimport { Component, useState } from \"@odoo/owl\";\nimport { registry } from \"@web/core/registry\";\nimport { pivotView } from \"@web/views/pivot/pivot_view\";\n\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport * as operationUtils from \"@web_studio/client_action/view_editor/operations_utils\";\nimport { fieldsToChoices } from \"@web_studio/client_action/view_editor/editors/utils\";\n\nimport { Record } from \"@web/model/record\";\nimport { Many2ManyTagsField } from \"@web/views/fields/many2many_tags/many2many_tags_field\";\n\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\nimport { computeReportMeasures } from \"@web/views/utils\";\nimport { MultiRecordSelector } from \"@web/core/record_selectors/multi_record_selector\";\n\nfunction getFieldNameFromGroupby(str) {\n    return str.split(\":\")[0];\n}\n\nexport class PivotEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.PivotEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        Property,\n        SidebarViewToolbox,\n        Record,\n        Many2ManyTagsField,\n        MultiRecordSelector,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        this.editArchAttributes = useEditNodeAttributes({ isRoot: true });\n    }\n\n    get possibleMeasures() {\n        const { fieldAttrs, activeMeasures } = this.archInfo;\n        return computeReportMeasures(this.viewEditorModel.fields, fieldAttrs, activeMeasures);\n    }\n\n    get multiRecordSelectorProps() {\n        return {\n            resModel: \"ir.model.fields\",\n            update: this.changeMeasureFields.bind(this),\n            resIds: this.currentMeasureFields,\n            domain: [\n                [\"model\", \"=\", this.viewEditorModel.resModel],\n                [\"name\", \"in\", Object.keys(this.possibleMeasures)],\n            ],\n        };\n    }\n\n    get currentMeasureFields() {\n        return (\n            JSON.parse(\n                this.viewEditorModel.xmlDoc.firstElementChild.getAttribute(\n                    \"studio_pivot_measure_field_ids\"\n                )\n            ) || []\n        );\n    }\n\n    get archInfo() {\n        return this.viewEditorModel.controllerProps.modelParams.metaData;\n    }\n\n    get rowGroupBys() {\n        return this.archInfo.rowGroupBys.map((fName) => getFieldNameFromGroupby(fName));\n    }\n\n    get colGroupBys() {\n        return this.archInfo.colGroupBys.map((fName) => getFieldNameFromGroupby(fName));\n    }\n\n    /**\n     * @param {Array<Number>} resIds\n     */\n    changeMeasureFields(resIds) {\n        const currentFullIds = this.currentMeasureFields;\n        const newIds = resIds.filter((id) => !currentFullIds.includes(id));\n        let toRemoveIds;\n\n        const operationType = newIds.length ? \"add\" : \"remove\";\n\n        if (operationType === \"remove\") {\n            toRemoveIds = currentFullIds.filter((id) => !resIds.includes(id));\n        }\n\n        this.viewEditorModel.doOperation({\n            type: \"pivot_measures_fields\",\n            target: {\n                operation_type: operationType,\n                field_ids: operationType === \"add\" ? newIds : toRemoveIds,\n            },\n        });\n    }\n\n    onGroupByChanged(type, newValue, oldValue) {\n        const operation = operationUtils.viewGroupByOperation(\"pivot\", type, newValue, oldValue);\n        this.viewEditorModel.doOperation(operation);\n    }\n\n    onViewAttributeChanged(value, name) {\n        value = value ? value : \"\";\n        return this.editArchAttributes({ [name]: value });\n    }\n\n    get columnGroupbyChoices() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) =>\n                field.store &&\n                this.viewEditorModel.GROUPABLE_TYPES.includes(field.type) &&\n                ![this.archInfo.rowGroupBys[0], this.archInfo.rowGroupBys[1]].includes(field.name)\n        );\n    }\n\n    get rowGroupbyChoices_first() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) =>\n                field.store &&\n                this.viewEditorModel.GROUPABLE_TYPES.includes(field.type) &&\n                ![this.archInfo.colGroupBys[0], this.archInfo.rowGroupBys[1]].includes(field.name)\n        );\n    }\n\n    get rowGroupbyChoices_second() {\n        return fieldsToChoices(\n            this.viewEditorModel.fields,\n            (field) =>\n                field.store &&\n                this.viewEditorModel.GROUPABLE_TYPES.includes(field.type) &&\n                ![this.archInfo.colGroupBys[0], this.archInfo.rowGroupBys[0]].includes(field.name)\n        );\n    }\n}\n\nregistry.category(\"studio_editors\").add(\"pivot\", {\n    ...pivotView,\n    Sidebar: PivotEditorSidebar,\n});\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\nimport { registry } from \"@web/core/registry\";\nimport {\n    computeXpath,\n    getNodesFromXpath,\n} from \"@web_studio/client_action/view_editor/editors/xml_utils\";\nimport { visitXML } from \"@web/core/utils/xml\";\nimport { StudioHook } from \"@web_studio/client_action/view_editor/editors/components/studio_hook_component\";\nimport { InteractiveEditorSidebar } from \"@web_studio/client_action/view_editor/interactive_editor/interactive_editor_sidebar\";\nimport { ExistingFields } from \"@web_studio/client_action/view_editor/view_structures/view_structures\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SidebarViewToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/sidebar_view_toolbox/sidebar_view_toolbox\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { memoize } from \"@web/core/utils/functions\";\nimport { useOwnedDialogs } from \"@web/core/utils/hooks\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\nimport { standardViewProps } from \"@web/views/standard_view_props\";\n\nfunction getGroupByFieldNameFromString(str) {\n    const matches = str.match(/(,\\s*)?([\"'])group_by\\2\\1(\\s*:\\s*)?\\2(?<fieldName>.*)\\2/);\n    if (!matches) {\n        return null;\n    }\n    if (!matches.groups) {\n        return null;\n    }\n    return matches.groups.fieldName;\n}\n\nfunction isFilterGroupBy(node) {\n    if (!node.hasAttribute(\"context\")) {\n        return false;\n    }\n    if (/(['\"])group_by\\1\\s*:/.test(node.getAttribute(\"context\"))) {\n        return true;\n    }\n    return false;\n}\n\n/** CONTROLLER STUFF */\nclass SearchEditorArchParser {\n    parse(xmlDoc) {\n        this.fields = [];\n        this.filters = [];\n        this.groupBys = [];\n        this.currentCategory = null;\n        this.currentItems = { items: [] };\n\n        visitXML(xmlDoc, this.visitNode.bind(this));\n        this.changeCategory(null, true); // Flush\n\n        return {\n            fields: this.fields,\n            filters: this.filters,\n            groupBys: this.groupBys,\n            xmlDoc,\n        };\n    }\n\n    visitNode(node) {\n        if (node.nodeType !== 1) {\n            return;\n        }\n\n        const nodeName = node.nodeName;\n        const studioXpath = computeXpath(node, \"search\");\n        if (nodeName === \"field\") {\n            this.changeCategory(\"field\", true);\n            const item = this.parseNode(node);\n            item.studioXpath = studioXpath;\n            this.fields.push(item);\n            return false;\n        }\n        if (nodeName === \"filter\") {\n            const category = isFilterGroupBy(node) ? \"groupBy\" : \"filter\";\n            this.changeCategory(category);\n            const item = this.parseNode(node);\n            item.studioXpath = studioXpath;\n            this.pushItem(item);\n            return false;\n        }\n        if (nodeName === \"separator\") {\n            this.changeCategory(\"filter\", true);\n            this.currentItems.separator = studioXpath;\n            return false;\n        }\n        if (nodeName === \"group\") {\n            this.changeCategory(null, true);\n            Array.from(node.children).forEach(this.visitNode.bind(this));\n            this.changeCategory(null, true);\n            return false;\n        }\n    }\n\n    parseNode(node) {\n        const nodeName = node.nodeName;\n        const invisible = node.getAttribute(\"invisible\");\n        if (nodeName === \"field\") {\n            return {\n                type: \"field\",\n                name: node.getAttribute(\"name\"),\n                label: node.getAttribute(\"string\"),\n                invisible,\n            };\n        }\n        if (nodeName === \"separator\") {\n            return { type: \"separator\" };\n        }\n        if (nodeName === \"filter\") {\n            const item = {\n                type: \"filter\",\n                name: node.getAttribute(\"name\"),\n                label: node.getAttribute(\"string\") || node.getAttribute(\"help\"),\n                domain: node.getAttribute(\"domain\"),\n                invisible,\n            };\n            if (node.hasAttribute(\"context\")) {\n                const groupBy = getGroupByFieldNameFromString(node.getAttribute(\"context\"));\n                if (groupBy) {\n                    item.groupBy = groupBy;\n                    item.type = \"groupBy\";\n                }\n            }\n            return item;\n        }\n    }\n\n    pushItem(item) {\n        this.currentItems.items.push(item);\n    }\n\n    changeCategory(category, force) {\n        if (this.currentCategory !== category || force) {\n            let itemsToPushIn;\n            if (this.currentCategory === \"filter\") {\n                itemsToPushIn = this.filters;\n            } else if (this.currentCategory === \"groupBy\") {\n                itemsToPushIn = this.groupBys;\n            }\n            if (itemsToPushIn) {\n                itemsToPushIn.push(this.currentItems);\n                this.currentItems = { items: [] };\n            }\n        }\n        this.currentCategory = category || this.currentCategory;\n    }\n}\n\nclass SearchEditorController extends Component {\n    static props = { ...standardViewProps, archInfo: { type: Object } };\n    static template = \"web_studio.SearchEditorController\";\n    static components = { StudioHook };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n    }\n\n    get filtersGroups() {\n        return this.props.archInfo.filters;\n    }\n\n    hasItems(group) {\n        return group.some((g) => this.getItems(g.items));\n    }\n\n    get autoCompleteFields() {\n        return this.props.archInfo.fields;\n    }\n\n    get groupByGroups() {\n        return this.props.archInfo.groupBys;\n    }\n\n    getItems(items) {\n        if (!this.viewEditorModel.showInvisible) {\n            return items.filter((i) => i.invisible !== \"True\" && i.invisible !== \"1\");\n        }\n        return items;\n    }\n\n    getFirstHookProps(type) {\n        const xpath = \"/search\";\n        const position = \"inside\";\n\n        const group = type === \"filter\" ? this.filtersGroups : this.groupByGroups;\n        if (this.hasItems(group)) {\n            return false;\n        }\n        const props = {\n            xpath,\n            position,\n            type,\n        };\n        if (type === \"groupBy\") {\n            props.infos = JSON.stringify({\n                create_group: true,\n            });\n        }\n        return props;\n    }\n\n    getItemLabel(type, item) {\n        if (type === \"filter\") {\n            return item.label;\n        }\n        if (type === \"groupBy\") {\n            let label = item.label || item.name;\n            if (this.env.debug) {\n                label = `${label} (${item.groupBy})`;\n            }\n            return label;\n        }\n        if (type === \"field\") {\n            let label = item.label || this.props.fields[item.name].string;\n            if (this.env.debug) {\n                label = `${label} (${item.name})`;\n            }\n            return label;\n        }\n    }\n\n    onItemClicked(ev, xpath) {\n        this.env.config.onNodeClicked(xpath);\n    }\n}\n\n/** SIDEBAR STUFF */\n\nclass SearchComponents extends Component {\n    static props = {};\n    static template = \"web_studio.SearchEditor.Sidebar.Components\";\n\n    get structures() {\n        return {\n            filter: {\n                name: _t(\"Filter\"),\n                class: \"o_web_studio_filter\",\n            },\n            separator: {\n                name: _t(\"Separator\"),\n                class: \"o_web_studio_filter_separator\",\n            },\n        };\n    }\n}\n\nclass SimpleElementEditor extends Component {\n    static props = { node: { type: Object } };\n    static components = { Property, SidebarPropertiesToolbox };\n    static template = \"web_studio.SearchEditor.SimpleElementEditor\";\n\n    setup() {\n        this.addDialog = useOwnedDialogs();\n    }\n\n    get viewEditorModel() {\n        return this.env.viewEditorModel;\n    }\n\n    get node() {\n        return this.props.node;\n    }\n\n    get label() {\n        if (this.node.type === \"field\" && !this.node.label) {\n            return this.env.viewEditorModel.fields[this.node.name].string;\n        }\n        return this.node.label;\n    }\n\n    get domain() {\n        if (this.node.type === \"filter\") {\n            return this.node.domain;\n        }\n        return null;\n    }\n\n    onChangeDomain(value) {\n        const operation = {\n            new_attrs: { domain: value },\n            type: \"attributes\",\n            position: \"attributes\",\n            target: this.viewEditorModel.getFullTarget(this.viewEditorModel.activeNodeXpath),\n        };\n        this.viewEditorModel.doOperation(operation);\n    }\n\n    onChangeLabel(value) {\n        const operation = {\n            new_attrs: { string: value },\n            type: \"attributes\",\n            position: \"attributes\",\n            target: this.viewEditorModel.getFullTarget(this.viewEditorModel.activeNodeXpath),\n        };\n        this.viewEditorModel.doOperation(operation);\n    }\n\n    onPropertyRemoved() {\n        const activeNodeXpath = this.viewEditorModel.activeNodeXpath;\n        this.viewEditorModel.activeNodeXpath = null;\n        const operation = {\n            type: \"remove\",\n            target: this.viewEditorModel.getFullTarget(activeNodeXpath),\n        };\n        this.viewEditorModel.doOperation(operation);\n    }\n}\n\nclass SearchEditorSidebar extends Component {\n    static template = \"web_studio.ViewEditor.SearchEditorSidebar\";\n    static props = {\n        openViewInForm: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n    };\n    static components = {\n        InteractiveEditorSidebar,\n        ExistingFields,\n        SearchComponents,\n        Property,\n        SidebarViewToolbox,\n        SimpleElementEditor,\n    };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n        const searchArchParser = new SearchEditorArchParser();\n        this._getCurrentNode = memoize(() => {\n            const { activeNodeXpath, xmlDoc } = this.viewEditorModel;\n            if (!activeNodeXpath) {\n                return null;\n            }\n            const node = getNodesFromXpath(activeNodeXpath, xmlDoc);\n            return searchArchParser.parseNode(node[0]);\n        });\n    }\n\n    get currentNode() {\n        const { activeNodeXpath, arch } = this.viewEditorModel;\n        return this._getCurrentNode(`${activeNodeXpath}_${arch}`);\n    }\n}\n\n/** SIDEBAR STUFF */\nconst searchEditor = {\n    ArchParser: SearchEditorArchParser,\n    Controller: SearchEditorController,\n    props(genericProps, editor, config) {\n        const archInfo = new editor.ArchParser().parse(genericProps.arch);\n        return { ...genericProps, archInfo };\n    },\n    Sidebar: SearchEditorSidebar,\n};\n\nregistry.category(\"studio_editors\").add(\"search\", searchEditor);\n\n/** Drag/Drop */\n\nconst FILTER_TYPES = [\"date\", \"datetime\"];\nconst GROUPABLE_TYPES = [\n    \"many2one\",\n    \"many2many\",\n    \"char\",\n    \"boolean\",\n    \"selection\",\n    \"date\",\n    \"datetime\",\n];\n\nfunction fieldCanBeFilter(field) {\n    return FILTER_TYPES.includes(field.type) && field.store;\n}\n\nfunction fieldCanBeGroupable(field) {\n    return GROUPABLE_TYPES.includes(field.type) && field.store;\n}\n\nconst disabledDropClass = \"o-web-studio-search--drop-disable\";\n\nsearchEditor.isValidHook = function isValidSearchHook({ hook, element, viewEditorModel }) {\n    if (hook.closest(`.${disabledDropClass}`)) {\n        return false;\n    }\n    return true;\n};\n\nsearchEditor.prepareForDrag = function ({ element, viewEditorModel, ref }) {\n    const draggingStructure = element.dataset.structure;\n\n    switch (draggingStructure) {\n        case \"field\": {\n            const fieldName = JSON.parse(element.dataset.drop).fieldName;\n            const field = viewEditorModel.fields[fieldName];\n            if (!fieldCanBeFilter(field)) {\n                ref.el\n                    .querySelector(`.o-web-studio-search--filters`)\n                    .classList.add(disabledDropClass);\n            }\n            if (!fieldCanBeGroupable(field)) {\n                ref.el\n                    .querySelector(`.o-web-studio-search--groupbys`)\n                    .classList.add(disabledDropClass);\n            }\n\n            break;\n        }\n        case \"separator\":\n        case \"filter\": {\n            const els = ref.el.querySelectorAll(\n                \".o-web-studio-search--fields,.o-web-studio-search--groupbys\"\n            );\n            els.forEach((el) => el.classList.add(\"o-web-studio-search--drop-disable\"));\n            break;\n        }\n    }\n\n    return () => {\n        ref.el\n            .querySelectorAll(\".o-web-studio-search--drop-disable\")\n            .forEach((el) => el.classList.remove(\"o-web-studio-search--drop-disable\"));\n    };\n};\n", "/** @odoo-module */\n\n/**\n * A list of field widget keys of the wowl's field registry (`registry.category(\"fields\")`)\n * that are safe for the user to swith to when editing a field's properties in the view editor's sidebar.\n *\n * Other widgets either don't make sense for that use because they are too specific, or they need\n * specific implementation details provided by some view to be usable.\n */\nexport const SIDEBAR_SAFE_FIELDS = [\n    \"badge\",\n    \"selection_badge\",\n    \"handle\",\n    \"percentpie\",\n    \"radio\",\n    \"selection\",\n    \"image_url\",\n    \"ace\",\n    \"priority\",\n    \"date\",\n    \"datetime\",\n    \"remaining_days\",\n    \"email\",\n    \"phone\",\n    \"url\",\n    \"binary\",\n    \"image\",\n    \"pdf_viewer\",\n    \"boolean\",\n    \"state_selection\",\n    \"boolean_toggle\",\n    \"statusbar\",\n    \"float\",\n    \"float_time\",\n    \"integer\",\n    \"monetary\",\n    \"percentage\",\n    \"progressbar\",\n    \"text\",\n    \"boolean_favorite\",\n    \"boolean_icon\",\n    \"char\",\n    \"statinfo\",\n    \"html\",\n    \"text_emojis\",\n    \"CopyClipboardChar\",\n    \"CopyClipboardText\",\n    \"CopyClipboardURL\",\n    \"char_emojis\",\n    \"many2many_tags\",\n    \"many2one\",\n    \"many2many\",\n    \"one2many\",\n    \"sms_widget\",\n    \"reference\",\n    \"daterange\",\n];\n", "/** @odoo-module */\nimport { sortBy } from \"@web/core/utils/arrays\";\nimport { registry } from \"@web/core/registry\";\nimport { SIDEBAR_SAFE_FIELDS } from \"@web_studio/client_action/view_editor/editors/sidebar_safe_fields\";\nimport { useComponent, useEffect, useRef } from \"@odoo/owl\";\n\nexport const hookPositionTolerance = 50;\n\nexport function cleanHooks(el) {\n    for (const hookEl of el.querySelectorAll(\".o_web_studio_nearest_hook\")) {\n        hookEl.classList.remove(\"o_web_studio_nearest_hook\");\n    }\n}\n\nexport function getActiveHook(el) {\n    return el.querySelector(\".o_web_studio_nearest_hook\");\n}\n\n// A naive function that determines if the toXpath on which we dropped\n// our object is actually the same as the fromXpath of the element we dropped.\n// Naive because it won't evaluate xpath, just guess whether they are equivalent\n// under precise conditions.\nexport function isToXpathEquivalentFromXpath(position, toXpath, fromXpath) {\n    if (toXpath === fromXpath) {\n        return true;\n    }\n    const toParts = toXpath.split(\"/\");\n    const fromParts = fromXpath.split(\"/\");\n\n    // Are the paths at least in the same parent node ?\n    if (toParts.slice(0, -1).join(\"/\") !== fromParts.slice(0, -1).join(\"/\")) {\n        return false;\n    }\n\n    const nodeIdxRegExp = /(\\w+)(\\[(\\d+)\\])?/;\n    const toMatch = toParts[toParts.length - 1].match(nodeIdxRegExp);\n    const fromMatch = fromParts[fromParts.length - 1].match(nodeIdxRegExp);\n\n    // Are the paths comparable in terms of their node tag ?\n    if (fromMatch[1] !== toMatch[1]) {\n        return false;\n    }\n\n    // Is the position actually referring to the same place ?\n    if (position === \"after\" && parseInt(toMatch[3] || 1) + 1 === parseInt(fromMatch[3] || 1)) {\n        return true;\n    }\n    return false;\n}\n\nexport function getHooks(el) {\n    return [...el.querySelectorAll(\".o_web_studio_hook\")];\n}\n\nexport function randomName(baseName) {\n    const random =\n        Math.floor(Math.random() * 10000).toString(32) + \"_\" + Number(new Date()).toString(32);\n    return `${baseName}_${random}`;\n}\n\n// A standardized method to determine if a component is visible\nexport function studioIsVisible(props) {\n    return props.studioIsVisible !== undefined ? props.studioIsVisible : true;\n}\n\nexport function cleanClickedElements(mainEl) {\n    for (const el of mainEl.querySelectorAll(\".o-web-studio-editor--element-clicked\")) {\n        el.classList.remove(\"o-web-studio-editor--element-clicked\");\n    }\n}\n\nexport function useStudioRef(refName = \"studioRef\", onClick) {\n    // create two hooks and call them here?\n    const comp = useComponent();\n    const ref = useRef(refName);\n    useEffect(\n        (el) => {\n            if (el) {\n                el.setAttribute(\"data-studio-xpath\", comp.props.studioXpath);\n            }\n        },\n        () => [ref.el]\n    );\n\n    if (onClick) {\n        const handler = onClick.bind(comp);\n        useEffect(\n            (el) => {\n                if (el) {\n                    el.addEventListener(\"click\", handler, { capture: true });\n                    return () => {\n                        el.removeEventListener(\"click\", handler);\n                    };\n                }\n            },\n            () => [ref.el]\n        );\n    }\n}\n\nexport function makeModelErrorResilient(ModelClass) {\n    function logError(debug) {\n        if (!debug) {\n            return;\n        }\n        console.warn(\n            \"The onchange triggered an error. It may indicate either a faulty call to onchange, or a faulty model python side\"\n        );\n    }\n    return class ResilientModel extends ModelClass {\n        setup() {\n            super.setup(...arguments);\n            const orm = this.orm;\n            const debug = this.env.debug;\n            this.orm = Object.assign(Object.create(orm), {\n                async call(model, method) {\n                    if (method === \"onchange\") {\n                        try {\n                            return await orm.call.call(orm, ...arguments);\n                        } catch {\n                            logError(debug);\n                        }\n                        return { value: {} };\n                    }\n                    return orm.call.call(orm, ...arguments);\n                },\n            });\n        }\n    };\n}\n\nexport function getWowlFieldWidgets(\n    fieldType,\n    currentKey = \"\",\n    blacklistedKeys = [],\n    debug = false\n) {\n    const wowlFieldRegistry = registry.category(\"fields\");\n    const widgets = [];\n    for (const [widgetKey, Component] of wowlFieldRegistry.getEntries()) {\n        if (widgetKey !== currentKey) {\n            // always show the current widget\n            // Widget dosn't explicitly supports the field's type\n            if (!Component.supportedTypes || !Component.supportedTypes.includes(fieldType)) {\n                continue;\n            }\n            // Widget is view-specific or is blacklisted\n            if (widgetKey.includes(\".\") || blacklistedKeys.includes(widgetKey)) {\n                continue;\n            }\n            // Widget is not whitelisted\n            if (!debug && !SIDEBAR_SAFE_FIELDS.includes(widgetKey)) {\n                continue;\n            }\n        }\n        widgets.push([widgetKey, Component.displayName]);\n    }\n    return sortBy(widgets, (el) => el[1] || el[0]);\n}\n\nexport function xpathToLegacyXpathInfo(xpath) {\n    // eg: /form[1]/field[3]\n    // RegExp notice: group 1 : form ; group 2: [1], group 3: 1\n    const xpathInfo = [];\n    const matches = xpath.matchAll(/\\/?(\\w+)(\\[(\\d+)\\])?/g);\n    for (const m of matches) {\n        const info = {\n            tag: m[1],\n            indice: parseInt(m[3] || 1),\n        };\n        xpathInfo.push(info);\n    }\n    return xpathInfo;\n}\n\nexport function fieldsToChoices(fields, filterCallback = undefined) {\n    let values = Object.values(fields);\n    if (filterCallback) {\n        values = values.filter(filterCallback);\n    }\n\n    return values.map((field) => ({\n        label: odoo.debug ? `${field.string} (${field.name})` : field.string || field.name,\n        value: field.name,\n    }));\n}\n\nexport function getStudioNoFetchFields(_fieldNodes) {\n    const fieldNames = [];\n    const fieldNodes = [];\n    Object.entries(_fieldNodes)\n        .filter(([fNode, field]) => field.attrs && field.attrs.studio_no_fetch)\n        .forEach(([fNode, field]) => {\n            fieldNames.push(field.name);\n            fieldNodes.push(fNode);\n        });\n    return {\n        fieldNames,\n        fieldNodes,\n    };\n}\n\nexport function useModelConfigFetchInvisible(model) {\n    function fixActiveFields(activeFields) {\n        const stack = [activeFields];\n        while (stack.length) {\n            const activeFields = stack.pop();\n            for (const activeField of Object.values(activeFields)) {\n                if (\"related\" in activeField) {\n                    stack.push(activeField.related.activeFields);\n                }\n                delete activeField.invisible;\n            }\n        }\n        return activeFields;\n    }\n\n    const load = model.load;\n    model.load = (...args) => {\n        fixActiveFields(model.config.activeFields);\n        return load.call(model, ...args);\n    };\n}\n\nexport function getCurrencyField(fieldsGet) {\n    const field = Object.entries(fieldsGet).find(([fName, fInfo]) => {\n        return fInfo.type === \"many2one\" && fInfo.relation === \"res.currency\";\n    });\n    if (field) {\n        return field[0];\n    }\n}\n", "/** @odoo-module */\nimport { evaluateExpr } from \"@web/core/py_js/py\";\nimport { isComponentNode, appendAttr } from \"@web/views/view_compiler\";\n\nconst nodeWeak = new WeakMap();\n\nexport function countPreviousSiblings(node) {\n    const countXpath = `count(preceding-sibling::${node.tagName})`;\n    return node.ownerDocument.evaluate(countXpath, node, null, XPathResult.NUMBER_TYPE).numberValue;\n}\n\nexport function computeXpath(node, upperBoundSelector = \"form\") {\n    if (nodeWeak.has(node)) {\n        return nodeWeak.get(node);\n    }\n    const tagName = node.tagName;\n    const count = countPreviousSiblings(node) + 1;\n\n    let xpath = `${tagName}[${count}]`;\n    const parent = node.parentElement;\n    if (!node.matches(upperBoundSelector)) {\n        const parentXpath = computeXpath(parent, upperBoundSelector);\n        xpath = `${parentXpath}/${xpath}`;\n    } else {\n        xpath = `/${xpath}`;\n    }\n    nodeWeak.set(node, xpath);\n    return xpath;\n}\n\nexport function getNodeAttributes(node) {\n    const attrs = {};\n    for (const att of node.getAttributeNames()) {\n        if (att === \"options\") {\n            attrs[att] = evaluateExpr(node.getAttribute(att));\n            continue;\n        }\n        attrs[att] = node.getAttribute(att);\n    }\n    return attrs;\n}\n\nfunction getXpathNodes(xpathResult) {\n    const nodes = [];\n    let res;\n    while ((res = xpathResult.iterateNext())) {\n        nodes.push(res);\n    }\n    return nodes;\n}\n\nexport function getNodesFromXpath(xpath, xml) {\n    const owner = \"evaluate\" in xml ? xml : xml.ownerDocument;\n    const xpathResult = owner.evaluate(xpath, xml, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    return getXpathNodes(xpathResult);\n}\n\nconst parser = new DOMParser();\nexport const parseStringToXml = (str) => {\n    return parser.parseFromString(str, \"text/xml\");\n};\n\nconst serializer = new XMLSerializer();\nexport const serializeXmlToString = (xml) => {\n    return serializer.serializeToString(xml);\n};\n\n// This function should be used in Compilers to apply the \"invisible\" modifiers on\n// the compiled templates's nodes\nexport function applyInvisible(invisible, compiled, params) {\n    // Just return the node if it is always Visible\n    if (!invisible || invisible === \"False\" || invisible === \"0\") {\n        return compiled;\n    }\n\n    let isVisileExpr;\n    // If invisible is dynamic, pass a props or apply the studio class.\n    if (invisible !== \"True\" && invisible !== \"1\") {\n        const recordExpr = params.recordExpr || \"__comp__.props.record\";\n        isVisileExpr = `!__comp__.evaluateBooleanExpr(${JSON.stringify(\n            invisible\n        )},${recordExpr}.evalContextWithVirtualIds)`;\n        if (isComponentNode(compiled)) {\n            compiled.setAttribute(\"studioIsVisible\", isVisileExpr);\n        } else {\n            appendAttr(compiled, \"class\", `o_web_studio_show_invisible:!${isVisileExpr}`);\n        }\n    } else {\n        if (isComponentNode(compiled)) {\n            compiled.setAttribute(\"studioIsVisible\", \"false\");\n        } else {\n            appendAttr(compiled, \"class\", `o_web_studio_show_invisible:true`);\n        }\n    }\n\n    // Finally, put a t-if on the node that accounts for the parameter in the config.\n    const studioShowExpr = `__comp__.viewEditorModel.showInvisible`;\n    isVisileExpr = isVisileExpr ? `(${isVisileExpr} or ${studioShowExpr})` : studioShowExpr;\n    if (compiled.hasAttribute(\"t-if\")) {\n        const formerTif = compiled.getAttribute(\"t-if\");\n        isVisileExpr = `( ${formerTif} ) and ${isVisileExpr}`;\n    }\n    compiled.setAttribute(\"t-if\", isVisileExpr);\n    return compiled;\n}\n", "/** @odoo-module */\n\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\nimport { DropdownItem } from \"@web/core/dropdown/dropdown_item\";\nimport { AutoComplete } from \"@web/core/autocomplete/autocomplete\";\nimport { Component, useState } from \"@odoo/owl\";\nimport { useOwnedDialogs, useService } from \"@web/core/utils/hooks\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { RecordSelector } from \"@web/core/record_selectors/record_selector\";\n\nexport class DialogAddNewButton extends Component {\n    static template = `web_studio.DialogNewButtonStatusBar`;\n    static components = {\n        AutoComplete,\n        Dialog,\n        Dropdown,\n        DropdownItem,\n        RecordSelector,\n    };\n    static props = {\n        model: { type: String },\n        onConfirm: { type: Function },\n        close: { type: Function },\n    };\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.state = useState({\n            action: \"\",\n            button_type: \"\",\n            actionId: false,\n            methodId: \"\",\n            methodList: [],\n            error: \"\",\n            methodChecked: false,\n        });\n    }\n\n    get multiRecordSelectorProps() {\n        return {\n            resModel: \"ir.actions.actions\",\n            update: (resId) => {\n                this.state.actionId = resId;\n            },\n            resId: this.state.actionId,\n            domain: [[\"binding_model_id\", \"=\", this.props.model]],\n        };\n    }\n\n    get title() {\n        return _t(\"Buttons Properties\");\n    }\n\n    get checkValidity() {\n        if (this.state.label?.length > 0) {\n            if (this.state.button_type === \"action\" && this.state.actionId) {\n                return false;\n            } else if (\n                this.state.methodChecked &&\n                this.state.button_type === \"object\" &&\n                this.state.methodId?.length > 0 &&\n                this.state.error?.length === 0\n            ) {\n                return false;\n            } else {\n                return true;\n            }\n        } else {\n            return true;\n        }\n    }\n    onChange() {\n        this.state.actionId = false;\n        this.state.methodId = null;\n    }\n    onConfirm() {\n        this.props.onConfirm(this.state);\n        this.props.close();\n    }\n    onCancel() {\n        this.props.close();\n    }\n    async checkMethod() {\n        this.state.error = \"\";\n        this.state.methodChecked = false;\n        if (this.state.methodId?.length > 0) {\n            if (this.state.methodId.startsWith(\"_\")) {\n                this.state.error = _t(\"The method %s is private.\", this.state.methodId);\n            } else {\n                try {\n                    await this.rpc(\"/web_studio/check_method\", {\n                        model_name: this.props.model,\n                        method_name: this.state.methodId,\n                    });\n                } catch (error) {\n                    if (error?.data?.message?.length > 0) {\n                        this.state.error = error.data.message;\n                    }\n                }\n                this.state.methodChecked = true;\n            }\n        }\n    }\n}\n\nexport class AddButtonAction extends Component {\n    static props = {};\n    static template = `web_studio.AddButtonAction`;\n    setup() {\n        this.addDialog = useOwnedDialogs();\n    }\n    onClick() {\n        this.addDialog(DialogAddNewButton, {\n            model: this.env.viewEditorModel.resModel,\n            onConfirm: (state) => {\n                const viewEditorModel = this.env.viewEditorModel;\n                const arch = viewEditorModel.xmlDoc;\n                const findHeader = arch.firstChild.querySelector(\":scope > header\");\n                if (!findHeader) {\n                    viewEditorModel.pushOperation({\n                        type: \"statusbar\",\n                        view_id: this.env.viewEditorModel.view.id,\n                    });\n                }\n                viewEditorModel.doOperation({\n                    type: \"add_button_action\",\n                    button_type: state.button_type,\n                    actionId: state.actionId,\n                    methodId: state.methodId,\n                    label: state.label,\n                });\n            },\n        });\n    }\n}\n", "/** @odoo-module */\nimport { Component, useState, xml } from \"@odoo/owl\";\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { ModelFieldSelector } from \"@web/core/model_field_selector/model_field_selector\";\nimport { useDialogConfirmation } from \"@web_studio/client_action/utils\";\nimport { useOwnedDialogs, useService } from \"@web/core/utils/hooks\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { DomainSelector } from \"@web/core/domain_selector/domain_selector\";\nimport { SelectionContentDialog } from \"@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog\";\nimport { RecordSelector } from \"@web/core/record_selectors/record_selector\";\n\nexport class SelectionValuesEditor extends Component {\n    static components = {\n        SelectionContentDialog,\n    };\n    static props = {\n        configurationModel: { type: Object },\n        confirm: { type: Function },\n        cancel: { type: Function },\n    };\n    static template = \"web_studio.SelectionValuesEditor\";\n    static Model = class SelectionValuesModel {\n        constructor() {\n            this.selection = \"[]\";\n        }\n        get isValid() {\n            return true;\n        }\n    };\n    get selection() {\n        return JSON.parse(this.props.configurationModel.selection);\n    }\n    onConfirm(choices) {\n        this.props.configurationModel.selection = JSON.stringify(choices);\n        this.props.confirm();\n    }\n}\n\nexport class RelationalFieldConfigurator extends Component {\n    static template = \"web_studio.RelationalFieldConfigurator\";\n    static components = { RecordSelector };\n    static props = {\n        configurationModel: { type: Object },\n        resModel: { type: String },\n        fieldType: { type: String },\n    };\n    static Model = class RelationalFieldModel {\n        constructor() {\n            this.relationId = false;\n        }\n        get isValid() {\n            return !!this.relationId;\n        }\n    };\n\n    setup() {\n        this.state = useState(this.props.configurationModel);\n    }\n\n    get valueSelectorProps() {\n        if (this.props.fieldType === \"one2many\") {\n            return {\n                resModel: \"ir.model.fields\",\n                domain: [\n                    [\"relation\", \"=\", this.props.resModel],\n                    [\"ttype\", \"=\", \"many2one\"],\n                    [\"model_id.abstract\", \"=\", false],\n                    [\"store\", \"=\", true],\n                ],\n                resId: this.state.relationId,\n                update: (resId) => {\n                    this.state.relationId = resId;\n                },\n            };\n        }\n        return {\n            resModel: \"ir.model\",\n            domain: [\n                [\"transient\", \"=\", false],\n                [\"abstract\", \"=\", false],\n            ],\n            resId: this.state.relationId,\n            update: (resId) => {\n                this.state.relationId = resId;\n            },\n        };\n    }\n}\n\nclass RelatedChainBuilderModel {\n    static services = [\"field\", \"dialog\"];\n\n    constructor({ services, props }) {\n        this.services = services;\n        this.relatedParams = {};\n        this.fieldInfo = { resModel: props.resModel, fieldDef: null };\n        this.resModel = props.resModel;\n    }\n\n    get isValid() {\n        return !!this.relatedParams.related;\n    }\n\n    getRelatedFieldDescription(resModel, lastField) {\n        const fieldType = lastField.type;\n        const relatedDescription = {\n            readonly: true,\n            copy: false,\n            string: lastField.string,\n            type: fieldType,\n            store: [\"one2many\", \"many2many\"].includes(fieldType) ? false : lastField.store,\n        };\n\n        if ([\"many2one\", \"many2many\", \"one2many\"].includes(fieldType)) {\n            relatedDescription.relation = lastField.relation;\n        }\n        if ([\"one2many\", \"many2many\"].includes(fieldType)) {\n            relatedDescription.relational_model = resModel;\n        }\n        if (fieldType === \"selection\") {\n            relatedDescription.selection = lastField.selection;\n        }\n        return relatedDescription;\n    }\n\n    async confirm() {\n        const relatedDescription = this.getRelatedFieldDescription(\n            this.fieldInfo.resModel,\n            this.fieldInfo.fieldDef\n        );\n        Object.assign(this.relatedParams, relatedDescription);\n        return true;\n    }\n}\n\nexport class RelatedChainBuilder extends Component {\n    static template = xml`<ModelFieldSelector resModel=\"props.resModel\" path=\"fieldChain\" readonly=\"false\" filter.bind=\"filter\" update.bind=\"updateChain\" />`;\n    static components = { ModelFieldSelector };\n    static props = {\n        resModel: { type: String },\n        configurationModel: { type: Object },\n    };\n    static Model = RelatedChainBuilderModel;\n\n    setup() {\n        this.state = useState(this.props.configurationModel);\n        this.relatedParams.related = \"\";\n    }\n\n    get relatedParams() {\n        return this.state.relatedParams;\n    }\n\n    get fieldChain() {\n        return this.relatedParams.related;\n    }\n\n    filter(fieldDef, path) {\n        if (!path) {\n            return fieldDef.type === \"many2one\";\n        }\n        return fieldDef.type !== \"properties\";\n    }\n\n    async updateChain(path, fieldInfo) {\n        this.relatedParams.related = path;\n        this.state.fieldInfo = fieldInfo;\n    }\n}\n\nfunction useConfiguratorModel(Model, props) {\n    const services = Object.fromEntries(\n        (Model.services || []).map((servName) => {\n            let serv;\n            if (servName === \"dialog\") {\n                serv = { add: useOwnedDialogs() };\n            } else {\n                serv = useService(servName);\n            }\n            return [servName, serv];\n        })\n    );\n\n    const model = new Model({ services, props });\n    return useState(model);\n}\n\nexport class FieldConfigurationDialog extends Component {\n    static props = {\n        confirm: { type: Function },\n        cancel: { type: Function },\n        close: { type: Function },\n        Component: { type: Function },\n        componentProps: { type: Object, optional: true },\n        fieldType: { type: String, optional: true },\n        isDialog: { type: Boolean, optional: true },\n        title: { type: String, optional: true },\n        size: { type: String, optional: true },\n    };\n    static template = \"web_studio.FieldConfigurationDialog\";\n    static components = { Dialog };\n\n    setup() {\n        const { confirm, cancel } = useDialogConfirmation({\n            confirm: async () => {\n                let confirmValues = false;\n                if (!this.configurationModel.isValid) {\n                    return false;\n                }\n                if (this.configurationModel.confirm) {\n                    const res = await this.configurationModel.confirm();\n                    if (res || res === undefined) {\n                        confirmValues = this.configurationModel;\n                    }\n                } else {\n                    confirmValues = this.configurationModel;\n                }\n                return this.props.confirm(confirmValues);\n            },\n            cancel: () => this.props.cancel(),\n        });\n        this.confirm = confirm;\n        this.cancel = cancel;\n        this.configurationModel = useConfiguratorModel(\n            this.Component.Model,\n            this.props.componentProps\n        );\n    }\n\n    get title() {\n        if (this.props.title) {\n            return this.props.title;\n        }\n        if (this.props.fieldType) {\n            return _t(\"Field properties: %s\", this.props.fieldType);\n        }\n        return \"\";\n    }\n\n    get Component() {\n        return this.props.Component;\n    }\n\n    get canConfirm() {\n        return this.configurationModel.isValid;\n    }\n}\n\nexport class FilterConfiguration extends Component {\n    static components = { DomainSelector };\n    static template = \"web_studio.FilterConfiguration\";\n    static props = {\n        resModel: { type: String },\n        configurationModel: { type: Object },\n    };\n    static Model = class FilterConfigurationModel {\n        constructor() {\n            this.filterLabel = \"\";\n            this.domain = \"[]\";\n        }\n\n        get isValid() {\n            return !!this.filterLabel;\n        }\n    };\n\n    setup() {\n        this.state = useState(this.props.configurationModel);\n    }\n\n    get domainSelectorProps() {\n        return {\n            resModel: this.props.resModel,\n            readonly: false,\n            domain: this.state.domain,\n            update: (domainStr) => {\n                this.state.domain = domainStr;\n            },\n            isDebugMode: !!this.env.debug,\n        };\n    }\n}\n", "/** @odoo-module */\n\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useSortable } from \"@web/core/utils/sortable_owl\";\n\nimport { Component, useRef, useState } from \"@odoo/owl\";\n\nexport class SelectionContentDialog extends Component {\n    static components = {\n        Dialog,\n    };\n    static defaultProps = {\n        defaultChoices: [],\n    };\n    static props = {\n        defaultChoices: { type: Array, optional: true },\n        onConfirm: { type: Function },\n        close: { type: Function },\n    };\n    static template = \"web_studio.SelectionContentDialog\";\n\n    setup() {\n        this.state = useState({\n            choices: this.props.defaultChoices,\n        });\n        this.localState = useState({\n            _newItem: [],\n            editedItem: null,\n        });\n\n        const itemsList = useRef(\"itemsList\");\n        useSortable({\n            enable: () => !this.editedItem,\n            handle: \".o-draggable-handle\",\n            ref: itemsList,\n            elements: \".o-draggable\",\n            cursor: \"move\",\n            onDrop: (params) => this.resequenceItems(params),\n        });\n\n        this.oldValue = new WeakMap();\n    }\n\n    getSelectionFromItem(item) {\n        if (item.id === \"new\") {\n            return this.localState._newItem;\n        }\n        return this.selection[item.id];\n    }\n\n    get selection() {\n        return this.state.choices;\n    }\n\n    set selection(items) {\n        this.state.choices = items;\n    }\n\n    get title() {\n        return _t(\"Field Properties\");\n    }\n\n    selectionToItem(selection, params = {}) {\n        return Object.assign(\n            {\n                id: \"new\",\n                key: selection[0],\n                name: selection[0],\n                label: selection[1],\n                isDraggable: false,\n                isRemovable: false,\n                isInEdition: false,\n            },\n            params\n        );\n    }\n\n    get selectionToItems() {\n        const inEdition = !!this.editedItem;\n        return this.selection.map((sel, index) => {\n            return this.selectionToItem(sel, {\n                id: index,\n                key: inEdition ? index : sel[0],\n                isInEdition:\n                    this.editedItem?.id === this.selection.indexOf(sel) && !this.shouldFullEdit,\n                isDraggable: !inEdition,\n                isRemovable: !inEdition,\n            });\n        });\n    }\n\n    get newItem() {\n        return this.selectionToItem(this.localState._newItem, { isInEdition: true, id: \"new\" });\n    }\n\n    get editedItem() {\n        return this.localState.editedItem;\n    }\n\n    get shouldFullEdit() {\n        return Boolean(this.env.debug);\n    }\n\n    ensureUnique(item) {\n        const value = item[0];\n        if (!value) {\n            return false;\n        }\n\n        const otherElements = this.selection.filter((i) => i !== item);\n        if (otherElements.some((i) => i[0] === value)) {\n            return false;\n        }\n        return true;\n    }\n\n    setItemValue(item, value) {\n        if (item.id !== \"new\" && item.id !== this.editedItem.id) {\n            return;\n        }\n        const isEditingLabel = item.id !== \"new\";\n        item = this.getSelectionFromItem(item);\n        item[0] = isEditingLabel ? this.editedItem.name : value;\n        item[1] = value;\n    }\n\n    addItem(item) {\n        if (!this.ensureUnique(item)) {\n            return;\n        }\n        this.selection.push(item);\n        this.localState._newItem = [];\n    }\n\n    removeItem(item) {\n        this.selection = this.selection.filter((i) => i[0] !== item.name);\n    }\n\n    editItem(item) {\n        const selItem = this.getSelectionFromItem(item);\n        if (item.id === \"new\") {\n            return this.addItem(selItem);\n        }\n        if (this.editedItem?.id === item.id) {\n            if (!this.ensureUnique(selItem)) {\n                return;\n            }\n            this.localState.editedItem = null;\n            this.oldValue.delete(selItem);\n            return;\n        }\n        this.oldValue.set(selItem, [...selItem]);\n        this.localState.editedItem = item;\n    }\n\n    discardItemChanges(item) {\n        if (item.id === \"new\") {\n            return this.setItemValue(item, \"\");\n        }\n        const selItem = this.getSelectionFromItem(item);\n        const oldValue = this.oldValue.get(selItem);\n        selItem[0] = oldValue[0];\n        selItem[1] = oldValue[1];\n        this.localState.editedItem = null;\n    }\n\n    resequenceItems(params) {\n        const { previous, next, element } = params;\n        const itemId = parseInt(element.dataset.itemId);\n\n        let items = this.selection;\n        const item = items[itemId];\n        items = items.filter((i) => i !== item);\n\n        let toIndex;\n        if (previous) {\n            toIndex = parseInt(previous.dataset.itemId) + 1;\n        } else if (next) {\n            toIndex = parseInt(next.dataset.itemId);\n        }\n        items.splice(toIndex, 0, item);\n        this.selection = items;\n    }\n\n    async onConfirm() {\n        if (this.newItem.name?.length) {\n            this.editItem(this.newItem);\n        }\n        await this.props.onConfirm(this.selection);\n        this.props.close();\n    }\n\n    onKeyPressed(item, key) {\n        if (key === \"Enter\") {\n            this.editItem(item);\n        }\n    }\n}\n", "/** @odoo-module */\nimport { Component, toRaw } from \"@odoo/owl\";\n\nimport { closest, touching } from \"@web/core/utils/ui\";\nimport { useDraggable } from \"@web/core/utils/draggable\";\nimport { useOwnedDialogs, useService } from \"@web/core/utils/hooks\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport {\n    isToXpathEquivalentFromXpath,\n    cleanHooks,\n    getActiveHook,\n    getCurrencyField,\n    getHooks,\n    hookPositionTolerance,\n    randomName,\n} from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport {\n    FieldConfigurationDialog,\n    SelectionValuesEditor,\n    RelationalFieldConfigurator,\n    RelatedChainBuilder,\n    FilterConfiguration,\n} from \"@web_studio/client_action/view_editor/interactive_editor/field_configuration/field_configuration\";\nimport {\n    getNodesFromXpath,\n    countPreviousSiblings,\n} from \"@web_studio/client_action/view_editor/editors/xml_utils\";\nimport { DefaultViewSidebar } from \"@web_studio/client_action/view_editor/default_view_sidebar/default_view_sidebar\";\n\nconst NO_M2O_AVAILABLE = _t(`\n    There are no many2one fields related to the current model.\n    To create a one2many field on the current model, you must first create its many2one counterpart on the model you want to relate to.\n`);\n\nfunction copyElementOnDrag() {\n    let element;\n    let copy;\n\n    function clone(_element) {\n        element = _element;\n        copy = element.cloneNode(true);\n    }\n\n    function insert() {\n        if (element) {\n            element.insertAdjacentElement(\"beforebegin\", copy);\n        }\n    }\n\n    function clean() {\n        if (copy) {\n            copy.remove();\n        }\n        copy = null;\n        element = null;\n    }\n\n    return { clone, insert, clean };\n}\n\nexport class InteractiveEditor extends Component {\n    static template = \"web_studio.InteractiveEditor\";\n    static components = {};\n    static props = {\n        editor: true,\n        slots: { type: Object },\n        editorContainerRef: { type: Object },\n        rendererRef: { type: Object },\n    };\n\n    setup() {\n        this.defaultSidebar = DefaultViewSidebar;\n\n        this.action = useService(\"action\");\n        this.orm = useService(\"orm\");\n        this.addDialog = useOwnedDialogs();\n        this.notification = useService(\"notification\");\n        /* DagDrop: from sidebar to View, and within the view */\n        const getNearestHook = this.getNearestHook.bind(this);\n        // Those are fine because editor defines the t-key\n        const prepareForDrag = this.props.editor.prepareForDrag;\n        const isValidHook = this.props.editor.isValidHook || (() => true);\n        const styleNearestHook =\n            this.props.editor.styleNearestHook ||\n            ((ref, hook) => {\n                hook.classList.add(\"o_web_studio_nearest_hook\");\n            });\n\n        function removeBootStrapClasses(element) {\n            const bootstrapClasses = Array.from(element.classList).filter(\n                (c) => c.startsWith(\"position-\") || c.startsWith(\"w-\") || c.startsWith(\"h-\")\n            );\n            if (!bootstrapClasses.length) {\n                return () => {};\n            }\n            element.classList.remove(...bootstrapClasses);\n            return () => {\n                element.classList.add(...bootstrapClasses);\n            };\n        }\n\n        let cleanUps;\n        const copyOnDrag = copyElementOnDrag();\n        useDraggable({\n            ref: this.props.editorContainerRef,\n            elements: \".o-draggable\",\n            onWillStartDrag: ({ element }) => {\n                cleanUps = [];\n                if (element.closest(\".o_web_studio_component\")) {\n                    copyOnDrag.clone(element);\n                }\n            },\n            onDragStart: ({ element }) => {\n                cleanUps.push(removeBootStrapClasses(element));\n                copyOnDrag.insert();\n                if (prepareForDrag) {\n                    cleanUps.push(\n                        prepareForDrag({\n                            element,\n                            viewEditorModel: this.viewEditorModel,\n                            ref: this.props.editorContainerRef,\n                        })\n                    );\n                }\n            },\n            onDrag: ({ x, y, element }) => {\n                cleanHooks(this.viewRef.el);\n                element.classList.remove(\"o-draggable--drop-ready\");\n                const hook = getNearestHook(element, { x, y });\n                if (!hook) {\n                    return;\n                }\n                if (!isValidHook({ hook, element, viewEditorModel: this.viewEditorModel })) {\n                    return;\n                }\n                styleNearestHook(this.props.rendererRef, hook);\n                element.classList.add(\"o-draggable--drop-ready\");\n            },\n            onDrop: ({ element }) => {\n                const targetHook = getActiveHook(this.viewRef.el);\n                if (!targetHook) {\n                    return;\n                }\n                const { xpath, position, type, infos } = targetHook.dataset;\n                const droppedData = element.dataset;\n\n                const isNew = element.classList.contains(\"o_web_studio_component\");\n                const structure = isNew ? droppedData.structure : \"field\"; // only fields can be moved\n\n                if (isNew) {\n                    this.addStructure(structure, droppedData.drop, {\n                        xpath,\n                        position,\n                        type,\n                        infos,\n                    });\n                } else {\n                    this.moveStructure(structure, droppedData, { xpath, position });\n                }\n            },\n            onDragEnd: ({ element }) => {\n                cleanHooks(this.viewRef.el);\n                if (cleanUps) {\n                    cleanUps.forEach((c) => c());\n                    cleanUps = null;\n                }\n                copyOnDrag.clean();\n            },\n        });\n\n        this.applyAutoClick = () => {\n            if (!this.autoClick) {\n                return;\n            }\n\n            const { targetInfo, tag, attrs } = this.autoClick;\n\n            // First step: locate node in new arch\n            let xpathToClick = targetInfo.xpath;\n            if (tag) {\n                // We are trying to select a new node of which targetInfo could be its parent\n                if (targetInfo.position !== \"inside\") {\n                    xpathToClick = xpathToClick.split(\"/\").slice(0, -1).join(\"/\");\n                }\n\n                const attrForXpath = Object.entries(attrs)\n                    .filter(([, value]) => !!value)\n                    .map(([attName, value]) => {\n                        return `@${attName}='${value}'`;\n                    })\n                    .join(\" and \");\n                const nodeXpath = `${tag}[${attrForXpath}]`;\n                const fullXpath = `${xpathToClick}/${nodeXpath}`;\n\n                const nodes = getNodesFromXpath(fullXpath, toRaw(this.viewEditorModel).xmlDoc);\n                this.autoClick = null; // Early reset of that variable\n                if (nodes.length !== 1) {\n                    return;\n                }\n                const atPosition = countPreviousSiblings(nodes[0]) + 1;\n                xpathToClick = `${xpathToClick}/${tag}[${atPosition}]`;\n            }\n\n            // Second step: locate corresponding dom element\n            const domEl = this.props.rendererRef.el.querySelector(\n                `[data-studio-xpath='${xpathToClick}'], [studioxpath='${xpathToClick}']`\n            );\n            if (domEl) {\n                domEl.click();\n            }\n        };\n    }\n\n    get viewEditorModel() {\n        return this.env.viewEditorModel;\n    }\n\n    get viewRef() {\n        return this.viewEditorModel.viewRef;\n    }\n\n    getNearestHook(draggedEl, { x, y }) {\n        const viewRefEl = this.viewRef.el;\n        cleanHooks(viewRefEl);\n\n        const mouseToleranceRect = {\n            x: x - hookPositionTolerance,\n            y: y - hookPositionTolerance,\n            width: hookPositionTolerance * 2,\n            height: hookPositionTolerance * 2,\n        };\n\n        const touchingEls = touching(getHooks(viewRefEl), mouseToleranceRect);\n        const closestHookEl = closest(touchingEls, { x, y });\n\n        return closestHookEl;\n    }\n\n    openViewInForm() {\n        return this.action.doAction(\n            {\n                type: \"ir.actions.act_window\",\n                res_model: \"ir.ui.view\",\n                res_id: this.env.viewEditorModel.mainView.id,\n                views: [[false, \"form\"]],\n                target: \"current\",\n            },\n            { clearBreadcrumbs: true }\n        );\n    }\n\n    openDefaultValues() {\n        const resModel = this.env.viewEditorModel.resModel;\n        this.action.doAction(\n            {\n                name: _t(\"Default Values\"),\n                type: \"ir.actions.act_window\",\n                res_model: \"ir.default\",\n                target: \"current\",\n                views: [\n                    [false, \"list\"],\n                    [false, \"form\"],\n                ],\n                domain: [[\"field_id.model\", \"=\", resModel]],\n            },\n            { clearBreadcrumbs: true }\n        );\n    }\n\n    setAutoClick(targetInfo, nodeDescr) {\n        if (!targetInfo) {\n            this.autoClick = null;\n            return;\n        }\n        if (targetInfo && !nodeDescr) {\n            this.autoClick = {\n                targetInfo,\n            };\n            return;\n        }\n        let nameAttr = nodeDescr.attrs.name;\n        if (nodeDescr.tag === \"field\" && !nameAttr) {\n            nameAttr = nodeDescr.field_description.name;\n        }\n        this.autoClick = {\n            targetInfo,\n            tag: nodeDescr.tag,\n            attrs: { name: nameAttr },\n        };\n    }\n\n    async addField(droppedData, targetInfo) {\n        const data = JSON.parse(droppedData);\n        const isExistingField = \"fieldName\" in data;\n\n        let newNode;\n        if (!isExistingField) {\n            newNode = await this.getNewFieldNode(data);\n        } else {\n            newNode = {\n                tag: \"field\",\n                attrs: { name: data.fieldName },\n            };\n\n            const field = this.viewEditorModel.fields[data.fieldName];\n            if (field.type === \"monetary\") {\n                this.setCurrencyInfos(newNode.attrs);\n            }\n        }\n        if (!newNode) {\n            return;\n        }\n        if (!isExistingField) {\n            this.viewEditorModel.setRenameableField(newNode.field_description?.name, true);\n        }\n\n        if (this.viewEditorModel.viewType === \"kanban\") {\n            newNode.attrs.display = \"full\";\n        }\n\n        if (this.viewEditorModel.viewType === \"list\") {\n            newNode.attrs.optional = \"show\";\n        }\n\n        const operation = {\n            node: newNode,\n            target: this.viewEditorModel.getFullTarget(targetInfo.xpath),\n            position: targetInfo.position,\n            type: \"add\",\n        };\n        this.setAutoClick(targetInfo, newNode);\n        return this.viewEditorModel.doOperation(operation);\n    }\n\n    async addStructure(structure, droppedData, targetInfo) {\n        if (structure === \"field\" && ![\"groupBy\", \"filter\"].includes(targetInfo.type)) {\n            // AddField in form,list,kanban\n            return this.addField(droppedData, targetInfo);\n        }\n\n        if ([\"notebook\", \"group\", \"separator\"].includes(structure)) {\n            // Add specific structure that don't need configuration (form, search)\n            const operation = {\n                node: {\n                    tag: structure,\n                    attrs: {\n                        name: randomName(`studio_${structure}`),\n                    },\n                },\n                target: this.viewEditorModel.getFullTarget(targetInfo.xpath),\n                position: targetInfo.position,\n                type: \"add\",\n            };\n            this.setAutoClick(targetInfo, operation.node);\n            return this.viewEditorModel.doOperation(operation);\n        }\n\n        if (structure === \"filter\") {\n            // For search editor\n            const filterData = await new Promise((resolve) => {\n                this.addDialog(FieldConfigurationDialog, {\n                    title: _t(\"New Filter\"),\n                    size: \"md\",\n                    confirm: (data) => resolve(data),\n                    cancel: () => resolve(false),\n                    Component: FilterConfiguration,\n                    componentProps: { resModel: this.viewEditorModel.resModel },\n                });\n            });\n            if (!filterData) {\n                return;\n            }\n            const node = {\n                tag: \"filter\",\n                attrs: {\n                    domain: filterData.domain,\n                    name: randomName(\"studio_filter\"),\n                    string: filterData.filterLabel,\n                },\n            };\n            const operation = {\n                node,\n                target: this.viewEditorModel.getFullTarget(targetInfo.xpath),\n                position: targetInfo.position,\n                type: \"add\",\n            };\n            this.setAutoClick(targetInfo, operation.node);\n            return this.viewEditorModel.doOperation(operation);\n        }\n\n        if (\n            this.viewEditorModel.viewType === \"search\" &&\n            structure === \"field\" &&\n            [\"groupBy\", \"filter\"].includes(targetInfo.type)\n        ) {\n            // Add field as a filter or as a groupBy, for search editor\n            const fieldName = JSON.parse(droppedData).fieldName;\n            const fieldGet = this.viewEditorModel.fields[fieldName];\n            const willBeGroupBy = targetInfo.type === \"groupBy\";\n\n            const node = {\n                tag: \"filter\",\n                attrs: {\n                    name: randomName(`studio_${willBeGroupBy ? \"group\" : \"filter\"}_by`),\n                    string: fieldGet.string,\n                },\n            };\n\n            if (willBeGroupBy) {\n                node.attrs.context = `{'group_by': '${fieldName}'}`;\n                if (targetInfo.infos && JSON.parse(targetInfo.infos).create_group) {\n                    node.attrs.create_group = true;\n                }\n            } else {\n                node.attrs.date = fieldName;\n            }\n            const operation = {\n                node,\n                target: this.viewEditorModel.getFullTarget(targetInfo.xpath),\n                position: targetInfo.position,\n                type: \"add\",\n            };\n            this.setAutoClick(targetInfo, operation.node);\n            return this.viewEditorModel.doOperation(operation);\n        }\n    }\n\n    async getNewFieldNode(data) {\n        const string = _t(\"New %s\", data.string);\n\n        const newNode = {\n            field_description: {\n                field_description: string,\n                name: randomName(`x_studio_${data.fieldType}_field`),\n                type: data.fieldType,\n                model_name: this.viewEditorModel.resModel,\n                special: data.special,\n            },\n            tag: \"field\",\n            attrs: { widget: data.widget },\n        };\n\n        if (data.special === \"lines\") {\n            return newNode;\n        }\n\n        const fieldType = data.fieldType;\n        if (fieldType === \"selection\" && data.widget === \"priority\") {\n            // should not be translated at the creation\n            newNode.field_description.selection = [\n                [\"0\", \"Normal\"],\n                [\"1\", \"Low\"],\n                [\"2\", \"High\"],\n                [\"3\", \"Very High\"],\n            ];\n            return newNode;\n        }\n\n        if ([\"selection\", \"one2many\", \"many2one\", \"many2many\", \"related\"].includes(fieldType)) {\n            if (fieldType === \"one2many\") {\n                const count = await this.orm.searchCount(\"ir.model.fields\", [\n                    [\"relation\", \"=\", this.viewEditorModel.resModel],\n                    [\"ttype\", \"=\", \"many2one\"],\n                    [\"store\", \"=\", true],\n                ]);\n                if (!count) {\n                    this.addDialog(ConfirmationDialog, {\n                        title: _t(\"No related many2one fields found\"),\n                        body: NO_M2O_AVAILABLE,\n                        confirm: async () => {},\n                    });\n                    return;\n                }\n            }\n\n            const fieldParams = await this.openFieldConfiguration(fieldType);\n            if (!fieldParams) {\n                return;\n            }\n            if (fieldType === \"selection\") {\n                newNode.field_description.selection = fieldParams.selection;\n            }\n            if (fieldType === \"one2many\") {\n                newNode.field_description.relation_field_id = fieldParams.relationId;\n            }\n            if (fieldType === \"many2many\" || fieldType === \"many2one\") {\n                newNode.field_description.relation_id = fieldParams.relationId;\n            }\n            if (fieldType === \"related\") {\n                Object.assign(newNode.field_description, fieldParams.relatedParams);\n                if (!newNode.field_description.related) {\n                    delete newNode.field_description.related;\n                }\n            }\n        }\n\n        if (fieldType === \"monetary\" || (fieldType === \"related\" && newNode.field_description?.type === 'monetary')) {\n            this.setCurrencyInfos(newNode.field_description);\n        }\n\n        if (fieldType === \"integer\") {\n            newNode.field_description.default_value = \"0\";\n        }\n\n        return newNode;\n    }\n\n    openFieldConfiguration(fieldType) {\n        let dialogProps;\n        if (fieldType === \"selection\") {\n            dialogProps = {\n                Component: SelectionValuesEditor,\n                isDialog: true,\n            };\n        } else if ([\"one2many\", \"many2many\", \"many2one\"].includes(fieldType)) {\n            dialogProps = {\n                Component: RelationalFieldConfigurator,\n                componentProps: { fieldType, resModel: this.viewEditorModel.resModel },\n            };\n        } else if (fieldType === \"related\") {\n            dialogProps = {\n                Component: RelatedChainBuilder,\n                componentProps: {\n                    resModel: this.viewEditorModel.resModel,\n                },\n            };\n        }\n\n        const fieldParams = new Promise((resolve, reject) => {\n            this.addDialog(FieldConfigurationDialog, {\n                fieldType,\n                confirm: async (params) => {\n                    resolve(params);\n                },\n                cancel: () => resolve(false),\n                ...dialogProps,\n            });\n        });\n        return fieldParams;\n    }\n\n    moveStructure(structure, droppedData, targetInfo) {\n        if (structure !== \"field\") {\n            throw Error(\"Moving anything else than a field is not supported\");\n        }\n\n        if (\n            isToXpathEquivalentFromXpath(\n                targetInfo.position,\n                targetInfo.xpath,\n                droppedData.studioXpath\n            )\n        ) {\n            return;\n        }\n\n        const operation = {\n            type: \"move\",\n            node: this.viewEditorModel.getFullTarget(droppedData.studioXpath),\n            target: this.viewEditorModel.getFullTarget(targetInfo.xpath),\n            position: targetInfo.position,\n        };\n        const subViewXpath = this.viewEditorModel.getSubviewXpath();\n        if (subViewXpath) {\n            operation.node.subview_xpath = subViewXpath;\n        }\n\n        if (this.viewEditorModel.activeNodeXpath === droppedData.studioXpath) {\n            this.setAutoClick(targetInfo, operation.node);\n        }\n        this.viewEditorModel.doOperation(operation);\n    }\n\n    setCurrencyInfos(object) {\n        const currencyField = getCurrencyField(this.viewEditorModel.fields);\n        if (currencyField) {\n            object.currency_field = currencyField;\n            object.currency_in_view = this.viewEditorModel.fieldsInArch.includes(currencyField);\n        }\n    }\n}\n", "/** @odoo-module */\nimport { _t } from \"@web/core/l10n/translation\";\nimport { onWillStart, useState, onWillUpdateProps, Component } from \"@odoo/owl\";\n\nimport { Notebook } from \"@web/core/notebook/notebook\";\nimport { useBus } from \"@web/core/utils/hooks\";\n\nconst tabsDisplay = {\n    new: {\n        class: \"o_web_studio_new px-2\",\n        title: _t(\"Add\"),\n    },\n    view: {\n        class: \"o_web_studio_view px-2\",\n        title: _t(\"View\"),\n    },\n    properties: {\n        class: \"o_web_studio_properties px-2\",\n        title: _t(\"Properties\"),\n    },\n};\n\nexport class InteractiveEditorSidebar extends Component {\n    static components = { Notebook };\n    static template = \"web_studio.ViewEditor.InteractiveEditorSidebar\";\n    static props = {\n        slots: { type: Object },\n    };\n\n    setup() {\n        this.editorModel = useState(this.env.viewEditorModel);\n        this.tabsDisplay = tabsDisplay;\n        useBus(this.editorModel.bus, \"error\", () => this.render(true));\n\n        this._defaultTab = this.computeDefaultTab(this.props);\n        this.editorModel.sidebarTab = this._defaultTab;\n\n        onWillStart(() => {\n            this.editorModel.resetSidebar();\n        });\n        onWillUpdateProps(() => {\n            // This component takes slots: it is always re-rendered\n            const editorModel = this.editorModel;\n            if (editorModel.sidebarTab === \"properties\" && !editorModel.activeNode) {\n                editorModel.resetSidebar();\n            }\n        });\n    }\n\n    get icons() {\n        return {\n            new: \"fa-plus\",\n            view: \"fa-television\",\n            properties: \"fa-server\",\n        };\n    }\n\n    computeDefaultTab(props) {\n        const slots = props.slots;\n        const defaults = Object.keys(slots).filter((s) => slots[s].isDefault);\n        if (defaults.length) {\n            return defaults[0];\n        }\n        return \"new\" in slots ? \"new\" : \"view\";\n    }\n\n    get defaultTab() {\n        return this.editorModel.sidebarTab || this._defaultTab;\n    }\n\n    onTabClicked(tab) {\n        if (tab !== \"properties\") {\n            this.editorModel.resetSidebar(tab);\n        }\n        this.editorModel.sidebarTab = tab;\n    }\n}\n", "/** @odoo-module */\n\nimport { Component, onWillStart, onWillUpdateProps, useState, toRaw } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { SelectionContentDialog } from \"@web_studio/client_action/view_editor/interactive_editor/field_configuration/selection_content_dialog\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { LimitGroupVisibility } from \"../limit_group_visibility/limit_group_visibility\";\nimport { TypeWidgetProperties } from \"./type_widget_properties\";\nimport { SidebarPropertiesToolbox } from \"../sidebar_properties_toolbox/sidebar_properties_toolbox\";\nimport { ModifiersProperties } from \"../modifiers/modifiers_properties\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\n\nclass TechnicalName extends Component {\n    static props = {\n        node: { type: Object },\n    };\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Field.TechnicalName\";\n    static components = { Property };\n\n    setup() {\n        this.renameField = (value) => {\n            return this.env.viewEditorModel.renameField(\n                this.props.node.attrs.name,\n                `x_studio_${value}`,\n                { autoUnique: false }\n            );\n        };\n    }\n\n    get canEdit() {\n        return (\n            this.env.debug && this.env.viewEditorModel.isFieldRenameable(this.props.node.attrs.name)\n        );\n    }\n\n    get fieldName() {\n        const fName = this.props.node.attrs.name;\n        if (this.canEdit) {\n            return fName.split(\"x_studio_\")[1];\n        }\n        return fName;\n    }\n}\n\nexport class FieldProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Field\";\n    static props = {\n        node: { type: Object },\n        availableOptions: { type: Array, optional: true },\n    };\n    static components = {\n        LimitGroupVisibility,\n        Property,\n        TechnicalName,\n        TypeWidgetProperties,\n        SidebarPropertiesToolbox,\n        ModifiersProperties,\n    };\n\n    setup() {\n        this.dialog = useService(\"dialog\");\n        this.rpc = useService(\"rpc\");\n        this.state = useState({});\n        this.editNodeAttributes = useEditNodeAttributes();\n        onWillStart(async () => {\n            if (this.canShowDefaultValue) {\n                this.state.defaultValue = await this.getDefaultValue(this.props.node);\n            }\n        });\n\n        onWillUpdateProps(async (nextProps) => {\n            if (this._canShowDefaultValue(nextProps.node)) {\n                this.state.defaultValue = await this.getDefaultValue(nextProps.node);\n            }\n        });\n    }\n\n    get viewEditorModel() {\n        return this.env.viewEditorModel;\n    }\n\n    async onChangeFieldString(value) {\n        if (this.viewEditorModel.isFieldRenameable(this.props.node.field.name) && value) {\n            return this.viewEditorModel.renameField(this.props.node.attrs.name, value, {\n                label: value,\n            });\n        } else {\n            const operation = {\n                new_attrs: { string: value },\n                type: \"attributes\",\n                position: \"attributes\",\n                target: this.viewEditorModel.getFullTarget(this.viewEditorModel.activeNodeXpath),\n            };\n            // FIXME: the python API is messy: we need to send node, which is the same as target since\n            // we are editing the target's attributes, to be able to modify the python field's string\n            operation.node = operation.target;\n            return this.viewEditorModel.doOperation(operation);\n        }\n    }\n\n    onChangeAttribute(value, name) {\n        return this.editNodeAttributes({ [name]: value });\n    }\n\n    onChangeDefaultValue(value) {\n        this.rpc(\"/web_studio/set_default_value\", {\n            model_name: this.env.viewEditorModel.resModel,\n            field_name: this.props.node.field.name,\n            value,\n        });\n    }\n\n    async getDefaultValue(node) {\n        const defaultValueObj = await this.rpc(\"/web_studio/get_default_value\", {\n            model_name: this.env.viewEditorModel.resModel,\n            field_name: node.field.name,\n        });\n        return defaultValueObj.default_value;\n    }\n\n    get optionalVisibilityChoices() {\n        return {\n            choices: [\n                { label: _t(\"Show by default\"), value: \"show\" },\n                { label: _t(\"Hide by default\"), value: \"hide\" },\n            ],\n        };\n    }\n\n    get defaultValuesInputType() {\n        const node = this.props.node;\n        return node.attrs?.widget === \"statusbar\"\n            ? \"selection\"\n            : node.attrs.widget || node.field.type;\n    }\n\n    get defaultValuesChoices() {\n        if (this.props.node.field.selection) {\n            return {\n                choices: this.props.node.field.selection.map(([value, label]) => {\n                    return {\n                        label,\n                        value,\n                    };\n                }),\n            };\n        }\n        return undefined;\n    }\n\n    _canShowDefaultValue(node) {\n        if (/^(in_group_|sel_groups_)/.test(node.attrs.name)) {\n            return false;\n        }\n        return ![\"image\", \"many2many\", \"many2one\", \"binary\"].includes(node.field.type);\n    }\n\n    get canShowDefaultValue() {\n        return this._canShowDefaultValue(this.props.node);\n    }\n\n    get canEditSelectionChoices() {\n        return this.props.node.field.manual && this.props.node.field.type === \"selection\";\n    }\n\n    /**\n     * @param {string} name of the attribute\n     * @returns if this attribute supported in the current view\n     */\n    isAttributeSupported(name) {\n        return this.props.availableOptions?.includes(name);\n    }\n\n    editSelectionChoices() {\n        const field = this.props.node.field;\n        this.dialog.add(SelectionContentDialog, {\n            defaultChoices: toRaw(field).selection.map((s) => [...s]),\n            onConfirm: async (choices) => {\n                const result = await this.rpc(\"/web_studio/edit_field\", {\n                    model_name: this.env.viewEditorModel.resModel,\n                    field_name: field.name,\n                    values: { selection: JSON.stringify(choices) },\n                    force_edit: false,\n                });\n                let reflectChanges = !result;\n                if (result && result.records_linked) {\n                    reflectChanges = false;\n                    await new Promise((resolve) => {\n                        this.dialog.add(ConfirmationDialog, {\n                            body:\n                                result.message ||\n                                _t(\"Are you sure you want to remove the selection values?\"),\n                            confirm: async () => {\n                                await this.rpc(\"/web_studio/edit_field\", {\n                                    model_name: this.env.viewEditorModel.resModel,\n                                    field_name: field.name,\n                                    values: { selection: JSON.stringify(choices) },\n                                    force_edit: true,\n                                });\n                                reflectChanges = true;\n                                resolve();\n                            },\n                            cancel: () => resolve(),\n                        });\n                    });\n                }\n                if (reflectChanges) {\n                    field.selection = choices;\n                }\n            },\n        });\n    }\n}\n", "/** @odoo-module */\n\nimport { _t } from \"@web/core/l10n/translation\";\n\n/**\n * This object describes the properties editable in studio, depending on\n * one or more attribute of a field. The TypeWidgetProperties component will\n * retrieve the value by itself, or you can set a function with the `getValue`\n * key to compute it specifically for one editable property.\n */\nexport const EDITABLE_ATTRIBUTES = {\n    context: {\n        name: \"context\",\n        label: _t(\"Context\"),\n        type: \"string\",\n    },\n    domain: {\n        name: \"domain\",\n        label: _t(\"Domain\"),\n        type: \"domain\",\n        getValue({ attrs, field }) {\n            return {\n                domain: attrs.domain,\n                relation: field.relation,\n            };\n        },\n    },\n    aggregate: {\n        name: \"aggregate\",\n        label: _t(\"Aggregate\"),\n        type: \"selection\",\n        choices: [\n            { value: \"sum\", label: _t(\"Sum\") },\n            { value: \"avg\", label: _t(\"Average\") },\n            { value: \"none\", label: _t(\"No aggregation\") },\n        ],\n        getValue({ attrs }) {\n            return attrs.sum ? \"sum\" : attrs.avg ? \"avg\" : \"none\";\n        },\n    },\n    placeholder: {\n        name: \"placeholder\",\n        label: _t(\"Placeholder\"),\n        type: \"string\",\n    },\n};\n\nexport const FIELD_TYPE_ATTRIBUTES = {\n    char: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n    },\n    date: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n    },\n    datetime: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n    },\n    float: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n        list: [EDITABLE_ATTRIBUTES.aggregate],\n    },\n    html: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n    },\n    integer: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n        list: [EDITABLE_ATTRIBUTES.aggregate],\n    },\n    many2many: {\n        common: [EDITABLE_ATTRIBUTES.domain, EDITABLE_ATTRIBUTES.context],\n    },\n    many2one: {\n        common: [\n            EDITABLE_ATTRIBUTES.domain,\n            EDITABLE_ATTRIBUTES.context,\n            EDITABLE_ATTRIBUTES.placeholder,\n        ],\n    },\n    monetary: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n        list: [EDITABLE_ATTRIBUTES.aggregate],\n    },\n    selection: {\n        common: [EDITABLE_ATTRIBUTES.placeholder],\n    },\n};\n\n/**\n * Computed Options are options that are tied to another option.\n * Their value and visibility depends on another option present in the sidebar.\n *\n * They must be documented using 'supportedOptions' on any field widget.\n * Then, register them under COMPUTED_DISPLAY_OPTIONS using the technical name of the option.\n *\n * Here is how to declare them :\n *\n *      COMPUTED_DISPLAY_OPTIONS = {\n *          dependent_option: {\n *              superOption (string): technical name of another option that has an impact on the dependent option.\n *                                      This option must also be documented under 'supportedOptions'.\n *              getValue (function): compute the value of the dependent option from super option value\n *              getReadonly (function): compute a boolean based on the super value.\n *                                      If true, the option is greyed out and it is not possible to interact with them.\n *                                      Otherwise, the dependent option can still be edited.\n *              getInvisible (function): compute a boolean based on the super value.\n *                                      If true, the option is not present in the sidebar.\n *          },\n *          ...\n *      }\n *\n */\n\nexport const COMPUTED_DISPLAY_OPTIONS = {\n    collaborative_trigger: {\n        superOption: \"collaborative\",\n        getInvisible: (value) => !value,\n    },\n    no_quick_create: {\n        superOption: \"no_create\",\n        getValue: (value) => value,\n        getReadonly: (value) => value,\n    },\n    no_create_edit: {\n        superOption: \"no_create\",\n        getValue: (value) => value,\n        getReadonly: (value) => value,\n    },\n    decimals: {\n        superOption: \"human_readable\",\n        getInvisible: (value) => !value,\n    },\n    zoom_delay: {\n        superOption: \"zoom\",\n        getInvisible: (value) => !value,\n    },\n    dynamic_placeholder_model_reference_field: {\n        superOption: \"dynamic_placeholder\",\n        getInvisible: (value) => !value,\n    },\n    edit_max_value: {\n        superOption: \"editable\",\n        getInvisible: (value) => !value,\n    },\n    no_edit_color: {\n        superOption: \"color_field\",\n        getInvisible: (value) => !value,\n    },\n};\n", "/** @odoo-module */\n\nimport { Component, onWillStart, onWillUpdateProps, useState } from \"@odoo/owl\";\nimport { registry } from \"@web/core/registry\";\nimport { Property } from \"@web_studio/client_action/view_editor/property/property\";\nimport { getWowlFieldWidgets } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport {\n    EDITABLE_ATTRIBUTES,\n    FIELD_TYPE_ATTRIBUTES,\n    COMPUTED_DISPLAY_OPTIONS,\n} from \"./field_type_properties\";\nimport { useService } from \"@web/core/utils/hooks\";\n\nexport class TypeWidgetProperties extends Component {\n    static template =\n        \"web_studio.ViewEditor.InteractiveEditorProperties.Field.TypeWidgetProperties\";\n    static components = { Property };\n    static props = {\n        node: { type: Object },\n        onChangeAttribute: { type: Function },\n    };\n\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.orm = useService(\"orm\");\n        this.attributes = useState({\n            field: [],\n            selection: [],\n            boolean: [],\n            domain: [],\n            number: [],\n            string: [],\n            digits: [],\n        });\n\n        onWillStart(async () => {\n            await this.computeAttributesList(this.props);\n        });\n\n        onWillUpdateProps(async (nextProps) => {\n            await this.computeAttributesList(nextProps);\n        });\n    }\n\n    async computeAttributesList(props) {\n        this.attributesForCurrentTypeAndWidget = this.getAttributesForCurrentTypeAndWidget(props);\n        await this.groupAttributesPerType(props);\n    }\n\n    async groupAttributesPerType(props) {\n        this.attributes.field = await this.getAttributesOfTypeField(props);\n        this.attributes.selection = this.getWidgetAttributes(\"selection\", props);\n        this.attributes.boolean = this.getWidgetAttributes(\"boolean\", props);\n        this.attributes.domain = this.getWidgetAttributes(\"domain\", props);\n        this.attributes.number = this.getWidgetAttributes(\"number\", props);\n        this.attributes.string = this.getWidgetAttributes(\"string\", props);\n        this.attributes.digits = this.getWidgetAttributes(\"digits\", props);\n    }\n\n    async getAttributesOfTypeField(props) {\n        const fieldAttributes = this.getWidgetAttributes(\"field\", props);\n        if (fieldAttributes.length) {\n            const fields = Object.entries(this.env.viewEditorModel.fields).map(([key, value]) => {\n                return {\n                    ...value,\n                    name: value.name || key,\n                };\n            });\n            // for each attribute looking for a field, compute the choices to display in the SelectMenu\n            await Promise.all(\n                fieldAttributes.map(async (attribute) => {\n                    const choices = await this.getFieldChoices(attribute, fields);\n                    attribute.choices = choices;\n                    this.getOptionObj(attribute.name).choices = choices;\n                })\n            );\n            return fieldAttributes;\n        }\n        return [];\n    }\n\n    getSupportedOptions(props) {\n        const widgetName = props.node.attrs?.widget || props.node.field.type;\n        const fieldRegistry = registry.category(\"fields\").content;\n        const widgetDescription =\n            fieldRegistry[this.env.viewEditorModel.viewType + \".\" + widgetName] ||\n            fieldRegistry[widgetName];\n        return (\n            widgetDescription?.[1].supportedOptions?.filter(\n                (o) => !o.viewTypes || o.viewTypes.includes(this.env.viewEditorModel.viewType)\n            ) || []\n        );\n    }\n\n    /**\n     * @returns the list of available widgets for the current node\n     */\n    get widgetChoices() {\n        const widgets = getWowlFieldWidgets(\n            this.props.node.field.type,\n            this.props.node.attrs.widget,\n            [],\n            this.env.debug\n        );\n        return {\n            choices: widgets.map(([value, label]) => {\n                label = label ? label : \"\";\n                return {\n                    label: `${label} (${value})`.trim(),\n                    value,\n                };\n            }),\n        };\n    }\n\n    /**\n     * @returns the list of attributes available depending the type of field,\n     * as well the current widget selected\n     */\n    _getAttributesForCurrentTypeAndWidget(props) {\n        const fieldType = props.node.field.type;\n        const { viewType } = this.env.viewEditorModel;\n\n        const fieldCommonViewsProperties = FIELD_TYPE_ATTRIBUTES[fieldType]?.common || [];\n        const fieldSpecificViewProperties = FIELD_TYPE_ATTRIBUTES[fieldType]?.[viewType] || [];\n\n        return [\n            ...fieldCommonViewsProperties,\n            ...fieldSpecificViewProperties,\n            // create a deep copy of the options description to avoid modifying the original objects\n            ...JSON.parse(JSON.stringify(this.getSupportedOptions(props))),\n        ];\n    }\n\n    getAttributesForCurrentTypeAndWidget(props) {\n        const _attributes = this._getAttributesForCurrentTypeAndWidget(props);\n        _attributes.forEach((property) => {\n            if (COMPUTED_DISPLAY_OPTIONS[property.name]) {\n                const dependentOption = COMPUTED_DISPLAY_OPTIONS[property.name];\n                const superOption = _attributes.find((o) => o.name === dependentOption.superOption);\n                property.isSubOption = true;\n                if (!superOption.subOptions) {\n                    superOption.subOptions = [];\n                }\n                if (!superOption.subOptions.includes(property.name)) {\n                    // only add the subOption if not already present\n                    superOption.subOptions.push(property.name);\n                }\n            }\n        });\n        return _attributes;\n    }\n\n    getOptionObj(optionName) {\n        return this.attributesForCurrentTypeAndWidget.find((o) => o.name === optionName);\n    }\n\n    /**\n     * @param {string} type of the attribute (eg. \"string\", \"boolean\" )\n     * @returns only the given type of attributes for the current field node\n     */\n    getWidgetAttributes(type, props) {\n        return this.attributesForCurrentTypeAndWidget\n            .filter((attribute) => attribute.type === type)\n            .map((attribute) => {\n                if (EDITABLE_ATTRIBUTES[attribute.name]) {\n                    return this.getPropertyFromAttributes(attribute, props);\n                }\n                return this.getPropertyFromOptions(attribute, props);\n            })\n            .filter((attribute) => attribute !== undefined);\n    }\n\n    async getFieldChoices(attribute, fields) {\n        let availableFields = fields;\n        // Specific code to filter available fields to display is handled here as supportedOptions\n        // is a generic description and don't allow to describe the full spec of an option\n        if (attribute.name === \"fold_field\") {\n            if (this.env.viewEditorModel.activeNode.field.type === \"selection\") {\n                // fold_field is only relevant with relational status with its own model\n                attribute.isInvisible = true;\n                return [];\n            }\n            const fields = await this.orm.call(\n                this.env.viewEditorModel.activeNode.field.relation,\n                \"fields_get\"\n            );\n            availableFields = Object.values(fields);\n        } else if (attribute.name === \"currency_field\") {\n            availableFields = availableFields.filter((f) => f.relation === \"res.currency\");\n        }\n        if (attribute.availableTypes) {\n            availableFields = availableFields.filter(\n                (f) =>\n                    attribute.availableTypes.includes(f.type) &&\n                    f.name !== this.env.viewEditorModel.activeNode.attrs.name\n            );\n        }\n        return availableFields.map((f) => {\n            return {\n                label: this.env.debug ? `${f.string} (${f.name})` : f.string,\n                value: f.name,\n            };\n        });\n    }\n\n    /**\n     * Compute the property and its value from one or more attributes on the node\n     */\n    getPropertyFromAttributes(property, props) {\n        let value;\n        value = props.node.attrs[property.name];\n        if (property.getValue) {\n            const attrs = props.node.attrs || {};\n            const field = props.node.field || {};\n            value = property.getValue({ attrs, field });\n        }\n        if (value === undefined && property.default) {\n            value = property.default;\n        }\n        return {\n            ...property,\n            value,\n        };\n    }\n\n    /**\n     * Compute the property and its value from the `options` attribute on the node\n     */\n    getPropertyFromOptions(property, props) {\n        let value;\n        if (COMPUTED_DISPLAY_OPTIONS[property.name]) {\n            // The display of this property must be computed from the value of the corresponding super option\n            const dependentOption = COMPUTED_DISPLAY_OPTIONS[property.name];\n            const superOption = this.getOptionObj(dependentOption.superOption);\n            const superValue = this.getPropertyFromOptions(superOption, props).value;\n            if (dependentOption.getReadonly) {\n                property.isReadonly = dependentOption.getReadonly(superValue);\n            }\n            if (dependentOption.getValue) {\n                property.value = dependentOption.getValue(superValue);\n                if (property.isReadonly) {\n                    // The property value cannot be edited, return the computed value directly\n                    return property;\n                }\n            }\n            if (dependentOption.getInvisible) {\n                property.isInvisible = dependentOption.getInvisible(superValue);\n            }\n        }\n        value = props.node.attrs.options?.[property.name];\n        if (property.type === \"string\") {\n            value = JSON.stringify(value);\n        }\n        if (value === undefined && property.default) {\n            value = property.default;\n        }\n        if (property.name === \"currency_field\" && !value) {\n            value = props.node.field.currency_field;\n        }\n        return {\n            ...property,\n            value,\n        };\n    }\n\n    getSelectValue(value) {\n        return typeof value === \"object\" ? JSON.stringify(value) : value;\n    }\n\n    async onChangeCurrency(value) {\n        const proms = [];\n        proms.push(\n            this.rpc(\"/web_studio/set_currency\", {\n                model_name: this.env.viewEditorModel.resModel,\n                field_name: this.props.node.field.name,\n                value,\n            })\n        );\n        this.env.viewEditorModel.fields[this.props.node.field.name][\"currency_field\"] = value;\n\n        if (this.env.viewEditorModel.fieldsInArch.includes(value)) {\n            // is the new currency in the view ?\n            await Promise.all(proms).then((results) => {\n                if (results[0] === true) {\n                    this.env.viewEditorModel.fields[this.props.node.field.name][\"currency_field\"] =\n                        value;\n                }\n            });\n            // alter the value of the currently selected currency manually to trigger a re-render of the SelectMenu\n            // with the correct value since we don't pass through doOperations from the ViewEditorModel\n            this.attributes.field = this.attributes.field.map((e) => {\n                if (e.name === \"currency_field\") {\n                    e.value = value;\n                }\n                return e;\n            });\n            return;\n        }\n\n        const currencyNode = {\n            tag: \"field\",\n            attrs: { name: value },\n        };\n\n        const operation = {\n            node: currencyNode,\n            target: this.env.viewEditorModel.getFullTarget(\n                this.env.viewEditorModel.activeNodeXpath\n            ),\n            position: \"after\",\n            type: \"add\",\n        };\n\n        proms.push(this.env.viewEditorModel.doOperation(operation));\n        await Promise.all(proms).then((results) => {\n            if (results[0] === true) {\n                this.env.viewEditorModel.fields[this.props.node.field.name][\"currency_field\"] =\n                    value;\n            }\n        });\n    }\n\n    onChangeWidget(value) {\n        return this.props.onChangeAttribute(value, \"widget\");\n    }\n\n    async onChangeProperty(value, name) {\n        if (name === \"show_time\" && !value && this.props.node.field.type === \"datetime\" && !this.props.node.attrs.widget) {\n            this.onChangeWidget(\"datetime\")\n        }\n        else if (name === \"currency_field\" && this.props.node.field.type === \"monetary\") {\n            await this.onChangeCurrency(value);\n            if (!this.props.node.attrs.options?.[name]) {\n                return;\n            }\n            value = \"\"; // the currency_field arch option will be deleted\n        }\n        if (EDITABLE_ATTRIBUTES[name]) {\n            return this.props.onChangeAttribute(value, name);\n        }\n        const currentProperty = this.getOptionObj(name);\n        const options = { ...this.props.node.attrs.options };\n        if (value || currentProperty.type === \"boolean\") {\n            if (currentProperty.type === \"digits\") {\n                // The digits options is composed of two integers.\n                // The first one is unused and the second one is passed to `toFixed`\n                // from `formatFloat`. It should be an integer between 0 and 20.\n                value = Number(value);\n                if (!Number.isInteger(value) || value < 0 || value > 20) {\n                    return;\n                }\n                options[name] = [value * 2, value];\n            } else if ([\"[\", \"{\"].includes(value[0]) || !isNaN(value)) {\n                options[name] = JSON.parse(value);\n            } else if (currentProperty.type === \"number\") {\n                options[name] = Number(value);\n            } else {\n                options[name] = value;\n            }\n        } else {\n            delete options[name];\n        }\n        this.props.onChangeAttribute(JSON.stringify(options), \"options\");\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { Record } from \"@web/model/record\";\nimport { useEditNodeAttributes } from \"@web_studio/client_action/view_editor/view_editor_model\";\nimport { MultiRecordSelector } from \"@web/core/record_selectors/multi_record_selector\";\n\nexport class LimitGroupVisibility extends Component {\n    static template = \"web_studio.ViewEditor.LimitGroupVisibility\";\n    static components = {\n        Record,\n        MultiRecordSelector,\n    };\n    static props = {\n        node: { type: Object },\n    };\n\n    setup() {\n        this.editNodeAttributes = useEditNodeAttributes();\n    }\n\n    onChangeAttribute(value, name) {\n        return this.editNodeAttributes({ [name]: value });\n    }\n\n    get multiRecordSelectorProps() {\n        const resIds = JSON.parse(this.props.node.attrs.studio_groups || \"[]\").map(\n            (group) => group.id\n        );\n        return {\n            resModel: \"res.groups\",\n            resIds,\n            update: (resIds) => {\n                this.onChangeAttribute(resIds, \"groups\");\n            },\n        };\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { CheckBox } from \"@web/core/checkbox/checkbox\";\nimport { useOwnedDialogs } from \"@web/core/utils/hooks\";\nimport { ExpressionEditorDialog } from \"@web/core/expression_editor_dialog/expression_editor_dialog\";\n\nexport class ModifiersProperties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Modifiers\";\n    static components = { CheckBox };\n    static props = {\n        node: { type: Object },\n        availableOptions: { type: Array },\n    };\n\n    setup() {\n        this.addDialog = useOwnedDialogs();\n    }\n\n    /**\n     * @param {string} name of the attribute\n     * @returns if this attribute supported in the current view\n     */\n    isAttributeSupported(name) {\n        return this.props.availableOptions?.includes(name);\n    }\n\n    // <tag invisible=\"EXPRESSION\"  />\n    onChangeModifier(name, value) {\n        const isTypeBoolean = typeof value === \"boolean\";\n        const encodesBoolean = isTypeBoolean || this.isBooleanExpression(value);\n        const isTruthy = encodesBoolean ? this.isBoolTrue(value) : !!value;\n        const newAttrs = {};\n        const oldAttrs = { ...this.props.node.attrs };\n\n        const changingInvisible = name === \"invisible\";\n        const isInList = this.env.viewEditorModel.viewType === \"list\";\n\n        if (encodesBoolean) {\n            if (changingInvisible && isInList) {\n                if (isTruthy) {\n                    newAttrs[\"column_invisible\"] = \"True\";\n                } else {\n                    newAttrs[\"column_invisible\"] = \"False\";\n                    newAttrs[\"invisible\"] = \"False\";\n                }\n            } else {\n                newAttrs[name] = isTruthy ? \"True\" : \"False\";\n            }\n        } else {\n            newAttrs[name] = value;\n            if (changingInvisible && isInList && \"column_invisible\" in oldAttrs) {\n                newAttrs[\"column_invisible\"] = \"False\";\n            }\n        }\n\n        if (this.env.viewEditorModel.viewType === \"form\" && name === \"readonly\") {\n            newAttrs.force_save = isTruthy ? \"1\" : \"0\";\n        }\n\n        const operation = {\n            new_attrs: newAttrs,\n            type: \"attributes\",\n            position: \"attributes\",\n            target: this.env.viewEditorModel.getFullTarget(\n                this.env.viewEditorModel.activeNodeXpath\n            ),\n        };\n        this.env.viewEditorModel.doOperation(operation);\n    }\n\n    getCheckboxClassName(value) {\n        if (value && !this.isBooleanExpression(value)) {\n            return \"o_web_studio_checkbox_indeterminate\";\n        }\n    }\n\n    isBooleanExpression(expression) {\n        return [\"1\", \"0\", \"True\", \"true\", \"False\", \"false\"].includes(expression);\n    }\n\n    isBoolTrue(value) {\n        if (typeof value === \"boolean\") {\n            return value;\n        }\n        return [\"1\", \"True\", \"true\"].includes(value);\n    }\n\n    valueAsBoolean(expression) {\n        if (!expression) {\n            return false;\n        }\n        if (this.isBooleanExpression(expression)) {\n            return this.isBoolTrue(expression);\n        }\n        return true;\n    }\n\n    onConditionalButtonClicked(name, value) {\n        if (typeof value !== \"string\" || value === \"\") {\n            value = \"False\"; // See py.js:evaluateBooleanExpr default value is False\n        }\n        const { fields, resModel, fieldsInArch } = this.env.viewEditorModel;\n        this.addDialog(ExpressionEditorDialog, {\n            resModel,\n            fields: Object.fromEntries([\"id\", ...fieldsInArch].map((name) => [name, fields[name]])),\n            expression: value,\n            onConfirm: (expression) => this.onChangeModifier(name, expression),\n        });\n    }\n}\n", "/** @odoo-module */\n\nimport { Component, useState, xml } from \"@odoo/owl\";\nimport { SidebarPropertiesToolbox } from \"@web_studio/client_action/view_editor/interactive_editor/properties/sidebar_properties_toolbox/sidebar_properties_toolbox\";\n\nclass DefaultProperties extends Component {\n    static props = {\n        node: { type: Object },\n    };\n    static template = xml`\n        <SidebarPropertiesToolbox/>\n    `;\n    static components = { SidebarPropertiesToolbox };\n}\n\nexport class Properties extends Component {\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties\";\n    static props = {\n        propertiesComponents: { type: Object },\n    };\n    static components = { DefaultProperties };\n\n    setup() {\n        this.viewEditorModel = useState(this.env.viewEditorModel);\n    }\n\n    get node() {\n        return this.viewEditorModel.activeNode;\n    }\n\n    get propertiesComponent() {\n        return this.props.propertiesComponents[this.nodeType] || {};\n    }\n\n    get nodeType() {\n        return this.node?.arch.tagName;\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport { _t } from \"@web/core/l10n/translation\";\n\nexport class SidebarPropertiesToolbox extends Component {\n    static props = {};\n    static template = \"web_studio.ViewEditor.InteractiveEditorProperties.Toolbox\";\n\n    setup() {\n        this.orm = useService(\"orm\");\n        this.action = useService(\"action\");\n        this.dialog = useService(\"dialog\");\n    }\n\n    get node() {\n        return this.env.viewEditorModel.activeNode;\n    }\n\n    get nodeType() {\n        return this.node.arch.tagName;\n    }\n\n    onRemoveFromView() {\n        let nodeHumanName = this.nodeType;\n        if (this.nodeType === \"t\" && this.node.attrs[\"t-name\"] === \"kanban-menu\") {\n            nodeHumanName = _t(\"dropdown\");\n        }\n\n        this.dialog.add(ConfirmationDialog, {\n            body: _t(\"Are you sure you want to remove this %s from the view?\", nodeHumanName),\n            confirm: () => {\n                return this.removeNodeFromArch();\n            },\n            cancel: () => {},\n        });\n    }\n\n    async openFormAction() {\n        const resId = await this.orm.searchRead(\n            \"ir.model.fields\",\n            [\n                [\"model\", \"=\", this.env.viewEditorModel.resModel],\n                [\"name\", \"=\", this.node.field.name],\n            ],\n            [\"id\"]\n        );\n        return this.action.doAction(\n            {\n                type: \"ir.actions.act_window\",\n                res_model: \"ir.model.fields\",\n                res_id: resId[0].id,\n                views: [[false, \"form\"]],\n                target: \"current\",\n            },\n            { clearBreadcrumbs: true }\n        );\n    }\n\n    removeNodeFromArch(xpath) {\n        const target = this.env.viewEditorModel.getFullTarget(xpath || this.node.xpath);\n        const operation = {\n            type: \"remove\",\n            target,\n        };\n        this.env.viewEditorModel.resetSidebar();\n        return this.env.viewEditorModel.doOperation(operation);\n    }\n}\n", "/** @odoo-module */\nimport { Component } from \"@odoo/owl\";\n\nexport class SidebarViewToolbox extends Component {\n    static template = \"web_studio.ViewEditor.ViewToolbox\";\n    static props = {\n        canEditXml: { type: Boolean, optional: true },\n        onMore: { type: Function, optional: true },\n        openDefaultValues: { type: Function, optional: true },\n        canEditDefaultValues: { type: Boolean, optional: true },\n    };\n}\n", "/** @odoo-module */\n\nexport function viewGroupByOperation(viewType, type, newValue, oldValue = undefined) {\n    const operation_type = newValue ? \"add\" : \"remove\";\n    const operation = {\n        target: {\n            view_type: viewType,\n            field_names: [operation_type === \"add\" ? newValue : oldValue],\n            operation_type,\n            field_type: type,\n        },\n        type: \"graph_pivot_groupbys_fields\",\n    };\n\n    if (oldValue && newValue) {\n        operation.target.operation_type = \"replace\";\n        operation.target.old_field_names = oldValue;\n    }\n\n    return operation;\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { CheckBox } from \"@web/core/checkbox/checkbox\";\nimport { DomainSelectorDialog } from \"@web/core/domain_selector_dialog/domain_selector_dialog\";\nimport { SelectMenu } from \"@web/core/select_menu/select_menu\";\nimport { useService } from \"@web/core/utils/hooks\";\n\nexport class Property extends Component {\n    static template = \"web_studio.Property\";\n    static components = { CheckBox, SelectMenu, DomainSelectorDialog };\n    static defaultProps = {\n        childProps: {},\n        class: \"\",\n    };\n    static props = {\n        name: { type: String },\n        type: { type: String },\n        value: { optional: true },\n        onChange: { type: Function, optional: true },\n        childProps: { type: Object, optional: true },\n        class: { type: String, optional: true },\n        isReadonly: { type: Boolean, optional: true },\n        slots: {\n            type: Object,\n            optional: true,\n        },\n        tooltip: { type: String, optional: true },\n        inputAttributes: { type: Object, optional: true },\n    };\n\n    setup() {\n        this.dialog = useService(\"dialog\");\n    }\n\n    get className() {\n        const propsClass = this.props.class ? this.props.class : \"\";\n        return `o_web_studio_property_${this.props.name} ${propsClass}`;\n    }\n\n    onDomainClicked() {\n        this.dialog.add(DomainSelectorDialog, {\n            resModel: this.props.childProps.relation,\n            domain: this.props.value || \"[]\",\n            isDebugMode: !!this.env.debug,\n            onConfirm: (domain) => this.props.onChange(domain, this.props.name),\n        });\n    }\n\n    onViewOptionChange(value) {\n        this.props.onChange(value, this.props.name);\n    }\n}\n", "/** @odoo-module */\n\nimport { WithSearch } from \"@web/search/with_search/with_search\";\nimport { cleanClickedElements } from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { Component, onError, onMounted, toRaw, useRef, xml, useSubEnv, useEffect } from \"@odoo/owl\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { _t } from \"@web/core/l10n/translation\";\n\nconst HEIGHT = \"height: 100%;\";\n\nexport class StudioView extends Component {\n    static props = { autoClick: { type: Function, optional: true }, \"*\": true }; // Same as View.js. This is just a wrapper\n    setup() {\n        this.notification = useService(\"notification\");\n        this.style = this.props.setOverlay ? `pointer-events: none; ${HEIGHT}` : HEIGHT;\n        this.withSearchProps = {\n            resModel: this.props.resModel,\n            SearchModel: this.props.SearchModel,\n            context: this.props.context,\n            domain: this.props.domain,\n            globalState: this.props.globalState,\n            searchViewArch: this.props.searchViewArch,\n            searchViewFields: this.props.searchViewFields,\n            irFilters: this.props.searchViewIrFilters,\n            display: this.props.display,\n        };\n        this.viewEditorModel = this.env.viewEditorModel;\n\n        this.viewRenderer = useRef(\"viewRenderer\");\n\n        this.controllerProps = { ...this.viewEditorModel.controllerProps };\n\n        useEffect(\n            (xpath) => {\n                if (xpath) {\n                    this.updateActiveNode({ xpath, resetSidebarOnNotFound: true });\n                }\n            },\n            () => [this.viewEditorModel.activeNodeXpath]\n        );\n\n        const rawModel = toRaw(this.viewEditorModel);\n        useEffect(\n            () => {\n                rawModel.isInEdition = false;\n            },\n            () => [rawModel.isInEdition]\n        );\n\n        onError((error) => {\n            if (rawModel.isInEdition) {\n                this.notification.add(\n                    _t(\n                        \"The requested change caused an error in the view. It could be because a field was deleted, but still used somewhere else.\"\n                    ),\n                    {\n                        type: \"danger\",\n                        title: _t(\"Error\"),\n                    }\n                );\n                this.viewEditorModel.resetSidebar(\"view\");\n                this.viewEditorModel._operations.undo(false);\n            } else {\n                throw error;\n            }\n        });\n\n        const config = {\n            ...this.env.config,\n            onNodeClicked: (xpath) => {\n                if (this.updateActiveNode({ xpath })) {\n                    this.viewEditorModel.activeNodeXpath = xpath;\n                }\n            },\n        };\n\n        if (this.props.autoClick) {\n            onMounted(() => this.props.autoClick());\n        }\n\n        useSubEnv({\n            config,\n            __beforeLeave__: null,\n            __getGlobalState__: null,\n            __getLocalState__: null,\n            __getContext__: null,\n            __getOrderBy__: null,\n        });\n    }\n\n    updateActiveNode({ xpath, resetSidebarOnNotFound = false }) {\n        const vem = this.env.viewEditorModel;\n        cleanClickedElements(this.viewRenderer.el);\n        const el = this.viewRenderer.el.querySelector(\n            `[data-studio-xpath=\"${xpath}\"], [studioxpath=\"${xpath}\"]`\n        );\n        if (!el) {\n            if (resetSidebarOnNotFound) {\n                vem.resetSidebar();\n            }\n            return false;\n        }\n        if (vem.editorInfo.editor.styleClickedElement) {\n            vem.editorInfo.editor.styleClickedElement(this.viewRenderer, { xpath });\n            return true;\n        }\n        const clickable = el.closest(\".o-web-studio-editor--element-clickable\");\n        if (clickable) {\n            clickable.classList.add(\"o-web-studio-editor--element-clicked\");\n        }\n        return true;\n    }\n}\nStudioView.components = { WithSearch };\nStudioView.template = xml`\n    <div t-att-style=\"style\" class=\"w-100\" t-ref=\"viewRenderer\">\n        <WithSearch t-props=\"withSearchProps\" t-slot-scope=\"search\">\n            <t t-component=\"viewEditorModel.editorInfo.editor.Controller\" t-props=\"Object.assign(controllerProps, search)\" />\n        </WithSearch>\n    </div>\n`;\n", "/** @odoo-module */\nimport { Component, onWillUpdateProps, useState, useSubEnv, useRef } from \"@odoo/owl\";\n\nimport { useBus, useService } from \"@web/core/utils/hooks\";\nimport { registry } from \"@web/core/registry\";\nimport { StudioView } from \"@web_studio/client_action/view_editor/studio_view\";\n\nimport { InteractiveEditor } from \"./interactive_editor/interactive_editor\";\nimport { useViewEditorModel } from \"./view_editor_hook\";\nimport { standardActionServiceProps } from \"@web/webclient/actions/action_service\";\nimport { getDefaultConfig } from \"@web/views/view\";\n\nimport { XmlResourceEditor } from \"@web_studio/client_action/xml_resource_editor/xml_resource_editor\";\n\nclass ViewXmlEditor extends XmlResourceEditor {\n    static props = { ...XmlResourceEditor.props, studioViewArch: { type: String } };\n    setup() {\n        super.setup();\n        this.viewEditorModel = this.env.viewEditorModel;\n        useBus(this.viewEditorModel.bus, \"error\", () => this.render(true));\n        this.studioViewState = useState({ arch: this.props.studioViewArch });\n\n        onWillUpdateProps((nextProps) => {\n            if (nextProps.studioViewArch !== this.props.studioViewArch) {\n                const studioResource = this.getStudioResource(this.state.resourcesOptions);\n                if (studioResource) {\n                    studioResource.value.arch = nextProps.studioViewArch;\n                }\n            }\n        });\n    }\n\n    getStudioResource(resourcesOptions) {\n        return resourcesOptions.find((opt) => opt.value.id === this.viewEditorModel.studioViewId);\n    }\n}\n\nexport class ViewEditor extends Component {\n    static props = { ...standardActionServiceProps };\n    static components = { StudioView, InteractiveEditor, ViewXmlEditor };\n    static template = \"web_studio.ViewEditor\";\n\n    setup() {\n        /* Services */\n        this.studio = useService(\"studio\");\n        this.user = useService(\"user\");\n        this.rpc = useService(\"rpc\");\n        this.orm = useService(\"orm\");\n        /* MISC */\n        // Avoid pollution from the real actionService's env\n        // Set config compatible with View.js\n        useSubEnv({ config: getDefaultConfig() });\n\n        // Usefull for drag/drop\n        this.rootRef = useRef(\"root\");\n        this.rendererRef = useRef(\"viewRenderer\");\n\n        this.viewEditorModel = useViewEditorModel(this.rendererRef);\n    }\n\n    get interactiveEditorKey() {\n        const { viewType, breadcrumbs } = this.viewEditorModel;\n        let key = viewType;\n        if (breadcrumbs.length > 1) {\n            key += `_${breadcrumbs.length}`;\n        }\n        return key;\n    }\n\n    onSaveXml({ resourceId, oldCode, newCode }) {\n        this.viewEditorModel.doOperation({\n            type: \"replace_arch\",\n            viewId: resourceId,\n            oldArch: oldCode,\n            newArch: newCode,\n        });\n    }\n\n    onXmlEditorClose() {\n        this.viewEditorModel.switchMode();\n    }\n}\nregistry.category(\"actions\").add(\"web_studio.view_editor\", ViewEditor);\n", "/** @odoo-module */\nimport {\n    onWillDestroy,\n    onWillStart,\n    status,\n    useComponent,\n    useEnv,\n    useState,\n    useSubEnv,\n} from \"@odoo/owl\";\nimport { useOwnedDialogs, useService } from \"@web/core/utils/hooks\";\nimport { viewTypeToString } from \"@web_studio/studio_service\";\nimport {\n    useEditorBreadcrumbs,\n    useEditorMenuItem,\n} from \"@web_studio/client_action/editor/edition_flow\";\nimport { ViewEditorModel } from \"./view_editor_model\";\nimport { ViewEditorSnackbar } from \"./view_editor_snackbar\";\n\nexport function useViewEditorModel(viewRef) {\n    const env = useEnv();\n\n    /* Services */\n    const services = Object.fromEntries(\n        [\"user\", \"rpc\", \"orm\", \"ui\", \"notification\"].map((sName) => {\n            return [sName, useService(sName)];\n        })\n    );\n    // Capture studio's state as a new Object. This is due to concurrency\n    // issues because we are an action, and rendering may be caused by other things (reactives)\n    services.studio = { ...env.services.studio };\n    services.dialog = { add: useOwnedDialogs() };\n\n    /* Coordination */\n    // Communicates with editorMenu, provides standard server calls\n    const editionFlow = useState(env.editionFlow);\n    useEditorBreadcrumbs({ name: viewTypeToString(services.studio.editedViewType) });\n\n    const viewEditorModel = new ViewEditorModel({\n        env,\n        services,\n        editionFlow,\n        viewRef,\n    });\n    useSubEnv({ viewEditorModel });\n\n    const { _snackBar, _operations } = viewEditorModel;\n    useEditorMenuItem({\n        component: ViewEditorSnackbar,\n        props: { operations: _operations, saveIndicator: _snackBar },\n    });\n\n    const component = useComponent();\n    onWillStart(async () => {\n        return new Promise((resolve, reject) => {\n            viewEditorModel\n                .load()\n                .then(resolve)\n                .catch((error) => {\n                    if (status(component) !== \"destroyed\") {\n                        reject(error);\n                    }\n                });\n        });\n    });\n\n    onWillDestroy(() => {\n        viewEditorModel.isInEdition = false;\n    });\n    return useState(viewEditorModel);\n}\n\nexport function useSnackbarWrapper(fn) {\n    const env = useEnv();\n    return env.viewEditorModel._decorateFunction(fn);\n}\n", "/** @odoo-module */\nimport { registry } from \"@web/core/registry\";\nimport { SearchModel } from \"@web/search/search_model\";\nimport {\n    computeXpath,\n    getNodesFromXpath,\n    getNodeAttributes,\n    parseStringToXml,\n    serializeXmlToString,\n} from \"@web_studio/client_action/view_editor/editors/xml_utils\";\nimport { EventBus, markRaw, useEnv, reactive, toRaw } from \"@odoo/owl\";\nimport { sprintf } from \"@web/core/utils/strings\";\nimport { parseXML } from \"@web/core/utils/xml\";\nimport { viewTypeToString } from \"@web_studio/studio_service\";\nimport {\n    xpathToLegacyXpathInfo,\n    cleanClickedElements,\n} from \"@web_studio/client_action/view_editor/editors/utils\";\nimport { Reactive, getFieldsInArch, memoizeOnce } from \"@web_studio/client_action/utils\";\nimport { getModifier, resetViewCompilerCache } from \"@web/views/view_compiler\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { EditorOperations, SnackbarIndicator } from \"@web_studio/client_action/editor/edition_flow\";\nimport { Race } from \"@web/core/utils/concurrency\";\nimport { AlertDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\n\nconst editorsRegistry = registry.category(\"studio_editors\");\nconst viewRegistry = registry.category(\"views\");\n\nclass EditorOperationsWithSnackbar extends EditorOperations {\n    constructor(params) {\n        super(...arguments);\n        this.snackBar = params.snackBar;\n        this.race = markRaw(new Race());\n    }\n\n    _wrapPromise(prom) {\n        const _prom = super._wrapPromise(prom);\n        this.snackBar.add(this.race.add(_prom));\n        return _prom;\n    }\n}\n\n/**\n * Determines whether a given x2m field has a subview corresponding to archTag.\n * it returns hasArch, true if there is one usable arch already\n * and position, an index, starting at 1, to locate the node via an xpath\n * If there is no arch, hasArch is false, and we expect to go through \"createInlineView\"\n * The position is then the position of the future arch node\n */\nfunction getSubarchPosition(mainArch, xpathToField, archTag) {\n    // get eligible arch nodes, which were not automatically inlined by the server\n    const xpathToArch = `${xpathToField}/${archTag}[not(@studio_subview_inlined)]`;\n    const nodes = getNodesFromXpath(xpathToArch, parseStringToXml(mainArch));\n    let hasArch = false;\n    let position = 1;\n    for (const node of nodes) {\n        // When a subarch has groups=\"somegroup\" and the user doesn't have those groups\n        // The server makes it invisible via the modifiers.\n        if (getModifier(node, \"invisible\") !== \"True\" && getModifier(node, \"invisible\") !== \"1\") {\n            hasArch = true;\n            break;\n        }\n        position++;\n    }\n    return { hasArch, position };\n}\n\n/**\n * Returns the arch of the subview\n *\n * @param {String} mainArch\n * @param {String} xpathToField\n * @param {String} viewType\n * @param {Number} position\n */\nfunction getSubArch(mainArch, xpathToField, archTag, position) {\n    const xpathToView = `${archTag}[${position}]`;\n    const xpathToArch = `${xpathToField}/${xpathToView}`;\n    const nodes = getNodesFromXpath(xpathToArch, parseStringToXml(mainArch));\n    if (nodes.length !== 1) {\n        throw new Error(`Single sub-view arch not found for xpath: ${xpathToArch}`);\n    }\n    return serializeXmlToString(nodes[0]);\n}\n\nfunction buildKey(...args) {\n    return args.join(\"_\");\n}\n\nexport class ViewEditorModel extends Reactive {\n    constructor({ env, services, editionFlow, viewRef }) {\n        super();\n        this._isInEdition = false;\n        this.mode = \"interactive\";\n        this.env = env;\n        this.bus = markRaw(new EventBus());\n        this._services = markRaw(services);\n        this._studio = services.studio;\n\n        this._snackBar = new SnackbarIndicator();\n        this._operations = new EditorOperationsWithSnackbar({\n            do: this._handleOperations.bind(this),\n            onDone: this._handleDone.bind(this),\n            onError: this._handleError.bind(this),\n            snackBar: this._snackBar,\n        });\n\n        this._decorateCall = async (callback, ...args) => {\n            this._services.ui.block();\n            const prom = callback(...args);\n            this._snackBar.add(prom);\n            try {\n                return await prom;\n            } finally {\n                this._services.ui.unblock();\n            }\n        };\n        this._decorateFunction = (callback) => {\n            return async (...args) => {\n                return this._decorateCall(callback, ...args);\n            };\n        };\n\n        this._rpc = services.rpc;\n        this._decoratedRpc = this._decorateFunction(services.rpc);\n\n        this._editionFlow = editionFlow;\n\n        this.GROUPABLE_TYPES = [\"many2one\", \"char\", \"boolean\", \"selection\", \"date\", \"datetime\"];\n\n        this._activeNodeXpath = undefined;\n        this.lastActiveNodeXpath = undefined;\n\n        this._getEditor = memoizeOnce(() => {\n            const viewType = this.viewType;\n            const view = viewRegistry.contains(viewType) ? viewRegistry.get(viewType) : null;\n\n            const editor = editorsRegistry.contains(viewType)\n                ? editorsRegistry.get(viewType)\n                : null;\n\n            // When the mode is interactive, the priority is to get the taylor-made editor if it exists.\n            // otherwise, the priority is to get the view, if it exists (e.g.:, the search editor doesn't have a view)\n            return {\n                getProps: editor ? editor.props : view.props,\n                editor: this.mode === \"interactive\" ? editor || view : view || editor,\n            };\n        });\n\n        this._getControllerProps = memoizeOnce(function () {\n            let { resId, resIds } = this.isEditingSubview\n                ? this._subviewInfo\n                : this._studio.editedControllerState || {};\n            resIds = resIds || [];\n            resId = resId || resIds[0];\n\n            const arch = parseXML(this.arch);\n            if (this.mode !== \"interactive\") {\n                arch.querySelectorAll(`[studio_no_fetch=\"1\"]`).forEach((n) => n.remove());\n            }\n\n            const rootArchNode = this.xmlDoc.firstElementChild;\n            const controllerClasses = Array.from(\n                new Set([\n                    \"o_view_controller\",\n                    `o_${this.viewType}_view`,\n                    ...(rootArchNode.getAttribute(\"class\") || \"\").split(\" \"),\n                ])\n            ).filter((c) => c);\n\n            let controllerProps = {\n                info: {},\n                relatedModels: { ...toRaw(this.viewDescriptions.relatedModels) },\n                useSampleModel: [\"graph\", \"pivot\"].includes(this.viewType),\n                searchMenuTypes: [],\n                className: controllerClasses.join(\" \"),\n                resId,\n                resIds,\n                resModel: this.resModel,\n                arch,\n                fields: { ...toRaw(this.fields) },\n            };\n\n            if (\n                [\"list\", \"tree\", \"form\"].includes(this.viewType) &&\n                this.mode === \"interactive\" &&\n                this._subviewInfo\n            ) {\n                controllerProps.parentRecord = this._subviewInfo.parentRecord;\n            }\n            // if (custom_view_id) {\n            //     // for dashboard\n            //     controllerProps.info.customViewId = custom_view_id;\n            // }\n\n            const { editor, getProps } = this.editorInfo;\n            controllerProps = getProps\n                ? getProps(controllerProps, editor, this.env.config)\n                : controllerProps;\n\n            return markRaw(controllerProps);\n        });\n\n        this.__getDefaultStudioViewProps = memoizeOnce(() => {\n            const editedAction = this._studio.editedAction;\n            let globalState;\n            if (this._views.search && !this.isEditingSubview) {\n                globalState = editedAction.globalState;\n            }\n\n            const context = this._subviewInfo ? this._subviewInfo.context : editedAction.context;\n            const searchModel = this.editorInfo.editor.SearchModel || SearchModel;\n            return {\n                context,\n                resModel: this.resModel,\n                SearchModel: searchModel,\n                setOverlay:\n                    ![\"form\", \"list\", \"tree\", \"kanban\", \"search\"].includes(this.viewType) ||\n                    this.mode !== \"interactive\",\n                display: { controlPanel: false, searchPanel: false },\n                globalState,\n            };\n        });\n\n        this._getActiveNode = memoizeOnce(() => {\n            if (!this.activeNodeXpath) {\n                return undefined;\n            }\n\n            const node = getNodesFromXpath(this.activeNodeXpath, this.xmlDoc)[0];\n            if (!node) {\n                return null;\n            }\n            const isField = node.tagName === \"field\";\n            const attrs = getNodeAttributes(node);\n\n            let field;\n            if (isField) {\n                field = reactive(this.fields[attrs.name]);\n                Object.defineProperty(field, \"label\", {\n                    get() {\n                        return field.string;\n                    },\n                    configurable: true,\n                });\n            }\n            return reactive({\n                arch: node,\n                attrs,\n                xpath: this.activeNodeXpath,\n                field,\n            });\n        });\n\n        this._getUnprocessedXmlDoc = memoizeOnce((arch) => parseStringToXml(arch));\n\n        this.breadcrumbs = editionFlow.breadcrumbs;\n\n        this._editionFlow = editionFlow;\n\n        this._views = {};\n\n        this.studioViewArch = \"\";\n        this.viewDescriptions = {\n            relatedModels: {},\n            fields: [],\n        };\n        this.viewRef = viewRef;\n\n        this.showInvisible = false;\n\n        // Keep track of the current sidebarTab to be able to\n        // restore it when switching back from the xml editor\n        // to the interactive editor.\n        this._currentSidebarTab = undefined;\n\n        this._getFieldsAllowedRename = memoizeOnce(() => {\n            return new Set();\n        });\n    }\n\n    //-----------------------------------------------------------------\n    // Public getters and setters\n    //-----------------------------------------------------------------\n    get editorInfo() {\n        return this._getEditor(buildKey(this.viewType, this.mode));\n    }\n\n    get controllerProps() {\n        const key = buildKey(\n            this.arch,\n            this.viewType,\n            this.mode,\n            this.resModel,\n            this.breadcrumbs.length > 1 ? this.breadcrumbs.length : 1\n        );\n        return this._getControllerProps(key);\n    }\n\n    get studioViewProps() {\n        const key = buildKey(this.viewType, this.resModel, this.mode, this.isEditingSubview);\n        return this.__getDefaultStudioViewProps(key);\n    }\n\n    get xmlDoc() {\n        return this._getUnprocessedXmlDoc(this.arch);\n    }\n\n    get isEditingSubview() {\n        return this.breadcrumbs.length > 1;\n    }\n\n    set isInEdition(value) {\n        value = !!value; // enforce boolean\n        if (this.isInEdition === value) {\n            return;\n        }\n        this._isInEdition = value;\n        if (value) {\n            this._services.ui.block();\n        } else {\n            this._services.ui.unblock();\n        }\n    }\n\n    get isInEdition() {\n        return this._isInEdition;\n    }\n\n    get mainView() {\n        return this._views ? this._views[this.mainViewType] : undefined;\n    }\n\n    get mainArch() {\n        return this.mainView ? this.mainView.arch : \"\";\n    }\n\n    get mainViewType() {\n        return this._studio.editedViewType;\n    }\n\n    get mainResModel() {\n        return this._studio.editedAction.res_model;\n    }\n\n    get arch() {\n        return this.isEditingSubview ? this._subviewInfo.getArch(this.mainArch) : this.mainArch;\n    }\n\n    get viewType() {\n        return this.isEditingSubview ? this._subviewInfo.viewType : this.mainViewType;\n    }\n\n    get view() {\n        return this._views[this.viewType];\n    }\n\n    get resModel() {\n        return this.isEditingSubview ? this._subviewInfo.resModel : this.mainResModel;\n    }\n\n    get fields() {\n        return this.viewDescriptions.relatedModels[this.resModel];\n    }\n\n    get activeNode() {\n        return this._getActiveNode(buildKey(this.activeNodeXpath, this.arch));\n    }\n\n    get studioViewKey() {\n        return buildKey(this.arch, JSON.stringify(this.fields));\n    }\n\n    get fieldsInArch() {\n        return getFieldsInArch(this.xmlDoc);\n    }\n\n    get isChatterAllowed() {\n        return !this.isEditingSubview && this._isChatterAllowed;\n    }\n\n    get activeNodeXpath() {\n        return this._activeNodeXpath;\n    }\n\n    set activeNodeXpath(value) {\n        this._activeNodeXpath = value;\n        if (value) {\n            this.lastActiveNodeXpath = value;\n        }\n    }\n\n    get sidebarTab() {\n        if (this.activeNodeXpath) {\n            return \"properties\";\n        }\n        return this._currentSidebarTab;\n    }\n\n    set sidebarTab(newTab) {\n        this._currentSidebarTab = newTab;\n    }\n\n    //-----------------------------------------------------------------\n    // Public methods\n    //-----------------------------------------------------------------\n\n    async editX2ManyView({ viewType, fieldName, record, xpath, fieldContext }) {\n        const staticList = record.data[fieldName];\n        const resIds = staticList.records.map((r) => r.resId);\n        const resModel = staticList.resModel;\n        const archTag = viewType === \"list\" ? \"tree\" : viewType;\n\n        // currentFullXpath is the absolute xpath to the current edited subview as a function of the whole full arch\n        // while xpath is the absolute xpath to the field we want to edit a subarch for, as a function of its subArch\n        // currentFullXpath: /form[x]/field[y]/form[z]\n        // xpath: /form[g]/field[h]/form[i]\n        // Where form[z] and form[g] do point to the same subArch\n        // We need to combine them to get a xpath of the field's arch we want to edit as a function of the entire main arch\n        // what we want: /form[x]/field[y]/form[z]/field[h]/form[i]\n        const currentFullXpath = this.getSubviewXpath();\n        let xpathToField = xpath;\n        if (currentFullXpath) {\n            const xpathWithoutView = xpath.split(\"/\").slice(2);\n            xpathToField = `${currentFullXpath}/${xpathWithoutView.join(\"/\")}`;\n        }\n\n        const { hasArch, position } = getSubarchPosition(this.mainArch, xpathToField, archTag);\n        if (!hasArch) {\n            const subViewRef = fieldContext[`${archTag}_view_ref`] || null;\n            this.studioViewArch = await this._createInlineView({\n                subViewType: viewType,\n                fullXpath: xpathToField,\n                subViewRef,\n                resModel,\n                fieldName,\n            });\n            const viewDescriptions = await this._editionFlow.loadViews();\n            this.viewDescriptions = viewDescriptions;\n            Object.assign(this._views, viewDescriptions.views);\n            this._operations.clear(false);\n        }\n        await this._decorateCall(() => this.fieldsGet(resModel));\n\n        const context = Object.fromEntries(\n            Object.entries(fieldContext).filter(([key, val]) => {\n                return !key.startsWith(\"default_\") && !key.endsWith(\"_view_ref\");\n            })\n        );\n\n        const x2ManyEditionInfo = {\n            name: sprintf(\"Subview %s\", viewTypeToString(viewType)),\n            context,\n            resModel,\n            resId: resIds[0],\n            resIds,\n            viewType,\n            parentRecord: record,\n            xpath: `${xpath}/${archTag}[${position}]`, // /form[x]/field[y]/tree[z]\n            fieldName,\n            getArch: memoizeOnce((mainArch) => {\n                return getSubArch(mainArch, xpathToField, archTag, position);\n            }),\n        };\n        this._editionFlow.pushBreadcrumb(x2ManyEditionInfo);\n    }\n\n    async fieldsGet(resModel) {\n        this.fieldsGetCache = this.fieldsGetCache || new Set();\n        if (!this.fieldsGetCache.has(resModel)) {\n            const fg = await this._services.orm.call(resModel, \"fields_get\");\n            this.fieldsGetCache.add(resModel);\n            Object.assign(this.viewDescriptions.relatedModels[resModel], fg);\n        }\n    }\n\n    async load() {\n        const proms = [this._editionFlow.loadViews({ forceSearch: true })];\n\n        if (this.viewType === \"form\") {\n            proms.push(this._studio.isAllowed(\"chatter\", this.mainResModel));\n        }\n\n        const [viewDescriptions, isChatterAllowed] = await Promise.all(proms);\n        this._isChatterAllowed = isChatterAllowed;\n        this.viewDescriptions = viewDescriptions || {\n            relatedModels: {},\n            fields: [],\n        };\n        Object.assign(this._views, viewDescriptions.views);\n        const { mainViewId, viewId, arch } = await this._getStudioViewArch();\n        this.studioViewArch = arch;\n        this.studioViewId = viewId;\n        if (!this.mainView.id) {\n            // the call to getStudioViewArch has created the view in DB (before that, it was the default_view)\n            // Clear the caches, in particular the one of the viewService to aknowledge that.\n            this.env.bus.trigger(\"CLEAR-CACHES\");\n            this.mainView.id = mainViewId;\n        }\n    }\n\n    getSubviewXpath() {\n        if (!this.isEditingSubview) {\n            return null;\n        }\n        const temp = [`/${this.mainViewType === \"list\" ? \"tree\" : this.mainViewType}[1]`];\n        this.breadcrumbs.slice(1).forEach(({ data }) => {\n            const withoutView = data.xpath.split(\"/\").slice(2);\n            temp.push(...withoutView);\n        });\n        return temp.join(\"/\");\n    }\n\n    getFullTarget(xpath, { isXpathFullAbsolute = true } = {}) {\n        const nodes = getNodesFromXpath(xpath, this.xmlDoc);\n        if (nodes.length !== 1) {\n            throw new Error(\"Xpath resolved to nothing or multiple nodes\");\n        }\n        const element = nodes[0];\n\n        // Attributes that could be used to identify the node python side, it is mandatory\n        // Although it might be more robust to rely solely on a sufficiently expressive xpath\n        const attrs = {};\n        [\"name\", \"id\", \"class\", \"for\"].forEach((attrName) => {\n            if (element.hasAttribute(attrName)) {\n                attrs[attrName] = element.getAttribute(attrName);\n            }\n        });\n\n        let xpath_info;\n        if (isXpathFullAbsolute) {\n            xpath_info = xpathToLegacyXpathInfo(xpath);\n        } else {\n            const fullAbsolute = computeXpath(\n                element,\n                this.viewType === \"list\" ? \"tree\" : this.viewType\n            );\n            xpath_info = xpathToLegacyXpathInfo(fullAbsolute);\n        }\n\n        const target = {\n            tag: element.tagName,\n            attrs,\n            xpath_info,\n        };\n\n        const subViewXpath = this.getSubviewXpath();\n        if (subViewXpath) {\n            target.subview_xpath = subViewXpath;\n\n            const subViewTargetInfo = xpathToLegacyXpathInfo(subViewXpath);\n            xpath_info.splice(0, 1, subViewTargetInfo[subViewTargetInfo.length - 1]);\n        }\n        return target;\n    }\n\n    async doOperation(operation, write = true) {\n        return this._operations.do(operation, !write);\n    }\n\n    pushOperation(operation) {\n        return this._operations.pushOp(operation);\n    }\n\n    /** Mode and Sidebar */\n    resetSidebar(tab = null) {\n        this.sidebarTab = tab;\n        // store the last active xpath in this variable\n        this.activeNodeXpath = undefined;\n\n        const resetEl = this.viewRef.el;\n        if (resetEl) {\n            cleanClickedElements(resetEl);\n        }\n    }\n\n    switchMode() {\n        resetViewCompilerCache();\n        this.mode = this.mode === \"interactive\" ? \"xml\" : \"interactive\";\n    }\n\n    /** Field Renaming */\n    setRenameableField(fieldName, add = true) {\n        if (add) {\n            this._fieldsAllowedRename.add(fieldName);\n        } else {\n            this._fieldsAllowedRename.delete(fieldName);\n        }\n    }\n\n    isFieldRenameable(fieldName) {\n        return this._fieldsAllowedRename.has(fieldName);\n    }\n\n    async renameField(fieldName, newName, { label, autoUnique = true } = {}) {\n        // Sanitization\n        newName = newName\n            .toLowerCase()\n            .trim()\n            .replace(/[^\\w\\s-]/g, \"\") // remove non-word [a-z0-9_], non-whitespace, non-hyphen characters\n            .replace(/[\\s_-]+/g, \"_\") // swap any length of whitespace, underscore, hyphen characters with a single _\n            .replace(/^-+|-+$/g, \"\"); // remove leading, trailing\n\n        if (!newName.startsWith(\"x_studio_\")) {\n            newName = `x_studio_${newName}`;\n        }\n\n        const existingFields = this.fields;\n        if (autoUnique) {\n            const baseName = newName;\n            let index = 1;\n            while (newName in existingFields) {\n                newName = baseName + \"_\" + index;\n                index++;\n            }\n        }\n\n        if (!autoUnique && newName in existingFields) {\n            this._services.dialog.add(AlertDialog, {\n                body: _t(\"A field with the same name already exists.\"),\n            });\n            return;\n        }\n        this.isInEdition = true;\n        const prom = this._rpc(\"/web_studio/rename_field\", {\n            studio_view_id: this.studioViewId,\n            studio_view_arch: this.studioViewArch,\n            model: this.resModel,\n            old_name: fieldName,\n            new_name: newName,\n            new_label: label,\n        });\n\n        this._snackBar.add(prom);\n\n        try {\n            await prom;\n        } catch (e) {\n            this.isInEdition = false;\n            throw e;\n        }\n\n        const strOperations = JSON.stringify(this._operations.operations);\n        // We only want to replace exact matches of the field name, but it can\n        // be preceeded/followed by other characters, like parent.my_field or in\n        // a domain like [('...', '...', my_field)] etc.\n        // Note that negative lookbehind is not correctly handled in JS ...\n        const chars = \"[^\\\\w\\\\u007F-\\\\uFFFF]\";\n        const re = new RegExp(`(${chars}|^)${fieldName}(${chars}|$)`, \"g\");\n        this._operations.clear();\n        this.setRenameableField(fieldName, false);\n        this.setRenameableField(newName, true);\n        this._operations.doMulti(JSON.parse(strOperations.replace(re, `$1${newName}$2`)));\n    }\n\n    //-----------------------------------------------------------------\n    // Private\n    //-----------------------------------------------------------------\n\n    async _createInlineView({ subViewType, fullXpath, subViewRef, resModel, fieldName }) {\n        subViewType = subViewType === \"list\" ? \"tree\" : subViewType;\n        // We build the correct xpath if we are editing a 'sub' subview\n        // Use specific view if available in context\n        // We write views in the base language to make sure we do it on the source term field\n        // of ir.ui.view\n        const context = { ...this._services.user.context, lang: false, studio: true };\n        if (subViewRef) {\n            context[`${subViewType}_view_ref`] = subViewRef;\n        }\n\n        // FIXME: maybe this route should return def _return_view\n        const studioViewArch = await this._decoratedRpc(\"/web_studio/create_inline_view\", {\n            model: resModel,\n            view_id: this.mainView.id,\n            field_name: fieldName,\n            subview_type: subViewType,\n            subview_xpath: fullXpath,\n            context,\n        });\n        this.env.bus.trigger(\"CLEAR-CACHES\");\n        return studioViewArch;\n    }\n\n    /** Arch Edition */\n    async _editView(operations) {\n        const context = {\n            ...this._services.user.context,\n            ...(this._studio.editedAction.context || {}),\n            lang: false,\n            studio: true,\n        };\n        return this._rpc(\"/web_studio/edit_view\", {\n            view_id: this.mainView.id,\n            studio_view_arch: this.studioViewArch,\n            operations: operations,\n            model: this.resModel,\n            context,\n        });\n    }\n\n    async _editViewArch(viewId, viewArch) {\n        // We write views in the base language to make sure we do it on the source term field\n        // of ir.ui.view\n        const context = {\n            ...this._services.user.context,\n            ...(this._studio.editedAction.context || {}),\n            lang: false,\n            studio: true,\n        };\n        const result = await this._rpc(\"/web_studio/edit_view_arch\", {\n            view_id: viewId,\n            view_arch: viewArch,\n            context,\n        });\n        return result;\n    }\n\n    async _handleOperations({ mode, operations, lastOp }) {\n        this.isInEdition = true;\n        if (lastOp.type !== \"replace_arch\") {\n            operations = operations.filter((op) => op.type !== \"replace_arch\");\n            return this._editView(operations);\n        } else {\n            const viewId = lastOp.viewId;\n            let { newArch, oldArch } = lastOp;\n            if (mode === \"undo\") {\n                const _newArch = newArch;\n                newArch = oldArch;\n                oldArch = _newArch;\n            }\n            return this._editViewArch(viewId, newArch);\n        }\n    }\n\n    async restoreDefaultView(viewId) {\n        const result = await this._editionFlow.restoreDefaultView(viewId, this.mainViewType);\n        if (result) {\n            this.viewDescriptions.relatedModels = result.models;\n            this._views[this.mainViewType].arch = result.views[this.mainViewType].arch;\n            this._operations.clear();\n        }\n    }\n\n    _handleDone({ mode, pending, pendingUndone, result }) {\n        this.env.bus.trigger(\"CLEAR-CACHES\");\n        if (result) {\n            this.viewDescriptions.relatedModels = result.models;\n\n            const oldArch = this._views[this.mainViewType].arch;\n            const newArch = result.views[this.mainViewType].arch;\n            this._views[this.mainViewType].arch = newArch;\n            if (oldArch === newArch) {\n                this.isInEdition = false;\n            }\n\n            if (!this.studioViewId && result.studio_view_id) {\n                this.studioViewId = result.studio_view_id;\n            }\n        }\n\n        const isUndoing = mode === \"undo\";\n        const pendingOps = isUndoing ? pendingUndone : pending;\n        const lastOperation = pendingOps[pendingOps.length - 1];\n        if (lastOperation && lastOperation.type === \"replace_arch\") {\n            if (lastOperation.viewId === this.studioViewId) {\n                this.studioViewArch = isUndoing ? lastOperation.oldArch : lastOperation.newArch;\n                this._operations.clear();\n                const ops = isUndoing ? this._operations.undone : this._operations.operations;\n                ops.push(lastOperation);\n            }\n        }\n    }\n\n    async _handleError({ mode, pending, error }) {\n        this.isInEdition = false;\n        this._services.notification.add(\n            _t(\"This operation caused an error, probably because a xpath was broken\"),\n            {\n                type: \"danger\",\n                title: _t(\"Error\"),\n            }\n        );\n\n        Promise.resolve().then(() => {\n            throw error;\n        });\n\n        this.resetSidebar(\"view\");\n        this.bus.trigger(\"error\");\n    }\n\n    async _getStudioViewArch() {\n        const result = await this._rpc(\"/web_studio/get_studio_view_arch\", {\n            model: this.resModel,\n            view_type: this.viewType,\n            view_id: this.mainView.id,\n            context: { ...this._services.user.context, lang: false },\n        });\n        return {\n            arch: result.studio_view_arch,\n            viewId: result.studio_view_id,\n            mainViewId: result.main_view_id,\n        };\n    }\n\n    get _subviewInfo() {\n        if (!this.isEditingSubview) {\n            return null;\n        }\n        const length = this.breadcrumbs.length;\n        return this.breadcrumbs[length - 1].data;\n    }\n\n    get _fieldsAllowedRename() {\n        return this._getFieldsAllowedRename(\n            this.breadcrumbs.length > 1 ? this.breadcrumbs.length : 1\n        );\n    }\n}\n\nexport function useEditNodeAttributes({ isRoot = false } = {}) {\n    const vem = useEnv().viewEditorModel;\n    function editNodeAttributes(newAttributes) {\n        let target;\n        let node;\n        if (isRoot) {\n            target = vem.getFullTarget(`/${vem.viewType === \"list\" ? \"tree\" : vem.viewType}`);\n            target.isSubviewAttr = true;\n        } else {\n            target = vem.getFullTarget(vem.activeNodeXpath);\n            const { arch, attrs } = vem.activeNode;\n            node = {\n                tag: arch.tagName,\n                attrs,\n            };\n        }\n\n        const operation = {\n            new_attrs: newAttributes,\n            type: \"attributes\",\n            position: \"attributes\",\n            target,\n        };\n        if (node) {\n            operation.node = node;\n        }\n        return vem.doOperation(operation);\n    }\n    return editNodeAttributes;\n}\n", "/** @odoo-module */\nimport { Component } from \"@odoo/owl\";\n\nexport class ViewEditorSnackbar extends Component {\n    static template = \"web_studio.ViewEditor.Snackbar\";\n    static props = {\n        operations: Object,\n        saveIndicator: Object,\n    };\n}\n", "/** @odoo-module */\nimport { Component, useState } from \"@odoo/owl\";\n\nimport { _t } from \"@web/core/l10n/translation\";\n\nexport class ExistingFields extends Component {\n    static props = {\n        fieldsInArch: { type: Array },\n        fields: { type: Object },\n        filterFields: { type: Boolean, optional: true },\n        folded: { type: Boolean, optional: true },\n        resModel: { type: String, optional: true },\n    };\n    static defaultProps = {\n        folded: true,\n        filterFields: true,\n        resModel: \"\",\n    };\n    static template = \"web_studio.ViewStructures.ExistingFields\";\n\n    setup() {\n        this.state = useState({\n            folded: this.props.folded,\n            searchValue: \"\",\n        });\n    }\n\n    isMatchingSearch(field) {\n        if (!this.state.searchValue) {\n            return true;\n        }\n        const search = this.state.searchValue.toLowerCase();\n        let matches = field.string.toLowerCase().includes(search);\n        if (!matches && this.env.debug && field.name) {\n            matches = field.name.toLowerCase().includes(search);\n        }\n        return matches;\n    }\n\n    get existingFields() {\n        const fieldsInArch = this.props.fieldsInArch;\n        const resModel = this.props.resModel;\n        const filtered = Object.entries(this.props.fields).filter(([fName, field]) => {\n            if (resModel === \"res.users\" && (fName.startsWith(\"in_group_\") || fName.startsWith(\"sel_groups_\"))) {\n                // These fields are virtual and represent res.groups hierarchy.\n                // If the hierarchy changes, the field is replaced by another one and the view will be\n                // broken, so, here we prevent adding them.\n                return false;\n            }\n            if (!this.isMatchingSearch(field) || this.props.filterFields && fieldsInArch.includes(fName)) {\n                return false;\n            }\n            return true;\n        });\n\n        return filtered.map(([fName, field]) => {\n            return {\n                ...field,\n                name: fName,\n                classType: field.type,\n                dropData: JSON.stringify({ fieldName: fName }),\n            };\n        });\n    }\n\n    getDropInfo(field) {\n        return {\n            structure: \"field\",\n            fieldName: field.name,\n            isNew: false,\n        };\n    }\n}\n\nconst newFields = [\n    { type: \"char\", string: _t(\"Text\") },\n    { type: \"text\", string: _t(\"Multine Text\") },\n    { type: \"integer\", string: _t(\"Integer\") },\n    { type: \"float\", string: _t(\"Decimal\") },\n    { type: \"html\", string: _t(\"HTML\") },\n    { type: \"monetary\", string: _t(\"Monetary\") },\n    { type: \"date\", string: _t(\"Date\") },\n    { type: \"datetime\", string: _t(\"Datetime\") },\n    { type: \"boolean\", string: _t(\"CheckBox\") },\n    { type: \"selection\", string: _t(\"Selection\") },\n    { type: \"binary\", string: _t(\"File\"), widget: \"file\" },\n    { type: \"one2many\", string: _t(\"Lines\"), special: \"lines\" },\n    { type: \"one2many\", string: _t(\"One2Many\") },\n    { type: \"many2one\", string: _t(\"Many2One\") },\n    { type: \"many2many\", string: _t(\"Many2Many\") },\n    { type: \"binary\", string: _t(\"Image\"), widget: \"image\", name: \"picture\" },\n    { type: \"many2many\", string: _t(\"Tags\"), widget: \"many2many_tags\", name: \"tags\" },\n    { type: \"selection\", string: _t(\"Priority\"), widget: \"priority\" },\n    { type: \"binary\", string: _t(\"Signature\"), widget: \"signature\" },\n    { type: \"related\", string: _t(\"Related Field\") },\n];\n\nexport class NewFields extends Component {\n    static props = {};\n    static template = \"web_studio.ViewStructures.NewFields\";\n\n    get newFieldsComponents() {\n        return newFields.map((f) => {\n            const classType = f.special || f.name || f.widget || f.type;\n            return {\n                ...f,\n                name: classType,\n                classType,\n                dropData: JSON.stringify({\n                    fieldType: f.type,\n                    widget: f.widget,\n                    name: f.name,\n                    special: f.special,\n                    string: f.string,\n                }),\n            };\n        });\n    }\n}\n", "/** @odoo-module */\nimport { Component, onWillStart, onWillUpdateProps, toRaw, useState } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { CodeEditor } from \"@web/core/code_editor/code_editor\";\nimport { ResizablePanel } from \"@web/core/resizable_panel/resizable_panel\";\nimport { SelectMenu } from \"@web/core/select_menu/select_menu\";\nimport { useService } from \"@web/core/utils/hooks\";\n\nclass ViewSelector extends SelectMenu {\n    static template = \"web_studio.ViewSelector\";\n    static choiceItemTemplate = \"web_studio.ViewSelector.ChoiceItemRecursive\";\n    static props = {\n        ...SelectMenu.props,\n        choices: {\n            optional: true,\n            type: Array,\n            element: {\n                type: Object,\n                shape: {\n                    value: true,\n                    label: { type: String },\n                    resource: { optional: true },\n                },\n            },\n        },\n    };\n\n    getMainViews() {\n        return this.state.displayedOptions.filter((opt) => opt.resource.isMainResource);\n    }\n\n    getInherited(choice) {\n        const inheritedChoices = this.state.displayedOptions.filter(\n            (opt) => (opt.resource.inherit_id || [])[0] === choice.resource.id\n        );\n        if (inheritedChoices.length) {\n            inheritedChoices.forEach((opt) => (opt.resource.relatedChoice = choice.resource.id));\n        }\n        return inheritedChoices;\n    }\n\n    getComposedBy(choice) {\n        const resource = choice.resource;\n        if (!resource.called_xml_ids) {\n            return [];\n        }\n        const composedChoices = this.state.displayedOptions.filter(\n            (opt) =>\n                resource.called_xml_ids.includes(opt.resource.xml_id) ||\n                resource.called_xml_ids.includes(opt.resource.key)\n        );\n        if (composedChoices.length) {\n            composedChoices.forEach((opt) => (opt.resource.relatedChoice = resource.id));\n        }\n        return composedChoices;\n    }\n\n    // Parents of displayed options must also be visible when doing a search\n    // Based on the filtered choices, they must be added from the list of choices\n    sliceDisplayedOptions() {\n        const childChoices = this.state.choices.filter((c) => c.resource.relatedChoice);\n        childChoices.forEach((c) => this.addRelatedChoice(c.resource.relatedChoice));\n        super.sliceDisplayedOptions();\n    }\n\n    addRelatedChoice(parentId) {\n        if (this.state.choices.findIndex((c) => c.resource.id === parentId) === -1) {\n            const parent = this.props.choices.find((c) => c.resource.id === parentId);\n            if (!parent.resource.isMainResource) {\n                this.addRelatedChoice(parent.resource.relatedChoice);\n            }\n            this.state.choices.push(parent);\n        }\n    }\n}\n\nexport class XmlResourceEditor extends Component {\n    static template = \"web_studio.XmlResourceEditor\";\n    static components = { ResizablePanel, CodeEditor, SelectMenu: ViewSelector };\n    static props = {\n        onClose: { type: Function },\n        onCodeChange: { type: Function, optional: true },\n        onSave: { type: Function, optional: true },\n        mainResourceId: { type: true },\n        defaultResourceId: { type: true, optional: true },\n        getDefaultResource: { optional: true, type: Function },\n        canSave: { type: Boolean, optional: true },\n        minWidth: { type: Number, optional: true },\n        reloadSources: { type: Number, optional: true },\n        displayAlerts: { type: Boolean, optional: true },\n        onResourceChange: { type: Function, optional: true },\n    };\n    static defaultProps = {\n        canSave: true,\n        minWidth: 400,\n        reloadSources: 1,\n        displayAlerts: true,\n        onResourceChange: () => {},\n        getDefaultResource: () => {},\n    };\n\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.state = useState({\n            resourcesOptions: [],\n            currentResourceId: null,\n            _codeChanges: null,\n        });\n        this.codeEditorKey = this.props.reloadSources;\n        onWillStart(() => this.loadResources(this.props.mainResourceId));\n\n        onWillUpdateProps(async (nextProps) => {\n            const shouldReload =\n                nextProps.mainResourceId !== this.props.mainResourceId ||\n                this.codeEditorKey !== nextProps.reloadSources;\n            const nextResourceId =\n                nextProps.mainResourceId !== this.props.mainResourceId\n                    ? nextProps.mainResourceId\n                    : this.state.currentResourceId;\n\n            if (shouldReload) {\n                this.state._codeChanges = null;\n                await this.loadResources(nextProps.mainResourceId);\n                this.state.currentResourceId = nextResourceId;\n            }\n            this.codeEditorKey = nextProps.reloadSources;\n        });\n\n        this.alerts = useState({\n            \"built-in-file\": {\n                message: _t(\n                    \"Editing a built-in file through this editor is not advised, as it will prevent it from being updated during future App upgrades.\"\n                ),\n                display: true,\n            },\n        });\n    }\n\n    get minWidth() {\n        return this.props.minWidth;\n    }\n\n    get arch() {\n        const currentResourceId = this.state.currentResourceId;\n        if (!currentResourceId) {\n            return \"\";\n        }\n        return this.tempCode || this.getResourceFromId(currentResourceId).arch;\n    }\n\n    get tempCode() {\n        if (!this.state.currentResourceId) {\n            return \"\";\n        }\n        return this.state._codeChanges && this.state._codeChanges[this.state.currentResourceId];\n    }\n\n    set tempCode(value) {\n        if (!this.state.currentResourceId) {\n            return;\n        }\n        this.state._codeChanges = this.state._codeChanges || {};\n        this.state._codeChanges[this.state.currentResourceId] = value;\n    }\n\n    getResourceFromId(resourceId) {\n        const opt = this.state.resourcesOptions.find((opt) => opt.value === resourceId) || {};\n        return opt.resource;\n    }\n\n    onFormat() {\n        this.tempCode = window.vkbeautify.xml(this.tempCode || this.arch, 4);\n    }\n\n    hideAlert(alertKey) {\n        this.alerts[alertKey].display = false;\n    }\n\n    onCloseClick() {\n        this.props.onClose();\n    }\n\n    onCodeChange(code) {\n        this.tempCode = code;\n        if (\"onCodeChange\" in this.props) {\n            this.props.onCodeChange({ ...toRaw(this.state._codeChanges) });\n        }\n    }\n\n    onSaveClick() {\n        if (!this.tempCode) {\n            return;\n        }\n        const resource = this.getResourceFromId(this.state.currentResourceId);\n        this.props.onSave({\n            resourceId: resource.id,\n            newCode: this.tempCode,\n            oldCode: resource.oldArch,\n        });\n    }\n\n    onResourceChange(resourceId) {\n        this.state.currentResourceId = resourceId;\n        this.props.onResourceChange(this.getResourceFromId(this.state.currentResourceId));\n    }\n\n    async loadResources(resourceId) {\n        const resources = await this.rpc(\"/web_studio/get_xml_editor_resources\", {\n            key: resourceId,\n        });\n\n        const resourcesOptions = resources.views.map((res) => ({\n            label: `${res.name} (${res.xml_id})`,\n            value: res.id,\n            resource: {\n                ...res,\n                oldArch: res.arch,\n                isMainResource:\n                    res.key === resourceId || res.id === resourceId || res.xml_id === resourceId,\n            },\n        }));\n\n        this.state.resourcesOptions = resourcesOptions;\n        if (resourcesOptions.length >= 1) {\n            let defaultResource = this.props.getDefaultResource(\n                resourcesOptions,\n                resources.main_view_key\n            );\n            if (!defaultResource && (this.props.defaultResourceId || resources.main_view_key)) {\n                const defaultId = this.props.defaultResourceId || resources.main_view_key;\n                defaultResource = resourcesOptions.find(\n                    (opt) =>\n                        opt.resource.id === defaultId ||\n                        opt.resource.xml_id === defaultId ||\n                        opt.resource.key === defaultId\n                );\n            }\n            defaultResource = defaultResource || resourcesOptions[0];\n            this.state.currentResourceId = defaultResource.value;\n        }\n\n        return resourcesOptions;\n    }\n}\n", "/** @odoo-module */\n\nimport { Component } from \"@odoo/owl\";\nimport { Dialog } from \"@web/core/dialog/dialog\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { useService } from \"@web/core/utils/hooks\";\n\nexport class NewReportDialog extends Component {\n    setup() {\n        this.rpc = useService(\"rpc\");\n        this.user = useService(\"user\");\n        this.layouts = [\n            {\n                name: \"web.external_layout\",\n                label: _t(\"External\"),\n                description: _t(\"Business header/footer\"),\n            },\n            {\n                name: \"web.internal_layout\",\n                label: _t(\"Internal\"),\n                description: _t(\"Minimal header/footer\"),\n            },\n            {\n                name: \"web.basic_layout\",\n                label: _t(\"Blank\"),\n                description: _t(\"No header/footer\"),\n            },\n        ];\n    }\n\n    async createNewReport(layout) {\n        const report = await this.rpc(\"/web_studio/create_new_report\", {\n            model_name: this.props.resModel,\n            layout,\n            context: this.user.context,\n        });\n        this.props.onReportCreated(report);\n        this.props.close();\n    }\n}\nNewReportDialog.template = \"web_studio.NewReportDialog\";\nNewReportDialog.components = { Dialog };\nNewReportDialog.props = [\"resModel\", \"onReportCreated\", \"close\"];\n", "/** @odoo-module */\n\nimport { registry } from \"@web/core/registry\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { kanbanView } from \"@web/views/kanban/kanban_view\";\nimport { KanbanController } from \"@web/views/kanban/kanban_controller\";\n\nimport { NewReportDialog } from \"./new_report_dialog\";\n\nclass StudioReportKanbanController extends KanbanController {\n    setup() {\n        super.setup();\n        this.actionService = useService(\"action\");\n        this.dialogService = useService(\"dialog\");\n        this.orm = useService(\"orm\");\n    }\n    createRecord() {\n        this.dialogService.add(NewReportDialog, {\n            resModel: this.props.context.default_model,\n            onReportCreated: (report) => {\n                this.openRecord({ data: report, resId: report.id });\n            },\n        });\n    }\n\n    openRecord(record) {\n        return this.actionService.doAction(\"web_studio.action_edit_report\", {\n            report: {\n                data: record.data,\n                res_id: record.resId,\n            },\n        });\n    }\n}\n\nconst studioReportKanbanView = {\n    ...kanbanView,\n    Controller: StudioReportKanbanController,\n};\n\nregistry.category(\"views\").add(\"studio_report_kanban\", studioReportKanbanView);\n", "/** @odoo-module */\nimport { Component, onWillStart, useState } from \"@odoo/owl\";\nimport { useService } from \"@web/core/utils/hooks\";\nimport { registry } from \"@web/core/registry\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { standardActionServiceProps } from \"@web/webclient/actions/action_service\";\nimport { DropdownItem } from \"@web/core/dropdown/dropdown_item\";\nimport { Dropdown } from \"@web/core/dropdown/dropdown\";\n\nclass WebsiteIntegrator extends Component {\n    static template = \"website_studio.WebsiteIntegrator\";\n    static props = { ...standardActionServiceProps };\n    static components = { Dropdown, DropdownItem };\n\n    setup() {\n        this.studio = useService(\"studio\");\n        this.rpc = useService(\"rpc\");\n        this.orm = useService(\"orm\");\n        this.action = useService(\"action\");\n        this.user = useService(\"user\");\n        this.notification = useService(\"notification\");\n        this.state = useState({ forms: [] });\n        this.isDesigner = false;\n        this.hasMultiWebsite = false;\n\n        this.pageGroups = [\n            {\n                name: _t(\"Listings\"),\n                type: \"listing\",\n                description: _t(\"Display records on your website, in a list or card format\"),\n                iconData: {\n                    src: \"/web_studio/static/src/img/view_type/list.png\",\n                    alt: \"view Listing\",\n                },\n            },\n            {\n                name: _t(\"Pages\"),\n                type: \"single\",\n                description: _t(\n                    \"Display a detailed page for a single record on a page of your website\"\n                ),\n                iconData: {\n                    src: \"/web_studio/static/src/img/view_type/form.png\",\n                    alt: \"view Page\",\n                },\n            },\n        ];\n\n        onWillStart(() => {\n            return Promise.all([\n                this.loadExistingForms(),\n                this.loadWebsitePages(),\n                this.user\n                    .hasGroup(\"website.group_website_designer\")\n                    .then((r) => (this.isDesigner = r)),\n                    this.user\n                    .hasGroup(\"website.group_multi_website\")\n                    .then((r) => (this.hasMultiWebsite = r)),\n            ]);\n        });\n    }\n\n    get resModel() {\n        return this.studio.editedAction.res_model;\n    }\n\n    async loadWebsitePages() {\n        const res = await this.rpc(\"/website_studio/get_website_pages\", {\n            res_model: this.resModel,\n        });\n\n        this.state.websites = res.websites;\n        this.state.pages = res.pages;\n    }\n\n    getWebsites() {\n        return [{ id: false, display_name: _t(\"All Websites\") }, ...this.state.websites];\n    }\n\n    getPages(type, websiteId) {\n        return this.state.pages.filter(\n            (p) =>\n                p.page_type === type && ((p.website_id && p.website_id[0]) || false) === websiteId\n        );\n    }\n\n    async loadExistingForms() {\n        const forms = await this.rpc(\"/website_studio/get_forms\", {\n            res_model: this.resModel,\n        });\n        this.state.forms = forms;\n    }\n\n    async onNewForm() {\n        if (this.isDesigner) {\n            const url = await this.rpc(\"/website_studio/create_form\", {\n                res_model: this.resModel,\n            });\n            this.loadExistingForms(); // don't wait\n            return this.openFormUrl(url);\n        } else {\n            this.notification.add(\n                _t(\n                    \"Sorry, only users with the following\" +\n                        \" access level are currently allowed to do that:\" +\n                        \" 'Website/Editor and Designer'\"\n                ),\n                {\n                    title: _t(\"Error\"),\n                    type: \"danger\",\n                }\n            );\n        }\n    }\n\n    openFormUrl(url) {\n        return this.action.doAction({ type: \"ir.actions.act_url\", url: `${url}?enable_editor=1` });\n    }\n\n    computePageUrl(page) {\n        let url = `/model/${page.name_slugified}`;\n        if (page.page_type === \"single\") {\n            url += \"/<string:record_slug>\";\n        }\n        return url;\n    }\n\n    openPageUrl(page) {\n        return this.action.doAction({\n            type: \"ir.actions.act_url\",\n            url: `${this.computePageUrl(page)}?enable_editor=1`,\n        });\n    }\n\n    onConfigurePage(page) {\n        return this.action.doAction(\n            {\n                type: \"ir.actions.act_window\",\n                target: \"new\",\n                res_id: page.id,\n                res_model: \"website.controller.page\",\n                views: [[false, \"form\"]],\n            },\n            {\n                onClose: () => this.loadWebsitePages(),\n            }\n        );\n    }\n\n    onNewPage(type, websiteId) {\n        const context = {\n            form_view_ref: \"website_studio.website_controller_page_form_dialog_new\",\n            default_model: this.resModel,\n            default_website_id: websiteId,\n            default_page_type: type,\n            default_website_published: true,\n            \"website_studio.create_page\": true,\n        };\n        if (type === \"listing\") {\n            context.default_use_menu = true;\n            context.default_auto_single_page = !this.state.pages.filter(\n                (p) => p.page_type === \"single\" && (!p.website_id || p.website_id[0] === websiteId)\n            ).length;\n        }\n\n        return this.action.doAction(\n            {\n                type: \"ir.actions.act_window\",\n                target: \"new\",\n                context,\n                res_model: \"website.controller.page\",\n                views: [[false, \"form\"]],\n            },\n            {\n                onClose: () => this.loadWebsitePages(),\n            }\n        );\n    }\n\n    async deletePage(page) {\n        await this.orm.unlink(\"website.controller.page\", [page.id]);\n        this.loadWebsitePages();\n    }\n}\n\nregistry.category(\"actions\").add(\"website_studio.action_website_integration\", WebsiteIntegrator);\nregistry.category(\"web_studio.editor_tabs\").add(\"website\", {\n    name: _t(\"Website\"),\n    action: \"website_studio.action_website_integration\",\n});\n"], "file": "/web/assets/b67536a/web_studio.studio_assets.js", "sourceRoot": "../../../"}